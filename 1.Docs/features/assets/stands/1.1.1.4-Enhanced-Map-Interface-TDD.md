# TDD: Enhanced Map Interface with Timeline

**Feature**: Interactive Map with Tooltips, Side Panel, and Timeline Controller  
**Version**: 1.1.1.4  
**Date**: January 2025  
**Owner**: Engineering Team  
**Status**: Ready for Implementation  
**PRD Reference**: 1.1.1.4-Enhanced-Map-Interface-PRD.md

## Technical Architecture

### Component Hierarchy
```
EnhancedStandsPage
├── StandMapInterface (enhanced from 1.1.1.3)
│   ├── MapContainer
│   │   ├── StandMarkers (with tooltip support)
│   │   └── MapTooltip
│   ├── MapControls
│   ├── MapLegend
│   └── TimelineController
│       ├── TimelineBar
│       ├── TimelineScrubber
│       ├── PlaybackControls
│       └── DateRangePicker
├── StandSidePanel
│   ├── PanelHeader
│   ├── PanelTabs
│   │   ├── OverviewTab
│   │   ├── MaintenanceTab
│   │   ├── HistoryTab
│   │   └── AdjacencyTab
│   └── PanelActions
├── StandFilters (existing)
└── StandDataTable (existing)
```

### Technology Stack
- **Core**: React 18, TypeScript, Next.js 15
- **Mapping**: Leaflet.js v1.9.4, React-Leaflet v4.2.1
- **Timeline**: D3.js v7.8.5 for timeline visualization
- **Animation**: Framer Motion v10.16.16 for smooth transitions
- **Date Handling**: date-fns v2.30.0 for date manipulation
- **State Management**: Zustand v4.4.7 for timeline state
- **Styling**: Tailwind CSS, Headless UI for components
- **Real-time**: Socket.io-client v4.7.4 for live updates

## Database Schema Enhancements

### Status History Table Structure
```sql
-- Enhanced StandStatusHistory table
CREATE TABLE IF NOT EXISTS assets.stand_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  stand_id UUID NOT NULL REFERENCES assets.stands(id),
  organization_id UUID NOT NULL,
  status assets.stand_status NOT NULL,
  previous_status assets.stand_status,
  changed_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  changed_by UUID REFERENCES shared.users(id),
  reason TEXT,
  system_generated BOOLEAN DEFAULT FALSE,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  
  CONSTRAINT fk_stand_status_history_organization 
    FOREIGN KEY (organization_id) REFERENCES shared.organizations(id),
  CONSTRAINT fk_stand_status_history_stand 
    FOREIGN KEY (stand_id) REFERENCES assets.stands(id)
);

-- Indexes for timeline queries
CREATE INDEX idx_stand_status_history_timeline 
ON assets.stand_status_history (stand_id, changed_at DESC);

CREATE INDEX idx_stand_status_history_date_range 
ON assets.stand_status_history (organization_id, changed_at);

CREATE INDEX idx_stand_status_history_status 
ON assets.stand_status_history (status, changed_at);
```

### Maintenance Records Enhancement
```sql
-- Enhanced StandMaintenanceRecord table
ALTER TABLE assets.stand_maintenance_records 
ADD COLUMN IF NOT EXISTS timeline_color VARCHAR(7) DEFAULT '#f59e0b',
ADD COLUMN IF NOT EXISTS priority INTEGER DEFAULT 1,
ADD COLUMN IF NOT EXISTS maintenance_type VARCHAR(50) DEFAULT 'routine',
ADD COLUMN IF NOT EXISTS estimated_duration_hours INTEGER,
ADD COLUMN IF NOT EXISTS actual_duration_hours INTEGER,
ADD COLUMN IF NOT EXISTS impact_level VARCHAR(20) DEFAULT 'low';

-- Index for timeline queries
CREATE INDEX idx_maintenance_timeline 
ON assets.stand_maintenance_records (stand_id, scheduled_start_time, scheduled_end_time);
```

## API Endpoints Implementation

### Timeline Data Endpoint
```javascript
// Enhanced API endpoint in simple-db-api.js
app.get('/api/stands/:standId/timeline', async (req, res) => {
  try {
    const { standId } = req.params;
    const { start, end, granularity = 'hour' } = req.query;
    const organizationId = req.headers['x-organization-id'];

    // Validate date range
    const startDate = new Date(start);
    const endDate = new Date(end);
    
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ error: 'Invalid date range' });
    }

    // Get status history
    const statusHistory = await prisma.standStatusHistory.findMany({
      where: {
        standId,
        organizationId,
        changedAt: {
          gte: startDate,
          lte: endDate
        }
      },
      orderBy: { changedAt: 'asc' },
      include: {
        changedByUser: {
          select: { name: true, email: true }
        }
      }
    });

    // Get maintenance records
    const maintenanceRecords = await prisma.standMaintenanceRecord.findMany({
      where: {
        standId,
        organizationId,
        OR: [
          {
            scheduledStartTime: {
              gte: startDate,
              lte: endDate
            }
          },
          {
            scheduledEndTime: {
              gte: startDate,
              lte: endDate
            }
          }
        ]
      },
      orderBy: { scheduledStartTime: 'asc' }
    });

    // Generate timeline data points
    const timelineData = generateTimelineData(
      statusHistory,
      maintenanceRecords,
      startDate,
      endDate,
      granularity
    );

    res.json({
      standId,
      dateRange: { start: startDate, end: endDate },
      granularity,
      statusHistory,
      maintenanceRecords,
      timelineData
    });
  } catch (error) {
    console.error('Timeline API error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Helper function to generate timeline data points
function generateTimelineData(statusHistory, maintenanceRecords, startDate, endDate, granularity) {
  const dataPoints = [];
  const interval = getIntervalFromGranularity(granularity);
  
  let currentTime = new Date(startDate);
  let currentStatus = 'operational'; // Default status
  
  // Sort all events by time
  const allEvents = [
    ...statusHistory.map(s => ({ ...s, type: 'status_change', time: s.changedAt })),
    ...maintenanceRecords.map(m => ({ ...m, type: 'maintenance_start', time: m.scheduledStartTime })),
    ...maintenanceRecords.map(m => ({ ...m, type: 'maintenance_end', time: m.scheduledEndTime }))
  ].sort((a, b) => new Date(a.time) - new Date(b.time));

  while (currentTime <= endDate) {
    // Update status based on events at this time
    const eventsAtTime = allEvents.filter(e => 
      new Date(e.time) <= currentTime && 
      new Date(e.time) > new Date(currentTime.getTime() - interval)
    );
    
    eventsAtTime.forEach(event => {
      if (event.type === 'status_change') {
        currentStatus = event.status;
      }
    });

    dataPoints.push({
      timestamp: new Date(currentTime),
      status: currentStatus,
      events: eventsAtTime
    });

    currentTime = new Date(currentTime.getTime() + interval);
  }

  return dataPoints;
}

function getIntervalFromGranularity(granularity) {
  const intervals = {
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000
  };
  return intervals[granularity] || intervals.hour;
}
```

### Bulk Timeline Endpoint
```javascript
// Bulk timeline data for multiple stands
app.get('/api/stands/timeline', async (req, res) => {
  try {
    const { start, end, standIds } = req.query;
    const organizationId = req.headers['x-organization-id'];
    
    const standIdArray = standIds ? standIds.split(',') : [];
    
    // Get all stands if no specific IDs provided
    const targetStands = standIdArray.length > 0 ? 
      standIdArray : 
      await prisma.stand.findMany({
        where: { organizationId, isDeleted: false },
        select: { id: true }
      }).then(stands => stands.map(s => s.id));

    // Get timeline data for all stands
    const timelinePromises = targetStands.map(standId => 
      getTimelineData(standId, start, end, organizationId)
    );

    const timelineResults = await Promise.all(timelinePromises);
    
    res.json({
      dateRange: { start, end },
      stands: timelineResults.reduce((acc, result) => {
        acc[result.standId] = result;
        return acc;
      }, {})
    });
  } catch (error) {
    console.error('Bulk timeline API error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

## React Components Implementation

### 1. Enhanced StandMapInterface with Timeline
```typescript
// apps/web/src/features/stands/components/EnhancedStandMapInterface.tsx
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { MapContainer, TileLayer, Marker, Popup } from 'react-leaflet';
import { motion, AnimatePresence } from 'framer-motion';
import { format, subDays, addDays } from 'date-fns';
import { useTimelineStore } from '../stores/timelineStore';
import { StandSidePanel } from './StandSidePanel';
import { TimelineController } from './TimelineController';
import { MapTooltip } from './MapTooltip';

interface EnhancedStandMapInterfaceProps {
  stands: StandMapData[];
  selectedStandId?: string;
  onStandSelect: (standId: string) => void;
  filters: StandFilters;
}

export const EnhancedStandMapInterface: React.FC<EnhancedStandMapInterfaceProps> = ({
  stands,
  selectedStandId,
  onStandSelect,
  filters
}) => {
  const [map, setMap] = useState<L.Map | null>(null);
  const [sidePanelOpen, setSidePanelOpen] = useState(false);
  const [hoveredStandId, setHoveredStandId] = useState<string | null>(null);
  const [tooltipPosition, setTooltipPosition] = useState<{ x: number; y: number } | null>(null);

  // Timeline state
  const {
    currentDate,
    isPlaying,
    playbackSpeed,
    dateRange,
    timelineData,
    setCurrentDate,
    setIsPlaying,
    setPlaybackSpeed,
    setDateRange,
    loadTimelineData
  } = useTimelineStore();

  // Initialize timeline with default date range (last 30 days)
  useEffect(() => {
    const endDate = new Date();
    const startDate = subDays(endDate, 30);
    setDateRange(startDate, endDate);
    setCurrentDate(endDate);
  }, []);

  // Load timeline data when date range changes
  useEffect(() => {
    if (dateRange.start && dateRange.end) {
      loadTimelineData(stands.map(s => s.id), dateRange.start, dateRange.end);
    }
  }, [dateRange, stands]);

  // Get current status for each stand based on timeline position
  const standsWithTimelineStatus = useMemo(() => {
    return stands.map(stand => {
      const standTimeline = timelineData[stand.id];
      if (!standTimeline || !currentDate) {
        return stand;
      }

      // Find the status at the current timeline position
      const timelinePoint = standTimeline.find(point => 
        point.timestamp <= currentDate
      );

      return {
        ...stand,
        status: timelinePoint?.status || stand.status,
        timelineEvents: timelinePoint?.events || []
      };
    });
  }, [stands, timelineData, currentDate]);

  // Handle marker click
  const handleMarkerClick = useCallback((standId: string) => {
    onStandSelect(standId);
    setSidePanelOpen(true);
  }, [onStandSelect]);

  // Handle marker hover
  const handleMarkerHover = useCallback((standId: string, event: L.LeafletMouseEvent) => {
    setHoveredStandId(standId);
    setTooltipPosition({
      x: event.containerPoint.x,
      y: event.containerPoint.y
    });
  }, []);

  // Handle marker hover end
  const handleMarkerHoverEnd = useCallback(() => {
    setHoveredStandId(null);
    setTooltipPosition(null);
  }, []);

  // Create enhanced markers with animation
  const createEnhancedMarkerIcon = (stand: StandWithTimelineStatus, isSelected: boolean) => {
    const colors = {
      operational: '#10b981',
      maintenance: '#f59e0b',
      closed: '#ef4444'
    };

    const size = isSelected ? 36 : 28;
    const color = colors[stand.status as keyof typeof colors] || '#6b7280';
    const hasEvents = stand.timelineEvents && stand.timelineEvents.length > 0;

    return divIcon({
      html: `
        <div style="
          width: ${size}px;
          height: ${size}px;
          background-color: ${color};
          border: 3px solid white;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: 0 4px 8px rgba(0,0,0,0.2);
          transition: all 0.3s ease;
          ${isSelected ? 'box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5);' : ''}
          ${hasEvents ? 'animation: pulse 2s infinite;' : ''}
        ">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="white">
            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
          </svg>
        </div>
        <style>
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
          }
        </style>
      `,
      className: 'enhanced-marker',
      iconSize: [size, size],
      iconAnchor: [size / 2, size]
    });
  };

  return (
    <div className="space-y-4">
      {/* Timeline Controller */}
      <TimelineController
        currentDate={currentDate}
        dateRange={dateRange}
        isPlaying={isPlaying}
        playbackSpeed={playbackSpeed}
        onDateChange={setCurrentDate}
        onPlayToggle={() => setIsPlaying(!isPlaying)}
        onSpeedChange={setPlaybackSpeed}
        onDateRangeChange={setDateRange}
        timelineData={timelineData}
      />

      {/* Enhanced Map */}
      <div className="relative bg-white rounded-lg shadow-sm border">
        <div className="flex items-center justify-between p-4 border-b">
          <div className="flex items-center space-x-2">
            <MapPin className="w-5 h-5 text-blue-600" />
            <h3 className="text-lg font-semibold">Stand Locations</h3>
            <span className="text-sm text-gray-500">
              ({standsWithTimelineStatus.length} stands)
            </span>
            {currentDate && (
              <span className="text-sm text-blue-600 font-medium">
                {format(currentDate, 'MMM dd, yyyy HH:mm')}
              </span>
            )}
          </div>
        </div>

        <div className="h-96 relative">
          <MapContainer
            center={[53.3498, -2.2744]} // Manchester Airport
            zoom={14}
            className="h-full w-full"
            ref={setMap}
          >
            <TileLayer
              attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
              url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            />
            
            <AnimatePresence>
              {standsWithTimelineStatus.map(stand => (
                <Marker
                  key={stand.id}
                  position={[stand.latitude, stand.longitude]}
                  icon={createEnhancedMarkerIcon(stand, stand.id === selectedStandId)}
                  eventHandlers={{
                    click: () => handleMarkerClick(stand.id),
                    mouseover: (e) => handleMarkerHover(stand.id, e),
                    mouseout: handleMarkerHoverEnd
                  }}
                />
              ))}
            </AnimatePresence>
          </MapContainer>

          {/* Tooltip */}
          <AnimatePresence>
            {hoveredStandId && tooltipPosition && (
              <MapTooltip
                stand={standsWithTimelineStatus.find(s => s.id === hoveredStandId)!}
                position={tooltipPosition}
                currentDate={currentDate}
              />
            )}
          </AnimatePresence>
        </div>
      </div>

      {/* Side Panel */}
      <AnimatePresence>
        {sidePanelOpen && selectedStandId && (
          <StandSidePanel
            standId={selectedStandId}
            onClose={() => setSidePanelOpen(false)}
            currentDate={currentDate}
          />
        )}
      </AnimatePresence>
    </div>
  );
};
```

### 2. Timeline Controller Component
```typescript
// apps/web/src/features/stands/components/TimelineController.tsx
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { Play, Pause, SkipBack, SkipForward, Calendar, Clock } from 'lucide-react';
import { format, addHours, subHours } from 'date-fns';
import * as d3 from 'd3';

interface TimelineControllerProps {
  currentDate: Date;
  dateRange: { start: Date; end: Date };
  isPlaying: boolean;
  playbackSpeed: number;
  onDateChange: (date: Date) => void;
  onPlayToggle: () => void;
  onSpeedChange: (speed: number) => void;
  onDateRangeChange: (start: Date, end: Date) => void;
  timelineData: Record<string, TimelineDataPoint[]>;
}

export const TimelineController: React.FC<TimelineControllerProps> = ({
  currentDate,
  dateRange,
  isPlaying,
  playbackSpeed,
  onDateChange,
  onPlayToggle,
  onSpeedChange,
  onDateRangeChange,
  timelineData
}) => {
  const timelineRef = useRef<SVGSVGElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);

  // Timeline dimensions
  const timelineWidth = 800;
  const timelineHeight = 60;
  const margin = { top: 10, right: 20, bottom: 30, left: 20 };

  // Create scales
  const xScale = d3.scaleTime()
    .domain([dateRange.start, dateRange.end])
    .range([margin.left, timelineWidth - margin.right]);

  const yScale = d3.scaleLinear()
    .domain([0, 1])
    .range([timelineHeight - margin.bottom, margin.top]);

  // Auto-play functionality
  useEffect(() => {
    if (!isPlaying) return;

    const interval = setInterval(() => {
      const nextDate = addHours(currentDate, playbackSpeed);
      if (nextDate <= dateRange.end) {
        onDateChange(nextDate);
      } else {
        onPlayToggle(); // Stop at end
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [isPlaying, currentDate, playbackSpeed, dateRange.end, onDateChange, onPlayToggle]);

  // Handle timeline drag
  const handleTimelineDrag = (event: React.MouseEvent<SVGSVGElement>) => {
    if (!isDragging) return;

    const rect = timelineRef.current?.getBoundingClientRect();
    if (!rect) return;

    const x = event.clientX - rect.left;
    const newDate = xScale.invert(x);

    // Clamp to date range
    const clampedDate = new Date(Math.max(
      dateRange.start.getTime(),
      Math.min(dateRange.end.getTime(), newDate.getTime())
    ));

    onDateChange(clampedDate);
  };

  // Get all events for timeline visualization
  const allEvents = Object.values(timelineData).flat().filter(point => 
    point.events && point.events.length > 0
  );

  // Speed options
  const speedOptions = [0.5, 1, 2, 4, 8];

  return (
    <div className="bg-white rounded-lg shadow-sm border p-4">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center space-x-2">
          <Clock className="w-5 h-5 text-blue-600" />
          <h3 className="text-lg font-semibold">Timeline Controller</h3>
        </div>
        
        <div className="flex items-center space-x-2">
          <button
            onClick={() => setShowDatePicker(!showDatePicker)}
            className="flex items-center space-x-1 px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-md"
          >
            <Calendar className="w-4 h-4" />
            <span>Date Range</span>
          </button>
        </div>
      </div>

      {/* Date Range Picker */}
      {showDatePicker && (
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -10 }}
          className="mb-4 p-3 bg-gray-50 rounded-lg"
        >
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Start Date
              </label>
              <input
                type="datetime-local"
                value={format(dateRange.start, "yyyy-MM-dd'T'HH:mm")}
                onChange={(e) => onDateRangeChange(new Date(e.target.value), dateRange.end)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                End Date
              </label>
              <input
                type="datetime-local"
                value={format(dateRange.end, "yyyy-MM-dd'T'HH:mm")}
                onChange={(e) => onDateRangeChange(dateRange.start, new Date(e.target.value))}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>
        </motion.div>
      )}

      {/* Timeline Visualization */}
      <div className="mb-4">
        <svg
          ref={timelineRef}
          width={timelineWidth}
          height={timelineHeight}
          className="border rounded cursor-pointer"
          onMouseDown={() => setIsDragging(true)}
          onMouseUp={() => setIsDragging(false)}
          onMouseLeave={() => setIsDragging(false)}
          onMouseMove={handleTimelineDrag}
        >
          {/* Timeline background */}
          <rect
            x={margin.left}
            y={margin.top}
            width={timelineWidth - margin.left - margin.right}
            height={timelineHeight - margin.top - margin.bottom}
            fill="#f8fafc"
            stroke="#e2e8f0"
          />

          {/* Event markers */}
          {allEvents.map((point, index) => (
            <circle
              key={index}
              cx={xScale(point.timestamp)}
              cy={yScale(0.5)}
              r={3}
              fill={point.events[0]?.type === 'maintenance_start' ? '#f59e0b' : '#10b981'}
              stroke="white"
              strokeWidth={1}
            />
          ))}

          {/* Current position indicator */}
          <line
            x1={xScale(currentDate)}
            y1={margin.top}
            x2={xScale(currentDate)}
            y2={timelineHeight - margin.bottom}
            stroke="#3b82f6"
            strokeWidth={2}
          />

          {/* Current position handle */}
          <circle
            cx={xScale(currentDate)}
            cy={yScale(0.5)}
            r={6}
            fill="#3b82f6"
            stroke="white"
            strokeWidth={2}
            className="cursor-grab active:cursor-grabbing"
          />

          {/* Time axis */}
          <g transform={`translate(0, ${timelineHeight - margin.bottom})`}>
            {xScale.ticks(5).map(tick => (
              <g key={tick.getTime()}>
                <line
                  x1={xScale(tick)}
                  y1={0}
                  x2={xScale(tick)}
                  y2={5}
                  stroke="#6b7280"
                />
                <text
                  x={xScale(tick)}
                  y={18}
                  textAnchor="middle"
                  fontSize="12"
                  fill="#6b7280"
                >
                  {format(tick, 'MMM dd')}
                </text>
              </g>
            ))}
          </g>
        </svg>
      </div>

      {/* Playback Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <button
            onClick={() => onDateChange(subHours(currentDate, 1))}
            className="p-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-md"
            disabled={currentDate <= dateRange.start}
          >
            <SkipBack className="w-4 h-4" />
          </button>
          
          <button
            onClick={onPlayToggle}
            className="p-2 text-white bg-blue-600 hover:bg-blue-700 rounded-md"
          >
            {isPlaying ? <Pause className="w-4 h-4" /> : <Play className="w-4 h-4" />}
          </button>
          
          <button
            onClick={() => onDateChange(addHours(currentDate, 1))}
            className="p-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-md"
            disabled={currentDate >= dateRange.end}
          >
            <SkipForward className="w-4 h-4" />
          </button>
        </div>

        <div className="flex items-center space-x-2">
          <span className="text-sm text-gray-600">Speed:</span>
          <select
            value={playbackSpeed}
            onChange={(e) => onSpeedChange(Number(e.target.value))}
            className="px-2 py-1 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            {speedOptions.map(speed => (
              <option key={speed} value={speed}>
                {speed}x
              </option>
            ))}
          </select>
        </div>

        <div className="text-sm text-gray-600">
          {format(currentDate, 'MMM dd, yyyy HH:mm')}
        </div>
      </div>
    </div>
  );
};
```

### 3. Map Tooltip Component
```typescript
// apps/web/src/features/stands/components/MapTooltip.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { format } from 'date-fns';
import { MapPin, Clock, Wrench, AlertTriangle } from 'lucide-react';

interface MapTooltipProps {
  stand: StandWithTimelineStatus;
  position: { x: number; y: number };
  currentDate: Date;
}

export const MapTooltip: React.FC<MapTooltipProps> = ({
  stand,
  position,
  currentDate
}) => {
  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'maintenance':
        return <Wrench className="w-4 h-4 text-yellow-600" />;
      case 'closed':
        return <AlertTriangle className="w-4 h-4 text-red-600" />;
      default:
        return <MapPin className="w-4 h-4 text-green-600" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'operational':
        return 'bg-green-100 text-green-800 border-green-200';
      case 'maintenance':
        return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'closed':
        return 'bg-red-100 text-red-800 border-red-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{ duration: 0.2 }}
      className="absolute z-50 pointer-events-none"
      style={{
        left: position.x + 10,
        top: position.y - 10,
        transform: 'translateY(-100%)'
      }}
    >
      <div className="bg-white rounded-lg shadow-lg border border-gray-200 p-3 max-w-xs">
        <div className="flex items-center justify-between mb-2">
          <div className="flex items-center space-x-2">
            <h4 className="font-semibold text-gray-900">{stand.code}</h4>
            {getStatusIcon(stand.status)}
          </div>
          <span className={`px-2 py-1 rounded-full text-xs font-medium border ${getStatusColor(stand.status)}`}>
            {stand.status}
          </span>
        </div>
        
        <p className="text-sm text-gray-600 mb-2">{stand.name}</p>
        
        <div className="space-y-1 text-xs text-gray-500">
          <div className="flex items-center justify-between">
            <span>Terminal:</span>
            <span className="font-medium">{stand.terminal_code}</span>
          </div>
          <div className="flex items-center justify-between">
            <span>Aircraft Size:</span>
            <span className="font-medium">{stand.aircraft_size_category}</span>
          </div>
          <div className="flex items-center justify-between">
            <span>Max Weight:</span>
            <span className="font-medium">{stand.max_weight_kg.toLocaleString()} kg</span>
          </div>
        </div>

        {/* Timeline events */}
        {stand.timelineEvents && stand.timelineEvents.length > 0 && (
          <div className="mt-2 pt-2 border-t border-gray-200">
            <div className="flex items-center space-x-1 text-xs text-gray-500 mb-1">
              <Clock className="w-3 h-3" />
              <span>Recent Events:</span>
            </div>
            <div className="space-y-1">
              {stand.timelineEvents.slice(0, 2).map((event, index) => (
                <div key={index} className="text-xs text-gray-600">
                  <span className="font-medium">
                    {event.type === 'status_change' ? 'Status Change' : 
                     event.type === 'maintenance_start' ? 'Maintenance Started' :
                     'Maintenance Ended'}
                  </span>
                  {event.reason && (
                    <span className="text-gray-500"> - {event.reason}</span>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}

        <div className="mt-2 pt-2 border-t border-gray-200 text-xs text-gray-500">
          <div className="flex items-center space-x-1">
            <Clock className="w-3 h-3" />
            <span>Timeline: {format(currentDate, 'MMM dd, HH:mm')}</span>
          </div>
        </div>
      </div>
    </motion.div>
  );
};
```

### 4. Side Panel Component
```typescript
// apps/web/src/features/stands/components/StandSidePanel.tsx
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { X, MapPin, Settings, History, Network, Edit, FileText, Download } from 'lucide-react';
import { format } from 'date-fns';

interface StandSidePanelProps {
  standId: string;
  onClose: () => void;
  currentDate: Date;
}

export const StandSidePanel: React.FC<StandSidePanelProps> = ({
  standId,
  onClose,
  currentDate
}) => {
  const [activeTab, setActiveTab] = useState<'overview' | 'maintenance' | 'history' | 'adjacency'>('overview');
  const [standDetails, setStandDetails] = useState<StandDetails | null>(null);
  const [loading, setLoading] = useState(true);

  // Load stand details
  useEffect(() => {
    const loadStandDetails = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/stands/${standId}/details`);
        const data = await response.json();
        setStandDetails(data);
      } catch (error) {
        console.error('Failed to load stand details:', error);
      } finally {
        setLoading(false);
      }
    };

    loadStandDetails();
  }, [standId]);

  const tabs = [
    { id: 'overview', label: 'Overview', icon: MapPin },
    { id: 'maintenance', label: 'Maintenance', icon: Settings },
    { id: 'history', label: 'History', icon: History },
    { id: 'adjacency', label: 'Adjacency', icon: Network }
  ];

  if (loading) {
    return (
      <motion.div
        initial={{ x: 400, opacity: 0 }}
        animate={{ x: 0, opacity: 1 }}
        exit={{ x: 400, opacity: 0 }}
        className="fixed right-0 top-0 h-full w-96 bg-white shadow-xl border-l border-gray-200 z-50"
      >
        <div className="p-6 flex items-center justify-center h-full">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      </motion.div>
    );
  }

  if (!standDetails) {
    return null;
  }

  return (
    <motion.div
      initial={{ x: 400, opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      exit={{ x: 400, opacity: 0 }}
      className="fixed right-0 top-0 h-full w-96 bg-white shadow-xl border-l border-gray-200 z-50 overflow-hidden"
    >
      {/* Header */}
      <div className="p-4 border-b border-gray-200 bg-gray-50">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className={`w-4 h-4 rounded-full ${
              standDetails.status === 'operational' ? 'bg-green-500' :
              standDetails.status === 'maintenance' ? 'bg-yellow-500' :
              'bg-red-500'
            }`}></div>
            <div>
              <h2 className="text-lg font-semibold text-gray-900">{standDetails.code}</h2>
              <p className="text-sm text-gray-600">{standDetails.name}</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-md"
          >
            <X className="w-5 h-5" />
          </button>
        </div>
        
        <div className="mt-3 flex items-center space-x-2">
          <span className={`px-2 py-1 rounded-full text-xs font-medium ${
            standDetails.status === 'operational' ? 'bg-green-100 text-green-800' :
            standDetails.status === 'maintenance' ? 'bg-yellow-100 text-yellow-800' :
            'bg-red-100 text-red-800'
          }`}>
            {standDetails.status}
          </span>
          <span className="text-xs text-gray-500">
            as of {format(currentDate, 'MMM dd, HH:mm')}
          </span>
        </div>
      </div>

      {/* Tabs */}
      <div className="border-b border-gray-200">
        <nav className="flex">
          {tabs.map(tab => {
            const Icon = tab.icon;
            return (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id as any)}
                className={`flex items-center space-x-2 px-4 py-3 text-sm font-medium border-b-2 transition-colors ${
                  activeTab === tab.id
                    ? 'border-blue-500 text-blue-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700'
                }`}
              >
                <Icon className="w-4 h-4" />
                <span>{tab.label}</span>
              </button>
            );
          })}
        </nav>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        {activeTab === 'overview' && (
          <OverviewTab standDetails={standDetails} />
        )}
        {activeTab === 'maintenance' && (
          <MaintenanceTab standId={standId} currentDate={currentDate} />
        )}
        {activeTab === 'history' && (
          <HistoryTab standId={standId} currentDate={currentDate} />
        )}
        {activeTab === 'adjacency' && (
          <AdjacencyTab standId={standId} />
        )}
      </div>

      {/* Actions */}
      <div className="p-4 border-t border-gray-200 bg-gray-50">
        <div className="flex space-x-2">
          <button className="flex items-center space-x-2 px-3 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700">
            <Edit className="w-4 h-4" />
            <span>Edit</span>
          </button>
          <button className="flex items-center space-x-2 px-3 py-2 text-sm bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">
            <FileText className="w-4 h-4" />
            <span>Maintenance</span>
          </button>
          <button className="flex items-center space-x-2 px-3 py-2 text-sm bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">
            <Download className="w-4 h-4" />
            <span>Export</span>
          </button>
        </div>
      </div>
    </motion.div>
  );
};
```

## State Management with Zustand

### Timeline Store
```typescript
// apps/web/src/features/stands/stores/timelineStore.ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

interface TimelineState {
  currentDate: Date;
  dateRange: { start: Date; end: Date };
  isPlaying: boolean;
  playbackSpeed: number;
  timelineData: Record<string, TimelineDataPoint[]>;
  loading: boolean;
  error: string | null;
}

interface TimelineActions {
  setCurrentDate: (date: Date) => void;
  setDateRange: (start: Date, end: Date) => void;
  setIsPlaying: (playing: boolean) => void;
  setPlaybackSpeed: (speed: number) => void;
  loadTimelineData: (standIds: string[], start: Date, end: Date) => Promise<void>;
  clearTimelineData: () => void;
}

export const useTimelineStore = create<TimelineState & TimelineActions>()(
  devtools(
    (set, get) => ({
      // State
      currentDate: new Date(),
      dateRange: { start: new Date(), end: new Date() },
      isPlaying: false,
      playbackSpeed: 1,
      timelineData: {},
      loading: false,
      error: null,

      // Actions
      setCurrentDate: (date) => set({ currentDate: date }),
      
      setDateRange: (start, end) => set({ 
        dateRange: { start, end },
        currentDate: end // Set current date to end of range
      }),
      
      setIsPlaying: (playing) => set({ isPlaying: playing }),
      
      setPlaybackSpeed: (speed) => set({ playbackSpeed: speed }),
      
      loadTimelineData: async (standIds, start, end) => {
        set({ loading: true, error: null });
        
        try {
          const response = await fetch(
            `/api/stands/timeline?start=${start.toISOString()}&end=${end.toISOString()}&standIds=${standIds.join(',')}`
          );
          
          if (!response.ok) {
            throw new Error('Failed to load timeline data');
          }
          
          const data = await response.json();
          set({ timelineData: data.stands, loading: false });
        } catch (error) {
          set({ 
            error: error instanceof Error ? error.message : 'Unknown error',
            loading: false 
          });
        }
      },
      
      clearTimelineData: () => set({ timelineData: {}, error: null })
    }),
    {
      name: 'timeline-store'
    }
  )
);
```

## Package Dependencies

### Required Packages
```json
{
  "dependencies": {
    "leaflet": "^1.9.4",
    "react-leaflet": "^4.2.1",
    "@types/leaflet": "^1.9.8",
    "d3": "^7.8.5",
    "@types/d3": "^7.4.3",
    "framer-motion": "^10.16.16",
    "date-fns": "^2.30.0",
    "zustand": "^4.4.7",
    "socket.io-client": "^4.7.4",
    "@headlessui/react": "^1.7.17",
    "@heroicons/react": "^2.0.18"
  }
}
```

### Installation Commands
```bash
# Install all required dependencies
pnpm add leaflet react-leaflet @types/leaflet d3 @types/d3 framer-motion date-fns zustand socket.io-client @headlessui/react @heroicons/react

# Install development dependencies
pnpm add -D @testing-library/react @testing-library/jest-dom @playwright/test
```

## CSS Enhancements

### Additional Styles
```css
/* apps/web/src/app/global.css */

/* Enhanced marker animations */
.enhanced-marker {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.enhanced-marker:hover {
  transform: scale(1.1);
  z-index: 1000;
}

/* Timeline styles */
.timeline-container {
  user-select: none;
}

.timeline-scrubber {
  cursor: grab;
  transition: all 0.2s ease;
}

.timeline-scrubber:active {
  cursor: grabbing;
  transform: scale(1.1);
}

/* Side panel animations */
.side-panel {
  will-change: transform;
  backface-visibility: hidden;
}

/* Tooltip styles */
.map-tooltip {
  backdrop-filter: blur(8px);
  background: rgba(255, 255, 255, 0.95);
}

/* Responsive timeline */
@media (max-width: 768px) {
  .timeline-container {
    padding: 0 10px;
  }
  
  .timeline-controls {
    flex-direction: column;
    gap: 10px;
  }
}

/* Loading animations */
@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.loading-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Status colors */
.status-operational {
  color: #10b981;
  background-color: #d1fae5;
}

.status-maintenance {
  color: #f59e0b;
  background-color: #fef3c7;
}

.status-closed {
  color: #ef4444;
  background-color: #fee2e2;
}
```

## Testing Implementation

### Unit Tests
```typescript
// apps/web/src/features/stands/components/TimelineController.spec.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { TimelineController } from './TimelineController';
import { addDays, subDays } from 'date-fns';

const mockProps = {
  currentDate: new Date('2025-01-15T10:00:00Z'),
  dateRange: {
    start: subDays(new Date('2025-01-15T10:00:00Z'), 7),
    end: addDays(new Date('2025-01-15T10:00:00Z'), 7)
  },
  isPlaying: false,
  playbackSpeed: 1,
  onDateChange: jest.fn(),
  onPlayToggle: jest.fn(),
  onSpeedChange: jest.fn(),
  onDateRangeChange: jest.fn(),
  timelineData: {}
};

describe('TimelineController', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders timeline controls', () => {
    render(<TimelineController {...mockProps} />);
    
    expect(screen.getByText('Timeline Controller')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /play/i })).toBeInTheDocument();
    expect(screen.getByDisplayValue('1')).toBeInTheDocument(); // Speed selector
  });

  test('toggles play/pause', () => {
    render(<TimelineController {...mockProps} />);
    
    const playButton = screen.getByRole('button', { name: /play/i });
    fireEvent.click(playButton);
    
    expect(mockProps.onPlayToggle).toHaveBeenCalled();
  });

  test('changes playback speed', () => {
    render(<TimelineController {...mockProps} />);
    
    const speedSelect = screen.getByDisplayValue('1');
    fireEvent.change(speedSelect, { target: { value: '2' } });
    
    expect(mockProps.onSpeedChange).toHaveBeenCalledWith(2);
  });

  test('navigates timeline with skip buttons', () => {
    render(<TimelineController {...mockProps} />);
    
    const skipForwardButton = screen.getByRole('button', { name: /skip forward/i });
    fireEvent.click(skipForwardButton);
    
    expect(mockProps.onDateChange).toHaveBeenCalled();
  });
});
```

### Integration Tests
```typescript
// apps/web/src/features/stands/components/EnhancedStandMapInterface.e2e.spec.tsx
import { test, expect } from '@playwright/test';

test.describe('Enhanced Stand Map Interface', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/stands');
    await page.waitForSelector('.leaflet-container');
  });

  test('displays timeline controller', async ({ page }) => {
    await expect(page.locator('text=Timeline Controller')).toBeVisible();
    await expect(page.locator('svg[width="800"]')).toBeVisible(); // Timeline SVG
  });

  test('plays timeline animation', async ({ page }) => {
    const playButton = page.locator('button[aria-label*="play"]');
    await playButton.click();
    
    // Check that play button changes to pause
    await expect(page.locator('button[aria-label*="pause"]')).toBeVisible();
    
    // Wait for timeline to advance
    await page.waitForTimeout(2000);
    
    // Pause and verify timeline moved
    await page.locator('button[aria-label*="pause"]').click();
  });

  test('shows tooltip on marker hover', async ({ page }) => {
    const marker = page.locator('.leaflet-marker-icon').first();
    await marker.hover();
    
    await expect(page.locator('.map-tooltip')).toBeVisible();
    await expect(page.locator('text=/Stand [A-Z0-9]+/')).toBeVisible();
  });

  test('opens side panel on marker click', async ({ page }) => {
    const marker = page.locator('.leaflet-marker-icon').first();
    await marker.click();
    
    await expect(page.locator('.side-panel')).toBeVisible();
    await expect(page.locator('text=Overview')).toBeVisible();
    await expect(page.locator('text=Maintenance')).toBeVisible();
    await expect(page.locator('text=History')).toBeVisible();
  });

  test('timeline scrubbing updates markers', async ({ page }) => {
    const timelineScrubber = page.locator('.timeline-scrubber');
    
    // Get initial marker color
    const marker = page.locator('.leaflet-marker-icon').first();
    const initialColor = await marker.evaluate(el => 
      getComputedStyle(el.querySelector('div')).backgroundColor
    );
    
    // Drag timeline scrubber
    await timelineScrubber.dragTo(page.locator('.timeline-container'), {
      targetPosition: { x: 400, y: 30 }
    });
    
    // Check if marker color potentially changed
    const newColor = await marker.evaluate(el => 
      getComputedStyle(el.querySelector('div')).backgroundColor
    );
    
    // Color may or may not change depending on data, but scrubber should move
    await expect(timelineScrubber).not.toHaveCSS('transform', 'none');
  });

  test('side panel tabs work correctly', async ({ page }) => {
    // Open side panel
    await page.locator('.leaflet-marker-icon').first().click();
    
    // Test each tab
    await page.click('text=Maintenance');
    await expect(page.locator('text=Maintenance Schedule')).toBeVisible();
    
    await page.click('text=History');
    await expect(page.locator('text=Status Changes')).toBeVisible();
    
    await page.click('text=Adjacency');
    await expect(page.locator('text=Adjacent Stands')).toBeVisible();
  });
});
```

## Performance Optimization

### Timeline Data Virtualization
```typescript
// Implement data virtualization for large datasets
const useVirtualizedTimelineData = (
  timelineData: Record<string, TimelineDataPoint[]>,
  dateRange: { start: Date; end: Date },
  granularity: string
) => {
  return useMemo(() => {
    const maxPoints = 1000; // Limit data points for performance
    const totalRange = dateRange.end.getTime() - dateRange.start.getTime();
    const interval = totalRange / maxPoints;
    
    return Object.entries(timelineData).reduce((acc, [standId, points]) => {
      const virtualizedPoints = points.filter((point, index) => 
        index % Math.ceil(points.length / maxPoints) === 0
      );
      acc[standId] = virtualizedPoints;
      return acc;
    }, {} as Record<string, TimelineDataPoint[]>);
  }, [timelineData, dateRange, granularity]);
};
```

### Marker Clustering for Large Datasets
```typescript
// Implement marker clustering when many stands are visible
const useMarkerClustering = (stands: StandMapData[], zoomLevel: number) => {
  return useMemo(() => {
    if (stands.length < 50 || zoomLevel > 15) {
      return stands; // No clustering needed
    }
    
    // Simple clustering algorithm
    const clusters = [];
    const clustered = new Set();
    
    stands.forEach(stand => {
      if (clustered.has(stand.id)) return;
      
      const nearbyStands = stands.filter(other => 
        !clustered.has(other.id) &&
        getDistance(stand.latitude, stand.longitude, other.latitude, other.longitude) < 0.001
      );
      
      if (nearbyStands.length > 1) {
        clusters.push({
          id: `cluster-${clusters.length}`,
          type: 'cluster',
          stands: nearbyStands,
          latitude: nearbyStands.reduce((sum, s) => sum + s.latitude, 0) / nearbyStands.length,
          longitude: nearbyStands.reduce((sum, s) => sum + s.longitude, 0) / nearbyStands.length
        });
        
        nearbyStands.forEach(s => clustered.add(s.id));
      } else {
        clusters.push(stand);
      }
    });
    
    return clusters;
  }, [stands, zoomLevel]);
};
```

## Real-time Updates

### WebSocket Integration
```typescript
// apps/web/src/features/stands/hooks/useRealTimeUpdates.ts
import { useEffect } from 'react';
import { io, Socket } from 'socket.io-client';
import { useTimelineStore } from '../stores/timelineStore';

export const useRealTimeUpdates = (organizationId: string) => {
  const { loadTimelineData, dateRange } = useTimelineStore();

  useEffect(() => {
    const socket: Socket = io('/stands', {
      query: { organizationId }
    });

    socket.on('stand_status_changed', (data) => {
      // Reload timeline data when status changes
      if (dateRange.start && dateRange.end) {
        loadTimelineData([data.standId], dateRange.start, dateRange.end);
      }
    });

    socket.on('maintenance_scheduled', (data) => {
      // Update timeline when maintenance is scheduled
      if (dateRange.start && dateRange.end) {
        loadTimelineData([data.standId], dateRange.start, dateRange.end);
      }
    });

    return () => {
      socket.disconnect();
    };
  }, [organizationId, dateRange, loadTimelineData]);
};
```

## Security Implementation

### Data Validation
```typescript
// Validate timeline data before processing
const validateTimelineData = (data: any): TimelineDataPoint[] => {
  if (!Array.isArray(data)) {
    throw new Error('Timeline data must be an array');
  }
  
  return data.map(point => {
    if (!point.timestamp || !point.status) {
      throw new Error('Invalid timeline data point');
    }
    
    return {
      timestamp: new Date(point.timestamp),
      status: ['operational', 'maintenance', 'closed'].includes(point.status) 
        ? point.status 
        : 'operational',
      events: Array.isArray(point.events) ? point.events : []
    };
  });
};
```

### Access Control
```typescript
// Ensure users can only access their organization's timeline data
const validateTimelineAccess = (req: Request, standId: string) => {
  const organizationId = req.headers['x-organization-id'];
  const userId = req.headers['x-user-id'];
  
  if (!organizationId || !userId) {
    throw new Error('Missing authentication headers');
  }
  
  // Verify stand belongs to user's organization
  return prisma.stand.findFirst({
    where: {
      id: standId,
      organizationId,
      isDeleted: false
    }
  });
};
```

## Deployment Considerations

### Build Configuration
```javascript
// next.config.js - Enhanced for timeline features
module.exports = {
  transpilePackages: ['leaflet', 'react-leaflet', 'd3'],
  
  webpack: (config) => {
    // Optimize D3 bundle size
    config.resolve.alias = {
      ...config.resolve.alias,
      'd3': 'd3/dist/d3.min.js'
    };
    
    return config;
  },
  
  // Enable server-side rendering for timeline components
  experimental: {
    esmExternals: false
  }
};
```

### Environment Variables
```bash
# .env.local
NEXT_PUBLIC_WEBSOCKET_URL=ws://localhost:3001
NEXT_PUBLIC_TIMELINE_MAX_RANGE_DAYS=90
NEXT_PUBLIC_TIMELINE_DEFAULT_GRANULARITY=hour
```

## Monitoring and Analytics

### Performance Metrics
```typescript
// Track timeline performance
const trackTimelinePerformance = () => {
  const startTime = performance.now();
  
  // Track timeline data loading
  const trackDataLoad = (standCount: number, dateRange: number) => {
    const loadTime = performance.now() - startTime;
    console.log(`Timeline data loaded: ${standCount} stands, ${dateRange} days in ${loadTime}ms`);
  };
  
  // Track scrubbing performance
  const trackScrubbing = (fps: number) => {
    console.log(`Timeline scrubbing FPS: ${fps}`);
  };
  
  return { trackDataLoad, trackScrubbing };
};
```

This comprehensive TDD provides detailed technical specifications for implementing the Enhanced Map Interface with Timeline functionality, ensuring proper integration with the existing system while maintaining high performance, security, and user experience standards. 