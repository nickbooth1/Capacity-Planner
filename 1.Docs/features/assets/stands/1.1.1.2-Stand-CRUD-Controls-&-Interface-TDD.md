# Technical Design Document: Stands CRUD Operations

**Feature**: Stand Asset Repository - CRUD Operations  
**Version**: 1.0  
**Date**: January 2025  
**Author**: Engineering Team  
**Status**: Ready for Implementation  
**Related PRD**: 1.1.1.2-Stand-CRUD-Controls-PRD.md

## Executive Summary

This document provides the technical implementation details for the Stand CRUD operations in the CapaCity Planner system. It outlines the architecture, implementation approach, performance optimizations, and technical decisions required to build a scalable, secure, and maintainable stand management system.

## Architecture Overview

### System Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        UI[React UI]
        API_CLIENT[API Client SDK]
    end
    
    subgraph "API Gateway"
        GATEWAY[Kong/Express Gateway]
        RATE_LIMIT[Rate Limiter]
        AUTH[Auth Middleware]
    end
    
    subgraph "Application Layer"
        CONTROLLER[Stand Controller]
        SERVICE[Stand Service]
        VALIDATOR[Validation Layer]
        CACHE[Redis Cache]
    end
    
    subgraph "Domain Layer"
        REPOSITORY[Stand Repository]
        EVENTS[Event Publisher]
        JOBS[Job Processor]
    end
    
    subgraph "Data Layer"
        DB[(PostgreSQL)]
        S3[S3/MinIO]
        QUEUE[Bull Queue]
    end
    
    UI --> API_CLIENT
    API_CLIENT --> GATEWAY
    GATEWAY --> RATE_LIMIT
    RATE_LIMIT --> AUTH
    AUTH --> CONTROLLER
    CONTROLLER --> SERVICE
    SERVICE --> VALIDATOR
    SERVICE --> CACHE
    SERVICE --> REPOSITORY
    SERVICE --> EVENTS
    SERVICE --> JOBS
    REPOSITORY --> DB
    JOBS --> QUEUE
    JOBS --> S3
```

### Component Responsibilities

| Component | Responsibility |
|-----------|---------------|
| **Controller** | HTTP request handling, response formatting |
| **Service** | Business logic, orchestration, caching |
| **Repository** | Data access, query optimization |
| **Validator** | Input validation, business rule enforcement |
| **Event Publisher** | Async event propagation |
| **Job Processor** | Bulk import handling, async operations |
| **React UI** | User interface, state management |
| **API Client** | HTTP requests, response caching |

## Technical Implementation

### Project Structure

```
packages/assets-module/
├── src/
│   ├── controllers/
│   │   └── stand.controller.ts
│   ├── services/
│   │   ├── stand.service.ts
│   │   ├── stand-import.service.ts
│   │   └── stand-cache.service.ts
│   ├── repositories/
│   │   └── stand.repository.ts
│   ├── validators/
│   │   ├── stand.validator.ts
│   │   └── schemas/
│   │       └── stand.schema.ts
│   ├── events/
│   │   ├── stand.events.ts
│   │   └── publishers/
│   │       └── stand.publisher.ts
│   ├── jobs/
│   │   ├── processors/
│   │   │   └── stand-import.processor.ts
│   │   └── queues/
│   │       └── stand-import.queue.ts
│   ├── middleware/
│   │   ├── auth.middleware.ts
│   │   ├── rate-limit.middleware.ts
│   │   └── cache.middleware.ts
│   ├── types/
│   │   ├── stand.types.ts
│   │   └── events.types.ts
│   └── utils/
│       ├── csv-parser.ts
│       ├── geometry-validator.ts
│       └── performance-monitor.ts
├── prisma/
│   ├── schema.prisma
│   └── migrations/
├── tests/
│   ├── unit/
│   ├── integration/
│   └── e2e/
└── package.json

packages/web/
├── src/
│   ├── features/
│   │   └── assets/
│   │       └── stands/
│   │           ├── components/
│   │           │   ├── StandList.tsx
│   │           │   ├── StandTable.tsx
│   │           │   ├── StandFilters.tsx
│   │           │   ├── StandForm.tsx
│   │           │   ├── StandImport.tsx
│   │           │   └── StandStatusBadge.tsx
│   │           ├── hooks/
│   │           │   ├── useStands.ts
│   │           │   ├── useStandMutations.ts
│   │           │   ├── useStandFilters.ts
│   │           │   └── useStandImport.ts
│   │           ├── api/
│   │           │   ├── stands.api.ts
│   │           │   └── stands.types.ts
│   │           ├── utils/
│   │           │   ├── stand.validators.ts
│   │           │   └── stand.mappers.ts
│   │           └── pages/
│   │               └── StandsPage.tsx
│   ├── shared/
│   │   ├── components/
│   │   │   ├── DataTable/
│   │   │   ├── Modal/
│   │   │   └── FileUpload/
│   │   └── hooks/
│   │       ├── useWebSocket.ts
│   │       └── useToast.ts
│   └── lib/
│       ├── api-client.ts
│       └── websocket-client.ts
├── tests/
│   ├── unit/
│   ├── integration/
│   └── e2e/
└── package.json
```

### Database Schema Integration

**Note**: This feature builds upon the comprehensive capabilities schema from feature 1.1.1.1. All capability-related tables and indexes are already implemented.

```prisma
// Stand model - extends capabilities schema (1.1.1.1) with CRUD controls
model Stand {
  id             String   @id @default(uuid())
  organizationId String   @map("organization_id")
  code           String   @db.VarChar(20)
  name           String   @db.VarChar(100)
  terminal       String?  @db.VarChar(50)
  status         String   @default("operational") @db.VarChar(20)
  
  // Comprehensive capabilities (from 1.1.1.1)
  dimensions               Json     @default("{}")
  aircraftCompatibility   Json     @default("{}")
  groundSupport           Json     @default("{}")
  operationalConstraints  Json     @default("{}")
  environmentalFeatures   Json     @default("{}")
  infrastructure          Json     @default("{}")
  
  // Location and geometry
  geometry       Json?    
  latitude       Float?   @db.Real
  longitude      Float?   @db.Real
  elevation      Float?   @db.Real
  
  // Legacy support and metadata
  capabilities   Json     @default("{}")
  metadata       Json     @default("{}")
  
  // CRUD Controls enhancements
  version        Int      @default(1) // Optimistic locking
  isDeleted      Boolean  @default(false) @map("is_deleted") // Soft delete
  deletedAt      DateTime? @map("deleted_at")
  deletedBy      String?  @map("deleted_by")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")
  createdBy      String?  @map("created_by")
  updatedBy      String?  @map("updated_by")

  // Relations (from capabilities feature)
  statusHistory           StandStatusHistory[]
  maintenanceRecords     StandMaintenanceRecord[]
  adjacencies            StandAdjacency[]
  utilizationPatterns    StandUtilizationPattern[]
  
  // Indexes for CRUD operations
  @@unique([organizationId, code, isDeleted])
  @@index([organizationId, status, isDeleted])
  @@index([organizationId, terminal, isDeleted])
  @@index([organizationId, createdAt])
  @@index([latitude, longitude])
  @@map("stands")
  @@schema("assets")
}

model StandStatusHistory {
  id         String   @id @default(uuid())
  standId    String   @map("stand_id")
  fromStatus String   @map("from_status") @db.VarChar(20)
  toStatus   String   @map("to_status") @db.VarChar(20)
  reason     String?  @db.Text
  changedBy  String   @map("changed_by")
  changedAt  DateTime @default(now()) @map("changed_at")
  metadata   Json     @default("{}")
  
  // Relations
  stand      Stand    @relation(fields: [standId], references: [id])
  
  // Indexes
  @@index([standId, changedAt])
  @@index([changedAt])
  @@map("stand_status_history")
  @@schema("assets")
}

model StandImportJob {
  id             String   @id @default(uuid())
  organizationId String   @map("organization_id")
  filename       String   @db.VarChar(255)
  fileUrl        String   @map("file_url") @db.Text
  status         String   @default("pending") @db.VarChar(20)
  totalRows      Int      @map("total_rows")
  processedRows  Int      @default(0) @map("processed_rows")
  successRows    Int      @default(0) @map("success_rows")
  errorRows      Int      @default(0) @map("error_rows")
  errors         Json     @default("[]")
  startedAt      DateTime? @map("started_at")
  completedAt    DateTime? @map("completed_at")
  createdBy      String   @map("created_by")
  createdAt      DateTime @default(now()) @map("created_at")
  
  // Indexes
  @@index([organizationId, status, createdAt])
  @@index([createdAt])
  @@map("stand_import_jobs")
  @@schema("assets")
}
```

### Core Implementation Details

#### 1. Stand Controller

```typescript
import { Request, Response } from 'express';
import { StandService } from '../services/stand.service';
import { CacheMiddleware } from '../middleware/cache.middleware';
import { validate } from '../middleware/validation.middleware';
import { standSchemas } from '../validators/schemas/stand.schema';

export class StandController {
  constructor(
    private standService: StandService,
    private cache: CacheMiddleware
  ) {}

  @validate(standSchemas.list)
  @cache({ ttl: 60, keyPattern: 'stands:list:{orgId}:{query}' })
  async list(req: Request, res: Response): Promise<void> {
    const { organizationId } = req;
    const filters = this.parseFilters(req.query);
    const pagination = this.parsePagination(req.query);
    
    const result = await this.standService.list(
      organizationId,
      filters,
      pagination
    );
    
    res.json(result);
  }

  @validate(standSchemas.create)
  async create(req: Request, res: Response): Promise<void> {
    const { organizationId, userId } = req;
    
    const stand = await this.standService.create({
      ...req.body,
      organizationId,
      createdBy: userId,
      updatedBy: userId,
    });
    
    // Invalidate cache
    await this.cache.invalidatePattern(`stands:*:${organizationId}:*`);
    
    res.status(201).json(stand);
  }

  @validate(standSchemas.update)
  async update(req: Request, res: Response): Promise<void> {
    const { standId } = req.params;
    const { organizationId, userId } = req;
    const { version, ...updateData } = req.body;
    
    const stand = await this.standService.update(
      standId,
      {
        ...updateData,
        updatedBy: userId,
      },
      {
        organizationId,
        version, // For optimistic locking
      }
    );
    
    // Invalidate cache
    await this.cache.invalidate([
      `stands:${standId}`,
      `stands:*:${organizationId}:*`,
    ]);
    
    res.json(stand);
  }

  async bulkImport(req: Request, res: Response): Promise<void> {
    const { organizationId, userId } = req;
    const { file } = req;
    
    if (!file) {
      return res.status(400).json({ error: 'File required' });
    }
    
    const job = await this.standService.startBulkImport(
      file,
      organizationId,
      userId,
      {
        replaceExisting: req.body.replaceExisting === 'true',
      }
    );
    
    res.status(202).json({
      jobId: job.id,
      status: 'processing',
      pollUrl: `/api/assets/stands/import-jobs/${job.id}`,
    });
  }

  private parseFilters(query: any): StandFilters {
    return {
      status: query.status,
      terminal: query.terminal,
      aircraftSize: query.aircraftSize,
      search: query.search,
      isDeleted: false, // Always filter out soft-deleted records
    };
  }

  private parsePagination(query: any): PaginationParams {
    return {
      page: parseInt(query.page) || 1,
      limit: Math.min(parseInt(query.limit) || 50, 100),
      sortBy: query.sortBy || 'code',
      sortOrder: query.sortOrder || 'asc',
    };
  }
}
```

#### 2. Stand Service with Caching

```typescript
import { PrismaClient } from '@prisma/client';
import { StandRepository } from '../repositories/stand.repository';
import { StandCacheService } from './stand-cache.service';
import { EventPublisher } from '../events/publishers/stand.publisher';
import { StandValidator } from '../validators/stand.validator';
import { BulkImportQueue } from '../jobs/queues/stand-import.queue';

export class StandService {
  constructor(
    private repository: StandRepository,
    private cache: StandCacheService,
    private events: EventPublisher,
    private validator: StandValidator,
    private importQueue: BulkImportQueue,
    private prisma: PrismaClient
  ) {}

  async list(
    organizationId: string,
    filters: StandFilters,
    pagination: PaginationParams
  ): Promise<PaginatedResult<Stand>> {
    // Try cache first
    const cacheKey = this.cache.generateKey('list', { organizationId, filters, pagination });
    const cached = await this.cache.get<PaginatedResult<Stand>>(cacheKey);
    
    if (cached) {
      return cached;
    }
    
    // Fetch from database
    const result = await this.repository.findMany({
      where: {
        organizationId,
        ...this.buildWhereClause(filters),
      },
      skip: (pagination.page - 1) * pagination.limit,
      take: pagination.limit,
      orderBy: {
        [pagination.sortBy]: pagination.sortOrder,
      },
    });
    
    const total = await this.repository.count({
      where: {
        organizationId,
        ...this.buildWhereClause(filters),
      },
    });
    
    const response = {
      stands: result,
      pagination: {
        page: pagination.page,
        limit: pagination.limit,
        total,
        totalPages: Math.ceil(total / pagination.limit),
      },
    };
    
    // Cache the result
    await this.cache.set(cacheKey, response, 60); // 1 minute TTL
    
    return response;
  }

  async create(data: CreateStandInput): Promise<Stand> {
    // Validate input
    await this.validator.validateCreate(data);
    
    // Check for duplicate code
    const existing = await this.repository.findUnique({
      where: {
        organizationId_code_isDeleted: {
          organizationId: data.organizationId,
          code: data.code,
          isDeleted: false,
        },
      },
    });
    
    if (existing) {
      throw new ConflictError(`Stand with code ${data.code} already exists`);
    }
    
    // Create in transaction
    const stand = await this.prisma.$transaction(async (tx) => {
      // Create stand
      const newStand = await tx.stand.create({
        data: {
          ...data,
          capabilities: this.normalizeCapabilities(data.capabilities),
          metadata: data.metadata || {},
        },
      });
      
      // Create status history
      await tx.standStatusHistory.create({
        data: {
          standId: newStand.id,
          fromStatus: 'none',
          toStatus: newStand.status,
          reason: 'Initial creation',
          changedBy: data.createdBy,
        },
      });
      
      return newStand;
    });
    
    // Publish event
    await this.events.publish({
      type: 'stand.created',
      standId: stand.id,
      organizationId: stand.organizationId,
      timestamp: new Date(),
      triggeredBy: data.createdBy,
      data: { after: stand },
      metadata: { source: 'api' },
    });
    
    // Trigger capacity recalculation
    await this.events.publishCapacityRecalculation({
      type: 'capacity.recalculation_required',
      organizationId: stand.organizationId,
      triggeredBy: data.createdBy,
      timestamp: new Date(),
      data: {
        affectedStands: [stand.id],
        reason: 'stand_created',
        impactLevel: 'low',
      },
    });
    
    return stand;
  }

  async update(
    standId: string,
    data: UpdateStandInput,
    options: UpdateOptions
  ): Promise<Stand> {
    // Validate input
    await this.validator.validateUpdate(data);
    
    // Get current stand with lock
    const current = await this.repository.findUnique({
      where: {
        id: standId,
        organizationId: options.organizationId,
        isDeleted: false,
      },
    });
    
    if (!current) {
      throw new NotFoundError('Stand not found');
    }
    
    // Check version for optimistic locking
    if (options.version && current.version !== options.version) {
      throw new ConflictError('Stand has been modified by another user');
    }
    
    // Validate status transition
    if (data.status && data.status !== current.status) {
      await this.validator.validateStatusTransition(current.status, data.status);
    }
    
    // Update in transaction
    const updated = await this.prisma.$transaction(async (tx) => {
      // Update stand
      const updatedStand = await tx.stand.update({
        where: { id: standId },
        data: {
          ...data,
          capabilities: data.capabilities 
            ? this.normalizeCapabilities(data.capabilities)
            : undefined,
          version: { increment: 1 },
        },
      });
      
      // Create status history if status changed
      if (data.status && data.status !== current.status) {
        await tx.standStatusHistory.create({
          data: {
            standId: updatedStand.id,
            fromStatus: current.status,
            toStatus: data.status,
            reason: data.statusReason || 'Status updated via API',
            changedBy: data.updatedBy,
            metadata: {
              previousCapabilities: current.capabilities,
              newCapabilities: updatedStand.capabilities,
            },
          },
        });
      }
      
      return updatedStand;
    });
    
    // Publish event
    await this.events.publish({
      type: 'stand.updated',
      standId: updated.id,
      organizationId: updated.organizationId,
      timestamp: new Date(),
      triggeredBy: data.updatedBy,
      data: {
        before: current,
        after: updated,
        changes: this.getChangedFields(current, updated),
      },
      metadata: { source: 'api' },
    });
    
    // Trigger capacity recalculation if significant changes
    if (this.isSignificantChange(current, updated)) {
      await this.events.publishCapacityRecalculation({
        type: 'capacity.recalculation_required',
        organizationId: updated.organizationId,
        triggeredBy: data.updatedBy,
        timestamp: new Date(),
        data: {
          affectedStands: [updated.id],
          reason: 'stand_updated',
          impactLevel: this.calculateImpactLevel(current, updated),
        },
      });
    }
    
    return updated;
  }

  async delete(standId: string, options: DeleteOptions): Promise<void> {
    const stand = await this.repository.findUnique({
      where: {
        id: standId,
        organizationId: options.organizationId,
        isDeleted: false,
      },
    });
    
    if (!stand) {
      throw new NotFoundError('Stand not found');
    }
    
    // Check for active dependencies
    await this.validator.validateDelete(standId);
    
    // Soft delete
    await this.repository.update({
      where: { id: standId },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: options.userId,
        version: { increment: 1 },
      },
    });
    
    // Publish event
    await this.events.publish({
      type: 'stand.deleted',
      standId: stand.id,
      organizationId: stand.organizationId,
      timestamp: new Date(),
      triggeredBy: options.userId,
      data: { before: stand },
      metadata: { source: 'api' },
    });
    
    // Trigger capacity recalculation
    await this.events.publishCapacityRecalculation({
      type: 'capacity.recalculation_required',
      organizationId: stand.organizationId,
      triggeredBy: options.userId,
      timestamp: new Date(),
      data: {
        affectedStands: [stand.id],
        reason: 'stand_deleted',
        impactLevel: 'high',
      },
    });
  }

  async startBulkImport(
    file: Express.Multer.File,
    organizationId: string,
    userId: string,
    options: BulkImportOptions
  ): Promise<ImportJob> {
    // Upload file to S3
    const fileUrl = await this.uploadToS3(file);
    
    // Create import job
    const job = await this.repository.createImportJob({
      organizationId,
      filename: file.originalname,
      fileUrl,
      status: 'pending',
      totalRows: 0, // Will be updated by processor
      createdBy: userId,
    });
    
    // Queue for processing
    await this.importQueue.add('process-import', {
      jobId: job.id,
      organizationId,
      userId,
      fileUrl,
      options,
    }, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
    });
    
    return job;
  }

  private buildWhereClause(filters: StandFilters): any {
    const where: any = {
      isDeleted: false,
    };
    
    if (filters.status) {
      where.status = filters.status;
    }
    
    if (filters.terminal) {
      where.terminal = filters.terminal;
    }
    
    if (filters.aircraftSize) {
      where.capabilities = {
        path: ['aircraftSize'],
        equals: filters.aircraftSize,
      };
    }
    
    if (filters.search) {
      where.OR = [
        { code: { contains: filters.search, mode: 'insensitive' } },
        { name: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    
    return where;
  }

  private normalizeCapabilities(capabilities: any): any {
    return {
      aircraftSize: capabilities.aircraftSize || 'C',
      hasPowerSupply: capabilities.hasPowerSupply ?? true,
      hasGroundSupport: capabilities.hasGroundSupport ?? true,
      maxWeight: capabilities.maxWeight || 200,
      ...capabilities,
    };
  }

  private getChangedFields(before: Stand, after: Stand): string[] {
    const changes: string[] = [];
    const fields = ['name', 'terminal', 'status', 'capabilities', 'latitude', 'longitude'];
    
    for (const field of fields) {
      if (JSON.stringify(before[field]) !== JSON.stringify(after[field])) {
        changes.push(field);
      }
    }
    
    return changes;
  }

  private isSignificantChange(before: Stand, after: Stand): boolean {
    // Status changes are always significant
    if (before.status !== after.status) return true;
    
    // Capability changes are significant
    if (JSON.stringify(before.capabilities) !== JSON.stringify(after.capabilities)) return true;
    
    // Location changes are significant
    if (before.latitude !== after.latitude || before.longitude !== after.longitude) return true;
    
    return false;
  }

  private calculateImpactLevel(before: Stand, after: Stand): 'low' | 'medium' | 'high' {
    // Status change to/from operational is high impact
    if (before.status === 'operational' || after.status === 'operational') {
      return 'high';
    }
    
    // Aircraft size change is medium impact
    if (before.capabilities.aircraftSize !== after.capabilities.aircraftSize) {
      return 'medium';
    }
    
    return 'low';
  }
}
```

#### 3. Bulk Import Processor

```typescript
import { Job } from 'bull';
import { parse } from 'csv-parse';
import { Readable } from 'stream';
import { StandRepository } from '../../repositories/stand.repository';
import { StandValidator } from '../../validators/stand.validator';
import { S3Service } from '../../services/s3.service';
import { chunk } from 'lodash';

interface ImportJobData {
  jobId: string;
  organizationId: string;
  userId: string;
  fileUrl: string;
  options: {
    replaceExisting: boolean;
  };
}

export class StandImportProcessor {
  private readonly BATCH_SIZE = 100;
  private readonly MAX_ERRORS = 1000;

  constructor(
    private repository: StandRepository,
    private validator: StandValidator,
    private s3: S3Service,
    private prisma: PrismaClient
  ) {}

  async process(job: Job<ImportJobData>): Promise<void> {
    const { jobId, organizationId, userId, fileUrl, options } = job.data;
    
    try {
      // Update job status
      await this.updateJobStatus(jobId, { 
        status: 'processing',
        startedAt: new Date(),
      });
      
      // Download file from S3
      const fileStream = await this.s3.getObjectStream(fileUrl);
      
      // Parse CSV
      const records = await this.parseCSV(fileStream);
      
      // Update total rows
      await this.updateJobStatus(jobId, { 
        totalRows: records.length,
      });
      
      // Process in batches
      const results = await this.processBatches(
        records,
        organizationId,
        userId,
        options,
        job
      );
      
      // Update final status
      await this.updateJobStatus(jobId, {
        status: results.errorCount === 0 ? 'completed' : 'completed_with_errors',
        processedRows: records.length,
        successRows: results.successCount,
        errorRows: results.errorCount,
        errors: results.errors,
        completedAt: new Date(),
      });
      
    } catch (error) {
      await this.updateJobStatus(jobId, {
        status: 'failed',
        errors: [{
          row: 0,
          field: 'system',
          message: error.message,
          value: null,
        }],
        completedAt: new Date(),
      });
      throw error;
    }
  }

  private async processBatches(
    records: any[],
    organizationId: string,
    userId: string,
    options: any,
    job: Job
  ): Promise<{ successCount: number; errorCount: number; errors: any[] }> {
    let successCount = 0;
    let errorCount = 0;
    const errors: any[] = [];
    
    const batches = chunk(records, this.BATCH_SIZE);
    
    for (const [batchIndex, batch] of batches.entries()) {
      // Report progress
      const progress = Math.round(((batchIndex + 1) / batches.length) * 100);
      await job.progress(progress);
      
      // Process batch in transaction
      const batchResults = await this.processBatch(
        batch,
        batchIndex * this.BATCH_SIZE,
        organizationId,
        userId,
        options
      );
      
      successCount += batchResults.successCount;
      errorCount += batchResults.errorCount;
      errors.push(...batchResults.errors);
      
      // Stop if too many errors
      if (errors.length >= this.MAX_ERRORS) {
        errors.push({
          row: 0,
          field: 'system',
          message: `Import stopped after ${this.MAX_ERRORS} errors`,
          value: null,
        });
        break;
      }
      
      // Update job progress
      await this.updateJobStatus(job.data.jobId, {
        processedRows: (batchIndex + 1) * this.BATCH_SIZE,
        successRows: successCount,
        errorRows: errorCount,
      });
    }
    
    return { successCount, errorCount, errors };
  }

  private async processBatch(
    records: any[],
    startIndex: number,
    organizationId: string,
    userId: string,
    options: any
  ): Promise<{ successCount: number; errorCount: number; errors: any[] }> {
    let successCount = 0;
    let errorCount = 0;
    const errors: any[] = [];
    
    await this.prisma.$transaction(async (tx) => {
      for (const [index, record] of records.entries()) {
        const rowNumber = startIndex + index + 2; // +2 for header row and 0-index
        
        try {
          // Validate record
          const validated = await this.validator.validateImportRecord(record);
          
          // Check if exists
          const existing = await tx.stand.findUnique({
            where: {
              organizationId_code_isDeleted: {
                organizationId,
                code: validated.code,
                isDeleted: false,
              },
            },
          });
          
          if (existing && !options.replaceExisting) {
            throw new Error(`Stand code ${validated.code} already exists`);
          }
          
          // Create or update
          if (existing) {
            await tx.stand.update({
              where: { id: existing.id },
              data: {
                ...validated,
                updatedBy: userId,
                version: { increment: 1 },
              },
            });
          } else {
            await tx.stand.create({
              data: {
                ...validated,
                organizationId,
                createdBy: userId,
                updatedBy: userId,
              },
            });
          }
          
          successCount++;
          
        } catch (error) {
          errorCount++;
          errors.push({
            row: rowNumber,
            field: this.extractErrorField(error),
            message: error.message,
            value: record,
          });
        }
      }
    });
    
    return { successCount, errorCount, errors };
  }

  private async parseCSV(stream: Readable): Promise<any[]> {
    return new Promise((resolve, reject) => {
      const records: any[] = [];
      
      stream
        .pipe(parse({
          columns: true,
          skip_empty_lines: true,
          trim: true,
          cast: true,
          cast_date: true,
        }))
        .on('data', (record) => {
          records.push(this.normalizeRecord(record));
        })
        .on('error', reject)
        .on('end', () => resolve(records));
    });
  }

  private normalizeRecord(record: any): any {
    return {
      code: record.code || record.Code || record.STAND_CODE,
      name: record.name || record.Name || record.STAND_NAME,
      terminal: record.terminal || record.Terminal || record.TERMINAL,
      status: record.status || record.Status || 'operational',
      capabilities: {
        aircraftSize: record.aircraftSize || record.aircraft_size || 'C',
        hasPowerSupply: this.parseBoolean(record.hasPowerSupply || record.power_supply),
        hasGroundSupport: this.parseBoolean(record.hasGroundSupport || record.ground_support),
        maxWeight: parseFloat(record.maxWeight || record.max_weight) || 200,
      },
      latitude: parseFloat(record.latitude || record.lat),
      longitude: parseFloat(record.longitude || record.lon || record.lng),
      metadata: this.parseMetadata(record),
    };
  }

  private parseBoolean(value: any): boolean {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'string') {
      return ['true', 'yes', '1', 'y'].includes(value.toLowerCase());
    }
    return Boolean(value);
  }

  private parseMetadata(record: any): any {
    const metadata: any = {};
    
    // Include any extra fields not in the standard schema
    const standardFields = [
      'code', 'name', 'terminal', 'status', 'aircraftSize',
      'hasPowerSupply', 'hasGroundSupport', 'maxWeight',
      'latitude', 'longitude',
    ];
    
    for (const [key, value] of Object.entries(record)) {
      if (!standardFields.includes(key) && value != null) {
        metadata[key] = value;
      }
    }
    
    return Object.keys(metadata).length > 0 ? metadata : {};
  }

  private extractErrorField(error: any): string {
    if (error.field) return error.field;
    if (error.message.includes('code')) return 'code';
    if (error.message.includes('name')) return 'name';
    return 'unknown';
  }

  private async updateJobStatus(jobId: string, updates: any): Promise<void> {
    await this.repository.updateImportJob({
      where: { id: jobId },
      data: updates,
    });
  }
}
```

#### 4. Caching Layer

```typescript
import { Redis } from 'ioredis';
import { createHash } from 'crypto';

export class StandCacheService {
  private readonly DEFAULT_TTL = 300; // 5 minutes
  
  constructor(private redis: Redis) {}

  async get<T>(key: string): Promise<T | null> {
    const value = await this.redis.get(key);
    if (!value) return null;
    
    try {
      return JSON.parse(value);
    } catch {
      return null;
    }
  }

  async set(key: string, value: any, ttl?: number): Promise<void> {
    const serialized = JSON.stringify(value);
    
    if (ttl) {
      await this.redis.setex(key, ttl, serialized);
    } else {
      await this.redis.setex(key, this.DEFAULT_TTL, serialized);
    }
  }

  async invalidate(keys: string | string[]): Promise<void> {
    const keysArray = Array.isArray(keys) ? keys : [keys];
    
    if (keysArray.length > 0) {
      await this.redis.del(...keysArray);
    }
  }

  async invalidatePattern(pattern: string): Promise<void> {
    const keys = await this.redis.keys(pattern);
    
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }

  generateKey(operation: string, params: any): string {
    const normalized = this.normalizeParams(params);
    const hash = createHash('sha256')
      .update(JSON.stringify(normalized))
      .digest('hex')
      .substring(0, 8);
    
    return `stands:${operation}:${hash}`;
  }

  private normalizeParams(params: any): any {
    // Sort object keys for consistent hashing
    if (typeof params === 'object' && params !== null) {
      const sorted: any = {};
      Object.keys(params).sort().forEach(key => {
        sorted[key] = this.normalizeParams(params[key]);
      });
      return sorted;
    }
    return params;
  }
}

// Cache middleware decorator
export function cache(options: { ttl?: number; keyPattern?: string } = {}) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const cacheService = this.cache;
      
      if (!cacheService) {
        return originalMethod.apply(this, args);
      }
      
      // Generate cache key
      const key = options.keyPattern
        ? options.keyPattern.replace(/{(\w+)}/g, (_, p) => args[0][p] || '')
        : cacheService.generateKey(propertyKey, args);
      
      // Try cache
      const cached = await cacheService.get(key);
      if (cached) {
        return cached;
      }
      
      // Execute method
      const result = await originalMethod.apply(this, args);
      
      // Cache result
      await cacheService.set(key, result, options.ttl);
      
      return result;
    };
    
    return descriptor;
  };
}
```

#### 5. Validation Layer

```typescript
import Joi from 'joi';
import { GeometryValidator } from '../utils/geometry-validator';

export class StandValidator {
  private geometryValidator: GeometryValidator;
  
  constructor() {
    this.geometryValidator = new GeometryValidator();
  }

  async validateCreate(data: any): Promise<void> {
    const schema = Joi.object({
      organizationId: Joi.string().uuid().required(),
      code: Joi.string()
        .pattern(/^[A-Z0-9]{1,10}$/)
        .required()
        .messages({
          'string.pattern.base': 'Stand code must be 1-10 alphanumeric characters',
        }),
      name: Joi.string().min(1).max(255).required(),
      terminal: Joi.string().max(10).allow(null),
      status: Joi.string()
        .valid('operational', 'maintenance', 'closed')
        .default('operational'),
      capabilities: Joi.object({
        aircraftSize: Joi.string()
          .valid('A', 'B', 'C', 'D', 'E', 'F')
          .required(),
        hasPowerSupply: Joi.boolean().default(true),
        hasGroundSupport: Joi.boolean().default(true),
        maxWeight: Joi.number().min(0).max(1000).default(200),
      }).required(),
      geometry: Joi.object().allow(null),
      latitude: Joi.number().min(-90).max(90).allow(null),
      longitude: Joi.number().min(-180).max(180).allow(null),
      metadata: Joi.object().default({}),
      createdBy: Joi.string().required(),
      updatedBy: Joi.string().required(),
    });
    
    const { error } = schema.validate(data);
    if (error) {
      throw new ValidationError(error.message);
    }
    
    // Validate geometry if provided
    if (data.geometry) {
      const geometryValid = await this.geometryValidator.validate(data.geometry);
      if (!geometryValid) {
        throw new ValidationError('Invalid GeoJSON geometry');
      }
    }
    
    // Validate lat/lng pair
    if ((data.latitude != null) !== (data.longitude != null)) {
      throw new ValidationError('Both latitude and longitude must be provided together');
    }
  }

  async validateUpdate(data: any): Promise<void> {
    const schema = Joi.object({
      name: Joi.string().min(1).max(255),
      terminal: Joi.string().max(10).allow(null),
      status: Joi.string().valid('operational', 'maintenance', 'closed'),
      capabilities: Joi.object({
        aircraftSize: Joi.string().valid('A', 'B', 'C', 'D', 'E', 'F'),
        hasPowerSupply: Joi.boolean(),
        hasGroundSupport: Joi.boolean(),
        maxWeight: Joi.number().min(0).max(1000),
      }),
      geometry: Joi.object().allow(null),
      latitude: Joi.number().min(-90).max(90).allow(null),
      longitude: Joi.number().min(-180).max(180).allow(null),
      metadata: Joi.object(),
      statusReason: Joi.string().max(500),
      updatedBy: Joi.string().required(),
    }).min(2); // At least one field besides updatedBy
    
    const { error } = schema.validate(data);
    if (error) {
      throw new ValidationError(error.message);
    }
  }

  async validateStatusTransition(from: string, to: string): Promise<void> {
    const validTransitions: Record<string, string[]> = {
      operational: ['maintenance', 'closed'],
      maintenance: ['operational', 'closed'],
      closed: ['operational', 'maintenance'],
    };
    
    if (!validTransitions[from]?.includes(to)) {
      throw new ValidationError(`Invalid status transition from ${from} to ${to}`);
    }
  }

  async validateDelete(standId: string): Promise<void> {
    // Check for active work requests
    // This would typically check against other modules
    // For now, we'll assume this check is performed elsewhere
  }

  async validateImportRecord(record: any): Promise<any> {
    const schema = Joi.object({
      code: Joi.string()
        .pattern(/^[A-Z0-9]{1,10}$/)
        .required(),
      name: Joi.string().min(1).max(255).required(),
      terminal: Joi.string().max(10).allow(null, ''),
      status: Joi.string()
        .valid('operational', 'maintenance', 'closed')
        .default('operational'),
      capabilities: Joi.object({
        aircraftSize: Joi.string()
          .valid('A', 'B', 'C', 'D', 'E', 'F')
          .default('C'),
        hasPowerSupply: Joi.boolean().default(true),
        hasGroundSupport: Joi.boolean().default(true),
        maxWeight: Joi.number().min(0).max(1000).default(200),
      }).default(),
      latitude: Joi.number().min(-90).max(90).allow(null),
      longitude: Joi.number().min(-180).max(180).allow(null),
      metadata: Joi.object().default({}),
    });
    
    const { error, value } = schema.validate(record);
    if (error) {
      throw new ValidationError(error.message);
    }
    
    return value;
  }
}

// Validation schemas for request validation
export const standSchemas = {
  list: Joi.object({
    query: Joi.object({
      status: Joi.string().valid('operational', 'maintenance', 'closed'),
      aircraftSize: Joi.string().valid('A', 'B', 'C', 'D', 'E', 'F'),
      search: Joi.string().max(100),
      terminal: Joi.string().max(10),
      page: Joi.number().integer().min(1).default(1),
      limit: Joi.number().integer().min(1).max(100).default(50),
      sortBy: Joi.string().valid('code', 'name', 'createdAt', 'updatedAt').default('code'),
      sortOrder: Joi.string().valid('asc', 'desc').default('asc'),
    }),
  }),
  
  create: Joi.object({
    body: Joi.object({
      code: Joi.string().pattern(/^[A-Z0-9]{1,10}$/).required(),
      name: Joi.string().min(1).max(255).required(),
      terminal: Joi.string().max(10).allow(null),
      status: Joi.string()
        .valid('operational', 'maintenance', 'closed')
        .default('operational'),
      capabilities: Joi.object({
        aircraftSize: Joi.string().valid('A', 'B', 'C', 'D', 'E', 'F').required(),
        hasPowerSupply: Joi.boolean().default(true),
        hasGroundSupport: Joi.boolean().default(true),
        maxWeight: Joi.number().min(0).max(1000).default(200),
      }).required(),
      geometry: Joi.object().allow(null),
      latitude: Joi.number().min(-90).max(90).allow(null),
      longitude: Joi.number().min(-180).max(180).allow(null),
      metadata: Joi.object().default({}),
    }),
  }),
  
  update: Joi.object({
    params: Joi.object({
      standId: Joi.string().uuid().required(),
    }),
    body: Joi.object({
      name: Joi.string().min(1).max(255),
      terminal: Joi.string().max(10).allow(null),
      status: Joi.string().valid('operational', 'maintenance', 'closed'),
      capabilities: Joi.object({
        aircraftSize: Joi.string().valid('A', 'B', 'C', 'D', 'E', 'F'),
        hasPowerSupply: Joi.boolean(),
        hasGroundSupport: Joi.boolean(),
        maxWeight: Joi.number().min(0).max(1000),
      }),
      geometry: Joi.object().allow(null),
      latitude: Joi.number().min(-90).max(90).allow(null),
      longitude: Joi.number().min(-180).max(180).allow(null),
      metadata: Joi.object(),
      statusReason: Joi.string().max(500),
      version: Joi.number().integer().min(1),
    }).min(1),
  }),
};
```

### Performance Optimizations

#### 1. Database Indexes

```sql
-- Performance indexes
CREATE INDEX idx_stands_org_status_deleted ON assets.stands(organization_id, status, is_deleted);
CREATE INDEX idx_stands_org_terminal_deleted ON assets.stands(organization_id, terminal, is_deleted);
CREATE INDEX idx_stands_org_created ON assets.stands(organization_id, created_at DESC);
CREATE INDEX idx_stands_location ON assets.stands(latitude, longitude) WHERE latitude IS NOT NULL;
CREATE INDEX idx_stands_capabilities_aircraft ON assets.stands USING GIN((capabilities->'aircraftSize'));

-- Full text search
CREATE INDEX idx_stands_search ON assets.stands USING GIN(
  to_tsvector('english', code || ' ' || name)
);

-- Status history performance
CREATE INDEX idx_status_history_stand_time ON assets.stand_status_history(stand_id, changed_at DESC);
CREATE INDEX idx_status_history_time ON assets.stand_status_history(changed_at DESC);

-- Import jobs
CREATE INDEX idx_import_jobs_org_status_created ON assets.stand_import_jobs(organization_id, status, created_at DESC);
```

#### 2. Query Optimization

```typescript
// Optimized repository queries
export class StandRepository {
  async findManyOptimized(params: FindManyParams): Promise<Stand[]> {
    const query = this.prisma.$queryRaw<Stand[]>`
      SELECT 
        s.*,
        COUNT(*) OVER() as total_count
      FROM assets.stands s
      WHERE s.organization_id = ${params.organizationId}
        AND s.is_deleted = false
        ${params.status ? Prisma.sql`AND s.status = ${params.status}` : Prisma.empty}
        ${params.terminal ? Prisma.sql`AND s.terminal = ${params.terminal}` : Prisma.empty}
        ${params.aircraftSize ? Prisma.sql`AND s.capabilities->>'aircraftSize' = ${params.aircraftSize}` : Prisma.empty}
        ${params.search ? Prisma.sql`
          AND (
            s.code ILIKE ${`%${params.search}%`}
            OR s.name ILIKE ${`%${params.search}%`}
          )
        ` : Prisma.empty}
      ORDER BY ${Prisma.raw(params.sortBy)} ${Prisma.raw(params.sortOrder)}
      LIMIT ${params.limit}
      OFFSET ${params.offset}
    `;
    
    return query;
  }

  async warmCache(organizationId: string): Promise<void> {
    // Pre-load commonly accessed data
    const commonQueries = [
      { status: 'operational' },
      { aircraftSize: 'C' },
      { aircraftSize: 'D' },
    ];
    
    for (const filters of commonQueries) {
      await this.findMany({
        where: { organizationId, ...filters, isDeleted: false },
        take: 50,
      });
    }
  }
}
```

### Security Implementation

#### 1. Row Level Security Policies

```sql
-- Enhanced RLS policies with performance considerations
CREATE POLICY "stands_organization_isolation" ON assets.stands
  USING (
    organization_id = current_setting('app.current_organization_id')::uuid
    AND is_deleted = false
  );

-- Bypass RLS for service accounts (with audit)
CREATE POLICY "stands_service_account_access" ON assets.stands
  USING (
    current_setting('app.service_account', true) = 'true'
    AND current_setting('app.audit_user_id', true) IS NOT NULL
  );

-- Create security definer functions for complex operations
CREATE OR REPLACE FUNCTION assets.get_stands_with_capacity()
RETURNS TABLE (
  id uuid,
  code varchar,
  name varchar,
  status varchar,
  available_capacity integer
) 
SECURITY DEFINER
AS $$
BEGIN
  -- Verify organization access
  IF NOT has_module_access(current_setting('app.current_organization_id')::uuid, 'assets') THEN
    RAISE EXCEPTION 'Access denied to assets module';
  END IF;
  
  RETURN QUERY
  SELECT 
    s.id,
    s.code,
    s.name,
    s.status,
    CASE 
      WHEN s.status = 'operational' THEN 100
      WHEN s.status = 'maintenance' THEN 50
      ELSE 0
    END as available_capacity
  FROM assets.stands s
  WHERE s.organization_id = current_setting('app.current_organization_id')::uuid
    AND s.is_deleted = false;
END;
$$ LANGUAGE plpgsql;
```

#### 2. API Security Middleware

```typescript
import { Request, Response, NextFunction } from 'express';
import { RateLimiter } from 'rate-limiter-flexible';
import { verify } from 'jsonwebtoken';

// Rate limiting per organization
const rateLimiter = new RateLimiter({
  storeClient: redisClient,
  keyPrefix: 'rl:stands',
  points: 100, // requests
  duration: 60, // per minute
  blockDuration: 60 * 5, // 5 minutes
});

export const standsRateLimiter = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const key = `${req.organizationId}:${req.method}:${req.path}`;
    await rateLimiter.consume(key);
    next();
  } catch (rateLimiterRes) {
    res.status(429).json({
      error: 'Too many requests',
      retryAfter: Math.round(rateLimiterRes.msBeforeNext / 1000) || 60,
    });
  }
};

// Input sanitization
export const sanitizeInput = (req: Request, res: Response, next: NextFunction) => {
  // Sanitize all string inputs
  const sanitize = (obj: any): any => {
    if (typeof obj === 'string') {
      return obj.trim().replace(/[<>]/g, ''); // Basic XSS prevention
    }
    if (Array.isArray(obj)) {
      return obj.map(sanitize);
    }
    if (obj && typeof obj === 'object') {
      const sanitized: any = {};
      for (const [key, value] of Object.entries(obj)) {
        sanitized[key] = sanitize(value);
      }
      return sanitized;
    }
    return obj;
  };
  
  req.body = sanitize(req.body);
  req.query = sanitize(req.query);
  next();
};

// Audit logging
export const auditLog = (action: string) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();
    const originalSend = res.send;
    
    res.send = function (data: any) {
      res.send = originalSend;
      
      // Log the audit event
      logger.info('API Audit', {
        action,
        organizationId: req.organizationId,
        userId: req.userId,
        method: req.method,
        path: req.path,
        params: req.params,
        query: req.query,
        statusCode: res.statusCode,
        duration: Date.now() - startTime,
        ip: req.ip,
        userAgent: req.get('user-agent'),
      });
      
      return res.send(data);
    };
    
    next();
  };
};
```

### Monitoring & Observability

#### 1. Custom Metrics

```typescript
import { register, Counter, Histogram, Gauge, Summary } from 'prom-client';

// Business metrics
const standUtilization = new Gauge({
  name: 'stand_utilization_ratio',
  help: 'Ratio of operational stands to total stands',
  labelNames: ['organization_id', 'terminal'],
});

const importSuccessRate = new Summary({
  name: 'stand_import_success_rate',
  help: 'Success rate of stand imports',
  labelNames: ['organization_id'],
  percentiles: [0.5, 0.9, 0.99],
});

// Cache metrics
const cacheHitRate = new Counter({
  name: 'stand_cache_hits_total',
  help: 'Cache hit rate for stand queries',
  labelNames: ['operation', 'hit'],
});

// Database connection pool metrics
const dbPoolSize = new Gauge({
  name: 'stand_db_pool_size',
  help: 'Database connection pool size',
  labelNames: ['state'], // 'active', 'idle', 'waiting'
});

// Export metrics endpoint
export const metricsHandler = async (req: Request, res: Response) => {
  // Update dynamic metrics
  await updateBusinessMetrics();
  
  res.set('Content-Type', register.contentType);
  res.end(await register.metrics());
};

async function updateBusinessMetrics() {
  // Update stand utilization
  const utilization = await prisma.$queryRaw<any[]>`
    SELECT 
      organization_id,
      terminal,
      COUNT(*) FILTER (WHERE status = 'operational') as operational,
      COUNT(*) as total
    FROM assets.stands
    WHERE is_deleted = false
    GROUP BY organization_id, terminal
  `;
  
  for (const row of utilization) {
    standUtilization.set(
      { 
        organization_id: row.organization_id, 
        terminal: row.terminal || 'none' 
      },
      row.operational / row.total
    );
  }
}
```

#### 2. Distributed Tracing

```typescript
import { trace, context, SpanStatusCode, SpanKind } from '@opentelemetry/api';
import { SemanticAttributes } from '@opentelemetry/semantic-conventions';

const tracer = trace.getTracer('stands-service', '1.0.0');

// Trace middleware
export const traceMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const span = tracer.startSpan(`${req.method} ${req.route?.path || req.path}`, {
    kind: SpanKind.SERVER,
    attributes: {
      [SemanticAttributes.HTTP_METHOD]: req.method,
      [SemanticAttributes.HTTP_URL]: req.url,
      [SemanticAttributes.HTTP_TARGET]: req.path,
      'organization.id': req.organizationId,
      'user.id': req.userId,
    },
  });
  
  // Inject span into context
  context.with(trace.setSpan(context.active(), span), () => {
    // Track response
    const originalSend = res.send;
    res.send = function (data: any) {
      span.setAttributes({
        [SemanticAttributes.HTTP_STATUS_CODE]: res.statusCode,
        'response.size': Buffer.byteLength(data),
      });
      
      if (res.statusCode >= 400) {
        span.setStatus({ code: SpanStatusCode.ERROR });
      }
      
      span.end();
      return originalSend.call(this, data);
    };
    
    next();
  });
};

// Database query tracing
export class TracedPrismaClient extends PrismaClient {
  constructor(options?: PrismaClientOptions) {
    super({
      ...options,
      log: [
        {
          emit: 'event',
          level: 'query',
        },
      ],
    });
    
    this.$on('query', (e) => {
      const span = tracer.startSpan('db.query', {
        kind: SpanKind.CLIENT,
        attributes: {
          'db.system': 'postgresql',
          'db.statement': e.query,
          'db.operation': this.extractOperation(e.query),
          'db.duration': e.duration,
        },
      });
      
      span.end();
    });
  }
  
  private extractOperation(query: string): string {
    const operation = query.trim().split(' ')[0].toUpperCase();
    return operation;
  }
}
```

### Testing Strategy

#### 1. Unit Tests

```typescript
import { StandService } from '../src/services/stand.service';
import { StandValidator } from '../src/validators/stand.validator';

describe('StandService', () => {
  let service: StandService;
  let mockRepository: jest.Mocked<StandRepository>;
  let mockCache: jest.Mocked<StandCacheService>;
  let mockEvents: jest.Mocked<EventPublisher>;
  
  beforeEach(() => {
    mockRepository = createMockRepository();
    mockCache = createMockCache();
    mockEvents = createMockEventPublisher();
    
    service = new StandService(
      mockRepository,
      mockCache,
      mockEvents,
      new StandValidator(),
      mockImportQueue,
      mockPrisma
    );
  });
  
  describe('create', () => {
    it('should create a stand with valid data', async () => {
      const input = {
        organizationId: 'org-123',
        code: 'A1',
        name: 'Alpha 1',
        capabilities: { aircraftSize: 'C' },
        createdBy: 'user-123',
        updatedBy: 'user-123',
      };
      
      mockRepository.findUnique.mockResolvedValue(null);
      mockRepository.create.mockResolvedValue({ id: 'stand-123', ...input });
      
      const result = await service.create(input);
      
      expect(result).toHaveProperty('id', 'stand-123');
      expect(mockEvents.publish).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'stand.created',
          standId: 'stand-123',
        })
      );
    });
    
    it('should reject duplicate stand codes', async () => {
      mockRepository.findUnique.mockResolvedValue({ id: 'existing-stand' });
      
      await expect(service.create({
        organizationId: 'org-123',
        code: 'A1',
        name: 'Alpha 1',
        capabilities: { aircraftSize: 'C' },
        createdBy: 'user-123',
        updatedBy: 'user-123',
      })).rejects.toThrow('Stand with code A1 already exists');
    });
  });
  
  describe('caching', () => {
    it('should return cached results when available', async () => {
      const cachedData = { stands: [], pagination: { total: 0 } };
      mockCache.get.mockResolvedValue(cachedData);
      
      const result = await service.list('org-123', {}, { page: 1, limit: 50 });
      
      expect(result).toEqual(cachedData);
      expect(mockRepository.findMany).not.toHaveBeenCalled();
    });
    
    it('should invalidate cache on updates', async () => {
      await service.update('stand-123', { name: 'Updated' }, { organizationId: 'org-123' });
      
      expect(mockCache.invalidate).toHaveBeenCalledWith([
        'stands:stand-123',
        'stands:*:org-123:*',
      ]);
    });
  });
});
```

#### 2. Integration Tests

```typescript
import request from 'supertest';
import { app } from '../src/app';
import { prisma } from '../src/prisma';

describe('Stand API Integration', () => {
  beforeEach(async () => {
    await prisma.stand.deleteMany();
  });
  
  describe('POST /api/assets/stands', () => {
    it('should create a stand with all fields', async () => {
      const response = await request(app)
        .post('/api/assets/stands')
        .set('X-Organization-Id', 'test-org')
        .set('X-User-Id', 'test-user')
        .send({
          code: 'A1',
          name: 'Alpha 1',
          terminal: 'T1',
          status: 'operational',
          capabilities: {
            aircraftSize: 'C',
            hasPowerSupply: true,
            hasGroundSupport: true,
            maxWeight: 250,
          },
          latitude: 51.4775,
          longitude: -0.4614,
        });
      
      expect(response.status).toBe(201);
      expect(response.body).toMatchObject({
        code: 'A1',
        name: 'Alpha 1',
        terminal: 'T1',
        status: 'operational',
      });
      
      // Verify database
      const created = await prisma.stand.findUnique({
        where: { id: response.body.id },
      });
      expect(created).toBeTruthy();
      
      // Verify event was published
      const events = await getPublishedEvents();
      expect(events).toContainEqual(
        expect.objectContaining({
          type: 'stand.created',
          standId: response.body.id,
        })
      );
    });
  });
  
  describe('Bulk Import', () => {
    it('should process CSV file successfully', async () => {
      const csv = `code,name,terminal,status,aircraftSize
A1,Alpha 1,T1,operational,C
A2,Alpha 2,T1,operational,D
B1,Bravo 1,T2,maintenance,E`;
      
      const response = await request(app)
        .post('/api/assets/stands/bulk-import')
        .set('X-Organization-Id', 'test-org')
        .set('X-User-Id', 'test-user')
        .attach('file', Buffer.from(csv), 'stands.csv')
        .field('replaceExisting', 'false');
      
      expect(response.status).toBe(202);
      expect(response.body).toHaveProperty('jobId');
      
      // Wait for job completion
      await waitForJob(response.body.jobId);
      
      // Verify import
      const job = await prisma.standImportJob.findUnique({
        where: { id: response.body.jobId },
      });
      
      expect(job.status).toBe('completed');
      expect(job.successRows).toBe(3);
      expect(job.errorRows).toBe(0);
      
      // Verify stands created
      const stands = await prisma.stand.findMany({
        where: { organizationId: 'test-org' },
      });
      expect(stands).toHaveLength(3);
    });
  });
});
```

#### 3. Performance Tests

```typescript
import autocannon from 'autocannon';

describe('Stand API Performance', () => {
  it('should handle 1000 req/s for list endpoint', async () => {
    const result = await autocannon({
      url: 'http://localhost:3000/api/assets/stands',
      connections: 10,
      pipelining: 1,
      duration: 10,
      headers: {
        'X-Organization-Id': 'perf-test-org',
      },
    });
    
    expect(result.errors).toBe(0);
    expect(result.timeouts).toBe(0);
    expect(result.requests.average).toBeGreaterThan(1000);
    expect(result.latency.p99).toBeLessThan(100); // 99th percentile < 100ms
  });
  
  it('should handle concurrent bulk imports', async () => {
    const imports = Array(10).fill(null).map((_, i) => 
      uploadBulkFile(`import-${i}.csv`, 1000) // 1000 records each
    );
    
    const results = await Promise.all(imports);
    
    expect(results.every(r => r.status === 202)).toBe(true);
    
    // Wait for all jobs
    await Promise.all(results.map(r => waitForJob(r.jobId)));
    
    // Verify all succeeded
    const jobs = await prisma.standImportJob.findMany({
      where: { organizationId: 'perf-test-org' },
    });
    
    expect(jobs.every(j => j.status === 'completed')).toBe(true);
  });
});
```

## Frontend Implementation

### 1. Stand List Component with shadcn/ui

```tsx
import React, { useState, useCallback } from 'react';
import { useStands } from '../hooks/useStands';
import { StandTable } from './StandTable';
import { StandFilters } from './StandFilters';
import { StandForm } from './StandForm';
import { StandImport } from './StandImport';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Plus, Upload, MoreVertical } from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';

export const StandList: React.FC = () => {
  const [filters, setFilters] = useState<StandFilters>({
    search: '',
    status: undefined,
    terminal: undefined,
    aircraftSize: undefined,
  });
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 50,
    sortBy: 'code' as const,
    sortOrder: 'asc' as const,
  });
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showImportModal, setShowImportModal] = useState(false);
  const [selectedStand, setSelectedStand] = useState<Stand | null>(null);
  
  const { data, isLoading, error } = useStands(filters, pagination);
  const { showToast } = useToast();
  
  const handleFilterChange = useCallback((newFilters: Partial<StandFilters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
    setPagination(prev => ({ ...prev, page: 1 }));
  }, []);
  
  const handleSort = useCallback((column: string) => {
    setPagination(prev => ({
      ...prev,
      sortBy: column as any,
      sortOrder: prev.sortBy === column && prev.sortOrder === 'asc' ? 'desc' : 'asc',
      page: 1,
    }));
  }, []);
  
  const handlePageChange = useCallback((page: number) => {
    setPagination(prev => ({ ...prev, page }));
  }, []);
  
  const handleStandSaved = useCallback(() => {
    setShowCreateModal(false);
    setSelectedStand(null);
    toast({
      title: 'Success',
      description: selectedStand ? 'Stand updated successfully' : 'Stand created successfully',
    });
  }, [selectedStand, toast]);
  
  const handleEdit = useCallback((stand: Stand) => {
    setSelectedStand(stand);
    setShowCreateModal(true);
  }, []);
  
  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">
            Aircraft Stands
          </h1>
          <p className="text-muted-foreground">
            {data ? `${data.pagination.total} total` : 'Loading...'}
          </p>
        </div>
        <div className="flex items-center space-x-2">
          <Button
            variant="outline"
            onClick={() => setShowImportModal(true)}
          >
            <Upload className="mr-2 h-4 w-4" />
            Import CSV
          </Button>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="icon">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem>Export CSV</DropdownMenuItem>
              <DropdownMenuItem>Export JSON</DropdownMenuItem>
              <DropdownMenuItem>View Audit Log</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          <Button
            onClick={() => {
              setSelectedStand(null);
              setShowCreateModal(true);
            }}
          >
            <Plus className="mr-2 h-4 w-4" />
            Add Stand
          </Button>
        </div>
      </div>
      
      {/* Filters */}
      <StandFilters
        filters={filters}
        onChange={handleFilterChange}
      />
      
      {/* Table */}
      <StandTable
        stands={data?.stands || []}
        isLoading={isLoading}
        error={error}
        pagination={data?.pagination}
        sortBy={pagination.sortBy}
        sortOrder={pagination.sortOrder}
        onSort={handleSort}
        onPageChange={handlePageChange}
        onEdit={handleEdit}
      />
      
      {/* Create/Edit Dialog */}
      <Dialog open={showCreateModal} onOpenChange={setShowCreateModal}>
        <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>
              {selectedStand ? `Edit Stand ${selectedStand.code}` : 'Create New Stand'}
            </DialogTitle>
          </DialogHeader>
          <StandForm
            stand={selectedStand}
            onSave={handleStandSaved}
            onCancel={() => {
              setShowCreateModal(false);
              setSelectedStand(null);
            }}
          />
        </DialogContent>
      </Dialog>
      
      {/* Import Sheet */}
      <Sheet open={showImportModal} onOpenChange={setShowImportModal}>
        <SheetContent className="w-full sm:max-w-xl">
          <SheetHeader>
            <SheetTitle>Import Stands from CSV</SheetTitle>
          </SheetHeader>
          <StandImport
            onComplete={() => {
              setShowImportModal(false);
              toast({
                title: 'Import Complete',
                description: 'Stands imported successfully',
              });
            }}
            onCancel={() => setShowImportModal(false)}
          />
        </SheetContent>
      </Sheet>
    </div>
  );
};
```

### 2. Data Fetching Hook with React Query

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { standsApi } from '../api/stands.api';
import { Stand, StandFilters, CreateStandRequest, UpdateStandRequest } from '../api/stands.types';
import { useWebSocket } from '@/shared/hooks/useWebSocket';
import { useEffect } from 'react';

const STANDS_QUERY_KEY = 'stands';

export const useStands = (filters: StandFilters, pagination: PaginationParams) => {
  const queryClient = useQueryClient();
  const { subscribe, unsubscribe } = useWebSocket();
  
  // Subscribe to real-time updates
  useEffect(() => {
    const handleStandUpdate = (event: StandEvent) => {
      // Invalidate relevant queries based on event type
      switch (event.type) {
        case 'stand.created':
        case 'stand.updated':
        case 'stand.deleted':
          queryClient.invalidateQueries([STANDS_QUERY_KEY]);
          break;
        case 'stand.status_changed':
          // Update specific stand in cache
          queryClient.setQueryData(
            [STANDS_QUERY_KEY, event.standId],
            (old: Stand | undefined) => {
              if (old && event.data.after) {
                return { ...old, ...event.data.after };
              }
              return old;
            }
          );
          queryClient.invalidateQueries([STANDS_QUERY_KEY, 'list']);
          break;
      }
    };
    
    const unsubscribeId = subscribe('stand.*', handleStandUpdate);
    
    return () => {
      unsubscribe(unsubscribeId);
    };
  }, [queryClient, subscribe, unsubscribe]);
  
  return useQuery({
    queryKey: [STANDS_QUERY_KEY, 'list', filters, pagination],
    queryFn: () => standsApi.list(filters, pagination),
    staleTime: 60 * 1000, // 1 minute
    cacheTime: 5 * 60 * 1000, // 5 minutes
  });
};

export const useStandMutations = () => {
  const queryClient = useQueryClient();
  const { showToast } = useToast();
  
  const createMutation = useMutation({
    mutationFn: (data: CreateStandRequest) => standsApi.create(data),
    onSuccess: (stand) => {
      queryClient.invalidateQueries([STANDS_QUERY_KEY]);
      showToast({
        type: 'success',
        message: `Stand ${stand.code} created successfully`,
      });
    },
    onError: (error: any) => {
      showToast({
        type: 'error',
        message: error.response?.data?.message || 'Failed to create stand',
      });
    },
  });
  
  const updateMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateStandRequest }) => 
      standsApi.update(id, data),
    onSuccess: (stand) => {
      queryClient.invalidateQueries([STANDS_QUERY_KEY]);
      queryClient.setQueryData([STANDS_QUERY_KEY, stand.id], stand);
      showToast({
        type: 'success',
        message: `Stand ${stand.code} updated successfully`,
      });
    },
    onError: (error: any) => {
      if (error.response?.status === 409) {
        showToast({
          type: 'error',
          message: 'Stand has been modified by another user. Please refresh and try again.',
        });
      } else {
        showToast({
          type: 'error',
          message: error.response?.data?.message || 'Failed to update stand',
        });
      }
    },
  });
  
  const deleteMutation = useMutation({
    mutationFn: (id: string) => standsApi.delete(id),
    onSuccess: (_, id) => {
      queryClient.invalidateQueries([STANDS_QUERY_KEY]);
      queryClient.removeQueries([STANDS_QUERY_KEY, id]);
      showToast({
        type: 'success',
        message: 'Stand deleted successfully',
      });
    },
    onError: (error: any) => {
      showToast({
        type: 'error',
        message: error.response?.data?.message || 'Failed to delete stand',
      });
    },
  });
  
  return {
    create: createMutation.mutate,
    update: updateMutation.mutate,
    delete: deleteMutation.mutate,
    isCreating: createMutation.isLoading,
    isUpdating: updateMutation.isLoading,
    isDeleting: deleteMutation.isLoading,
  };
};
```

### 3. Stand Table Component with shadcn/ui DataTable

```tsx
import React, { useMemo } from 'react';
import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
  SortingState,
  getSortedRowModel,
} from '@tanstack/react-table';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  ChevronDown,
  ChevronUp,
  ChevronLeft,
  ChevronRight,
  ChevronFirst,
  ChevronLast,
  MoreHorizontal,
  Pencil,
  Trash2,
  Zap,
  Wrench,
} from 'lucide-react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { formatDate } from '@/lib/utils';
import { Stand } from '../api/stands.types';

interface StandTableProps {
  stands: Stand[];
  isLoading: boolean;
  error: Error | null;
  pagination?: Pagination;
  sortBy: string;
  sortOrder: 'asc' | 'desc';
  onSort: (column: string) => void;
  onPageChange: (page: number) => void;
  onEdit: (stand: Stand) => void;
}

export const StandTable: React.FC<StandTableProps> = ({
  stands,
  isLoading,
  error,
  pagination,
  sortBy,
  sortOrder,
  onSort,
  onPageChange,
  onEdit,
}) => {
  const [rowSelection, setRowSelection] = React.useState({});
  const [sorting, setSorting] = React.useState<SortingState>([
    { id: sortBy, desc: sortOrder === 'desc' },
  ]);

  const columns: ColumnDef<Stand>[] = useMemo(() => [
    {
      id: 'select',
      header: ({ table }) => (
        <Checkbox
          checked={table.getIsAllPageRowsSelected()}
          onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
          aria-label="Select all"
        />
      ),
      cell: ({ row }) => (
        <Checkbox
          checked={row.getIsSelected()}
          onCheckedChange={(value) => row.toggleSelected(!!value)}
          aria-label="Select row"
        />
      ),
      enableSorting: false,
      enableHiding: false,
    },
    {
      accessorKey: 'code',
      header: ({ column }) => {
        return (
          <Button
            variant="ghost"
            onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
          >
            Code
            {column.getIsSorted() === "asc" ? (
              <ChevronUp className="ml-2 h-4 w-4" />
            ) : column.getIsSorted() === "desc" ? (
              <ChevronDown className="ml-2 h-4 w-4" />
            ) : null}
          </Button>
        );
      },
      cell: ({ row }) => <div className="font-medium">{row.getValue('code')}</div>,
    },
    {
      accessorKey: 'name',
      header: ({ column }) => {
        return (
          <Button
            variant="ghost"
            onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
          >
            Name
          </Button>
        );
      },
    },
    {
      accessorKey: 'terminal',
      header: 'Terminal',
      cell: ({ row }) => row.getValue('terminal') || '-',
    },
    {
      accessorKey: 'status',
      header: ({ column }) => {
        return (
          <Button
            variant="ghost"
            onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
          >
            Status
          </Button>
        );
      },
      cell: ({ row }) => {
        const status = row.getValue('status') as string;
        return (
          <Badge
            variant={
              status === 'operational'
                ? 'default'
                : status === 'maintenance'
                ? 'warning'
                : 'secondary'
            }
          >
            {status}
          </Badge>
        );
      },
    },
    {
      accessorKey: 'capabilities.aircraftSize',
      header: 'Size',
      cell: ({ row }) => {
        const stand = row.original;
        return <Badge variant="outline">{stand.capabilities.aircraftSize}</Badge>;
      },
    },
    {
      id: 'capabilities',
      header: 'Capabilities',
      cell: ({ row }) => {
        const stand = row.original;
        return (
          <div className="flex gap-2">
            {stand.capabilities.hasPowerSupply && (
              <Zap className="h-4 w-4 text-blue-600" aria-label="Power supply" />
            )}
            {stand.capabilities.hasGroundSupport && (
              <Wrench className="h-4 w-4 text-green-600" aria-label="Ground support" />
            )}
          </div>
        );
      },
    },
    {
      accessorKey: 'createdAt',
      header: ({ column }) => {
        return (
          <Button
            variant="ghost"
            onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
          >
            Created
          </Button>
        );
      },
      cell: ({ row }) => formatDate(row.getValue('createdAt')),
    },
    {
      id: 'actions',
      enableHiding: false,
      cell: ({ row }) => {
        const stand = row.original;
        return (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="h-8 w-8 p-0">
                <span className="sr-only">Open menu</span>
                <MoreHorizontal className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => onEdit(stand)}>
                <Pencil className="mr-2 h-4 w-4" />
                Edit
              </DropdownMenuItem>
              <DropdownMenuItem className="text-destructive">
                <Trash2 className="mr-2 h-4 w-4" />
                Delete
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        );
      },
    },
  ], [onEdit]);
  
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="text-center text-red-600 p-4">
        Error loading stands: {error.message}
      </div>
    );
  }
  
  return (
    <div className="bg-white rounded-lg shadow">
      {/* Table Header */}
      <div className="grid grid-cols-[50px_100px_1fr_100px_120px_80px_150px_150px_100px] gap-4 p-4 border-b font-medium text-sm text-gray-700">
        {columns.map((column) => (
          <div
            key={column.key}
            className={`flex items-center ${
              column.sortable ? 'cursor-pointer hover:text-gray-900' : ''
            }`}
            style={{ width: column.width }}
            onClick={() => column.sortable && onSort(column.key)}
          >
            {column.label}
            {column.sortable && sortBy === column.key && (
              <span className="ml-1">
                {sortOrder === 'asc' ? '↑' : '↓'}
              </span>
            )}
          </div>
        ))}
      </div>
      
      {/* Table Body with Virtual Scrolling */}
      <div
        ref={parentRef}
        className="h-[600px] overflow-auto"
      >
        <div
          style={{
            height: `${rowVirtualizer.getTotalSize()}px`,
            width: '100%',
            position: 'relative',
          }}
        >
          {rowVirtualizer.getVirtualItems().map((virtualRow) => {
            const stand = stands[virtualRow.index];
            return (
              <div
                key={virtualRow.key}
                className="grid grid-cols-[50px_100px_1fr_100px_120px_80px_150px_150px_100px] gap-4 p-4 border-b hover:bg-gray-50"
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '100%',
                  height: `${virtualRow.size}px`,
                  transform: `translateY(${virtualRow.start}px)`,
                }}
              >
                {columns.map((column) => (
                  <div key={column.key} style={{ width: column.width }}>
                    {column.render(stand)}
                  </div>
                ))}
              </div>
            );
          })}
        </div>
      </div>
      
      {/* Pagination */}
      {pagination && (
        <div className="flex justify-between items-center p-4 border-t">
          <div className="text-sm text-gray-600">
            Showing {(pagination.page - 1) * pagination.limit + 1}-
            {Math.min(pagination.page * pagination.limit, pagination.total)} of{' '}
            {pagination.total}
          </div>
          <div className="flex gap-1">
            <button
              className="px-3 py-1 border rounded disabled:opacity-50"
              disabled={pagination.page === 1}
              onClick={() => onPageChange(pagination.page - 1)}
            >
              Previous
            </button>
            {Array.from({ length: Math.min(5, pagination.totalPages) }, (_, i) => {
              const page = i + 1;
              return (
                <button
                  key={page}
                  className={`px-3 py-1 border rounded ${
                    page === pagination.page
                      ? 'bg-primary text-white'
                      : 'hover:bg-gray-100'
                  }`}
                  onClick={() => onPageChange(page)}
                >
                  {page}
                </button>
              );
            })}
            <button
              className="px-3 py-1 border rounded disabled:opacity-50"
              disabled={pagination.page === pagination.totalPages}
              onClick={() => onPageChange(pagination.page + 1)}
            >
              Next
            </button>
          </div>
        </div>
      )}
    </div>
  );
};
```

### 4. Stand Form with shadcn/ui Form Components

```tsx
import React from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Stand, CreateStandRequest, UpdateStandRequest } from '../api/stands.types';
import { useStandMutations } from '../hooks/useStandMutations';
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Switch } from '@/components/ui/switch';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Separator } from '@/components/ui/separator';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { AlertCircle } from 'lucide-react';

const standSchema = z.object({
  code: z.string().regex(/^[A-Z0-9]{1,10}$/, 'Code must be 1-10 alphanumeric characters'),
  name: z.string().min(1, 'Name is required').max(255),
  terminal: z.string().max(10).optional().nullable(),
  status: z.enum(['operational', 'maintenance', 'closed']),
  statusReason: z.string().max(500).optional(),
  capabilities: z.object({
    aircraftSize: z.enum(['A', 'B', 'C', 'D', 'E', 'F']),
    hasPowerSupply: z.boolean(),
    hasGroundSupport: z.boolean(),
    maxWeight: z.number().min(0).max(1000),
  }),
  latitude: z.number().min(-90).max(90).optional().nullable(),
  longitude: z.number().min(-180).max(180).optional().nullable(),
});

type StandFormData = z.infer<typeof standSchema>;

interface StandFormProps {
  stand?: Stand | null;
  onSave: () => void;
  onCancel: () => void;
}

export const StandForm: React.FC<StandFormProps> = ({ stand, onSave, onCancel }) => {
  const { create, update, isCreating, isUpdating } = useStandMutations();
  const isLoading = isCreating || isUpdating;
  
  const {
    control,
    handleSubmit,
    watch,
    formState: { errors, isDirty },
  } = useForm<StandFormData>({
    resolver: zodResolver(standSchema),
    defaultValues: stand ? {
      code: stand.code,
      name: stand.name,
      terminal: stand.terminal,
      status: stand.status,
      capabilities: stand.capabilities,
      latitude: stand.latitude,
      longitude: stand.longitude,
    } : {
      code: '',
      name: '',
      terminal: null,
      status: 'operational',
      capabilities: {
        aircraftSize: 'C',
        hasPowerSupply: true,
        hasGroundSupport: true,
        maxWeight: 200,
      },
      latitude: null,
      longitude: null,
    },
  });
  
  const watchStatus = watch('status');
  const watchCoordinates = watch(['latitude', 'longitude']);
  const hasCoordinates = watchCoordinates[0] != null && watchCoordinates[1] != null;
  
  const onSubmit = async (data: StandFormData) => {
    try {
      if (stand) {
        await update({
          id: stand.id,
          data: {
            ...data,
            version: stand.version, // Include version for optimistic locking
          } as UpdateStandRequest,
        });
      } else {
        await create(data as CreateStandRequest);
      }
      onSave();
    } catch (error) {
      // Error handling is done in the mutation hook
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Basic Information */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium">Basic Information</h3>
        
        <div className="grid grid-cols-2 gap-4">
          <Controller
            control={control}
            name="code"
            render={({ field }) => (
              <Input
                {...field}
                label="Stand Code"
                error={errors.code?.message}
                disabled={!!stand} // Can't change code after creation
                placeholder="e.g., A1, B15"
              />
            )}
          />
          
          <Controller
            control={control}
            name="name"
            render={({ field }) => (
              <Input
                {...field}
                label="Stand Name"
                error={errors.name?.message}
                placeholder="e.g., Alpha 1"
              />
            )}
          />
        </div>
        
        <div className="grid grid-cols-2 gap-4">
          <Controller
            control={control}
            name="terminal"
            render={({ field }) => (
              <Input
                {...field}
                value={field.value || ''}
                label="Terminal"
                error={errors.terminal?.message}
                placeholder="e.g., T1"
              />
            )}
          />
          
          <Controller
            control={control}
            name="status"
            render={({ field }) => (
              <Select
                {...field}
                label="Status"
                error={errors.status?.message}
                options={[
                  { value: 'operational', label: 'Operational' },
                  { value: 'maintenance', label: 'Maintenance' },
                  { value: 'closed', label: 'Closed' },
                ]}
              />
            )}
          />
        </div>
        
        {stand && watchStatus !== stand.status && (
          <Controller
            control={control}
            name="statusReason"
            render={({ field }) => (
              <Input
                {...field}
                label="Reason for Status Change"
                error={errors.statusReason?.message}
                placeholder="Provide a reason for the status change"
                multiline
                rows={3}
              />
            )}
          />
        )}
      </div>
      
      {/* Capabilities */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium">Capabilities</h3>
        
        <div className="grid grid-cols-2 gap-4">
          <Controller
            control={control}
            name="capabilities.aircraftSize"
            render={({ field }) => (
              <Select
                {...field}
                label="Aircraft Size"
                error={errors.capabilities?.aircraftSize?.message}
                options={[
                  { value: 'A', label: 'A - Small Regional' },
                  { value: 'B', label: 'B - Regional' },
                  { value: 'C', label: 'C - Narrowbody' },
                  { value: 'D', label: 'D - Widebody' },
                  { value: 'E', label: 'E - Jumbo' },
                  { value: 'F', label: 'F - Super Jumbo' },
                ]}
              />
            )}
          />
          
          <Controller
            control={control}
            name="capabilities.maxWeight"
            render={({ field }) => (
              <Input
                {...field}
                type="number"
                label="Max Weight (tonnes)"
                error={errors.capabilities?.maxWeight?.message}
                min={0}
                max={1000}
              />
            )}
          />
        </div>
        
        <div className="grid grid-cols-2 gap-4">
          <Controller
            control={control}
            name="capabilities.hasPowerSupply"
            render={({ field }) => (
              <Toggle
                {...field}
                label="Power Supply Available"
              />
            )}
          />
          
          <Controller
            control={control}
            name="capabilities.hasGroundSupport"
            render={({ field }) => (
              <Toggle
                {...field}
                label="Ground Support Available"
              />
            )}
          />
        </div>
      </div>
      
      {/* Location */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium">Location (Optional)</h3>
        
        <div className="grid grid-cols-2 gap-4">
          <Controller
            control={control}
            name="latitude"
            render={({ field }) => (
              <Input
                {...field}
                type="number"
                label="Latitude"
                error={errors.latitude?.message}
                step="any"
                min={-90}
                max={90}
              />
            )}
          />
          
          <Controller
            control={control}
            name="longitude"
            render={({ field }) => (
              <Input
                {...field}
                type="number"
                label="Longitude"
                error={errors.longitude?.message}
                step="any"
                min={-180}
                max={180}
              />
            )}
          />
        </div>
        
        {hasCoordinates && (
          <div className="h-64 border rounded">
            <MapPicker
              latitude={watchCoordinates[0]!}
              longitude={watchCoordinates[1]!}
              onChange={(lat, lng) => {
                // Update form values
              }}
            />
          </div>
        )}
      </div>
      
      {/* Actions */}
      <div className="flex justify-end gap-2 pt-4 border-t">
        <Button
          type="button"
          variant="secondary"
          onClick={onCancel}
          disabled={isLoading}
        >
          Cancel
        </Button>
        <Button
          type="submit"
          variant="primary"
          disabled={isLoading || !isDirty}
          loading={isLoading}
        >
          {stand ? 'Update Stand' : 'Create Stand'}
        </Button>
      </div>
    </form>
  );
};
```

### 5. Real-time WebSocket Integration

```typescript
import { io, Socket } from 'socket.io-client';
import { EventEmitter } from 'events';

class WebSocketClient extends EventEmitter {
  private socket: Socket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  
  connect(url: string, token: string) {
    this.socket = io(url, {
      auth: { token },
      transports: ['websocket'],
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: this.reconnectDelay,
    });
    
    this.socket.on('connect', () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.emit('connected');
    });
    
    this.socket.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason);
      this.emit('disconnected', reason);
    });
    
    this.socket.on('error', (error) => {
      console.error('WebSocket error:', error);
      this.emit('error', error);
    });
    
    // Domain events
    this.socket.on('domain_event', (event: any) => {
      this.emit(event.type, event);
    });
  }
  
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
  
  subscribe(pattern: string, callback: (event: any) => void): string {
    const listenerId = `${pattern}_${Date.now()}`;
    
    if (pattern.includes('*')) {
      // Pattern matching for wildcards
      const regex = new RegExp(pattern.replace('*', '.*'));
      const handler = (event: any) => {
        if (regex.test(event.type)) {
          callback(event);
        }
      };
      this.on('domain_event', handler);
    } else {
      this.on(pattern, callback);
    }
    
    // Tell server we're interested in these events
    if (this.socket) {
      this.socket.emit('subscribe', { pattern });
    }
    
    return listenerId;
  }
  
  unsubscribe(listenerId: string) {
    // Implementation to remove specific listener
    this.removeAllListeners(listenerId);
  }
}

export const wsClient = new WebSocketClient();

// React hook for WebSocket
export const useWebSocket = () => {
  const [isConnected, setIsConnected] = React.useState(false);
  
  React.useEffect(() => {
    const handleConnect = () => setIsConnected(true);
    const handleDisconnect = () => setIsConnected(false);
    
    wsClient.on('connected', handleConnect);
    wsClient.on('disconnected', handleDisconnect);
    
    // Connect if not already connected
    if (!wsClient.socket) {
      const token = localStorage.getItem('authToken');
      if (token) {
        wsClient.connect(process.env.REACT_APP_WS_URL!, token);
      }
    }
    
    return () => {
      wsClient.off('connected', handleConnect);
      wsClient.off('disconnected', handleDisconnect);
    };
  }, []);
  
  return {
    isConnected,
    subscribe: wsClient.subscribe.bind(wsClient),
    unsubscribe: wsClient.unsubscribe.bind(wsClient),
  };
};
```

### 6. Testing Strategy

```typescript
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { StandList } from '../components/StandList';
import { standsApi } from '../api/stands.api';
import { mockStands } from './fixtures/stands';

jest.mock('../api/stands.api');

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });
  
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('StandList', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('should display stands list', async () => {
    (standsApi.list as jest.Mock).mockResolvedValue({
      stands: mockStands,
      pagination: {
        page: 1,
        limit: 50,
        total: 3,
        totalPages: 1,
      },
    });
    
    render(<StandList />, { wrapper: createWrapper() });
    
    await waitFor(() => {
      expect(screen.getByText('Aircraft Stands')).toBeInTheDocument();
      expect(screen.getByText('(3)')).toBeInTheDocument();
    });
    
    // Check if stands are displayed
    expect(screen.getByText('A1')).toBeInTheDocument();
    expect(screen.getByText('Alpha 1')).toBeInTheDocument();
    expect(screen.getByText('Operational')).toBeInTheDocument();
  });
  
  it('should filter stands by status', async () => {
    const user = userEvent.setup();
    
    render(<StandList />, { wrapper: createWrapper() });
    
    // Open status filter
    await user.click(screen.getByLabelText('Status filter'));
    await user.click(screen.getByText('Maintenance'));
    
    await waitFor(() => {
      expect(standsApi.list).toHaveBeenCalledWith(
        expect.objectContaining({ status: 'maintenance' }),
        expect.any(Object)
      );
    });
  });
  
  it('should open create modal', async () => {
    const user = userEvent.setup();
    
    render(<StandList />, { wrapper: createWrapper() });
    
    await user.click(screen.getByText('Add Stand'));
    
    expect(screen.getByText('Create New Stand')).toBeInTheDocument();
    expect(screen.getByLabelText('Stand Code')).toBeInTheDocument();
  });
  
  it('should handle real-time updates', async () => {
    const { rerender } = render(<StandList />, { wrapper: createWrapper() });
    
    // Simulate WebSocket event
    act(() => {
      wsClient.emit('stand.created', {
        type: 'stand.created',
        standId: 'new-stand',
        data: { after: { code: 'C1', name: 'Charlie 1' } },
      });
    });
    
    await waitFor(() => {
      expect(standsApi.list).toHaveBeenCalledTimes(2); // Initial + refetch
    });
  });
});
```

## shadcn/ui Setup and Configuration

### 1. Installation

```bash
# Initialize shadcn/ui (if not already done)
npx shadcn-ui@latest init

# Install required components
npx shadcn-ui@latest add button
npx shadcn-ui@latest add card
npx shadcn-ui@latest add dialog
npx shadcn-ui@latest add sheet
npx shadcn-ui@latest add form
npx shadcn-ui@latest add input
npx shadcn-ui@latest add select
npx shadcn-ui@latest add checkbox
npx shadcn-ui@latest add switch
npx shadcn-ui@latest add table
npx shadcn-ui@latest add badge
npx shadcn-ui@latest add separator
npx shadcn-ui@latest add dropdown-menu
npx shadcn-ui@latest add alert
npx shadcn-ui@latest add toast
npx shadcn-ui@latest add progress
npx shadcn-ui@latest add textarea
npx shadcn-ui@latest add scroll-area
```

### 2. Theme Configuration

```css
/* app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
  }
}
```

### 3. Utility Functions

```typescript
// lib/utils.ts
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
import { format } from 'date-fns';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatDate(date: string | Date) {
  return format(new Date(date), 'MMM d, yyyy');
}

export function formatDateTime(date: string | Date) {
  return format(new Date(date), 'MMM d, yyyy h:mm a');
}
```

### 4. Custom Badge Variants

```typescript
// components/ui/badge.tsx (extended)
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80',
        outline: 'text-foreground',
        success:
          'border-transparent bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200',
        warning:
          'border-transparent bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
```

### Deployment Configuration

#### 1. Environment Variables

```env
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/capacity_planner
DATABASE_POOL_MIN=2
DATABASE_POOL_MAX=10

# Redis
REDIS_URL=redis://localhost:6379
REDIS_CACHE_TTL=300
REDIS_CACHE_MAX_SIZE=1000

# S3/MinIO
S3_ENDPOINT=http://localhost:9000
S3_ACCESS_KEY=minioadmin
S3_SECRET_KEY=minioadmin
S3_BUCKET=stand-imports
S3_REGION=us-east-1

# Bull Queue
QUEUE_REDIS_URL=redis://localhost:6379/1
QUEUE_CONCURRENCY=5
QUEUE_MAX_RETRIES=3

# Monitoring
JAEGER_ENDPOINT=http://localhost:14268/api/traces
METRICS_PORT=9090
LOG_LEVEL=info

# Security
JWT_SECRET=your-secret-key
ENCRYPTION_KEY=your-encryption-key
RATE_LIMIT_WINDOW=60000
RATE_LIMIT_MAX_REQUESTS=100

# Frontend
REACT_APP_API_URL=http://localhost:3000/api
REACT_APP_WS_URL=ws://localhost:3000
REACT_APP_MAPBOX_TOKEN=your-mapbox-token
REACT_APP_ENVIRONMENT=development
REACT_APP_VERSION=$npm_package_version
```

#### 2. Frontend Build Configuration

```json
// packages/web/package.json
{
  "name": "@capacity-planner/web",
  "version": "1.0.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "jest",
    "test:e2e": "cypress run",
    "lint": "eslint src --ext .ts,.tsx",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "@tanstack/react-query": "^5.0.0",
    "@tanstack/react-table": "^8.10.0",
    "@tanstack/react-virtual": "^3.0.0",
    "react-hook-form": "^7.47.0",
    "@hookform/resolvers": "^3.3.0",
    "zod": "^3.22.0",
    "socket.io-client": "^4.5.0",
    "axios": "^1.6.0",
    "date-fns": "^2.30.0",
    "clsx": "^2.0.0",
    "tailwindcss": "^3.3.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@vitejs/plugin-react": "^4.0.0",
    "vite": "^5.0.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.0.0",
    "jest": "^29.0.0",
    "cypress": "^13.0.0"
  }
}
```

```typescript
// packages/web/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3001,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      },
      '/socket.io': {
        target: 'http://localhost:3000',
        ws: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'query-vendor': ['@tanstack/react-query', '@tanstack/react-table'],
          'form-vendor': ['react-hook-form', 'zod'],
        },
      },
    },
  },
});
```

#### 3. Docker Configuration

```dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
COPY packages/assets-module/package*.json ./packages/assets-module/
RUN npm ci --workspace=packages/assets-module

# Build
COPY packages/assets-module ./packages/assets-module
RUN npm run build --workspace=packages/assets-module

# Production image
FROM node:18-alpine

WORKDIR /app

# Install production dependencies
COPY package*.json ./
COPY packages/assets-module/package*.json ./packages/assets-module/
RUN npm ci --production --workspace=packages/assets-module

# Copy built application
COPY --from=builder /app/packages/assets-module/dist ./packages/assets-module/dist
COPY packages/assets-module/prisma ./packages/assets-module/prisma

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

EXPOSE 3000 9090

CMD ["node", "packages/assets-module/dist/index.js"]
```

#### 3. Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: assets-module
  namespace: capacity-planner
spec:
  replicas: 3
  selector:
    matchLabels:
      app: assets-module
  template:
    metadata:
      labels:
        app: assets-module
    spec:
      containers:
      - name: assets-module
        image: capacity-planner/assets-module:1.0.0
        ports:
        - containerPort: 3000
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: assets-module
  namespace: capacity-planner
spec:
  selector:
    app: assets-module
  ports:
  - name: http
    port: 80
    targetPort: 3000
  - name: metrics
    port: 9090
    targetPort: 9090
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: assets-module-hpa
  namespace: capacity-planner
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: assets-module
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## Migration Plan

### Phase 1: Database Setup (Day 1)
1. Run database migrations
2. Create indexes
3. Set up RLS policies
4. Verify security constraints

### Phase 2: Core Implementation (Days 2-3)
1. Implement repository layer
2. Build service layer with validation
3. Create REST API controllers
4. Add caching layer

### Phase 3: Bulk Import (Day 4)
1. Implement CSV parser
2. Build import queue processor
3. Add progress tracking
4. Test with large datasets

### Phase 4: Events & Integration (Day 5)
1. Implement event publishers
2. Set up event listeners
3. Integration with capacity module
4. End-to-end testing

### Phase 5: Frontend List View (Days 6-8)
1. Implement StandList component with virtual scrolling
2. Build filtering and sorting functionality
3. Add pagination controls
4. Integrate with React Query for caching
5. Connect WebSocket for real-time updates

### Phase 6: Frontend Forms & Import (Days 9-10)
1. Create StandForm component with validation
2. Build bulk import interface
3. Add progress tracking for imports
4. Implement optimistic updates
5. Error handling and recovery

### Phase 7: Testing & Integration (Day 11)
1. Unit tests for all components
2. Integration tests with API
3. E2E tests for critical flows
4. Performance testing
5. Accessibility testing

### Phase 8: Security & Monitoring (Day 12)
1. Add rate limiting
2. Implement audit logging
3. Set up metrics collection
4. Configure alerts
5. Security scan

### Phase 9: Deployment (Days 13-14)
1. Build optimization
2. CDN configuration
3. Environment setup
4. Progressive rollout
5. Monitoring verification

## Rollback Plan

### Immediate Rollback (< 1 hour)
1. Revert deployment
2. Restore database from backup
3. Clear cache
4. Notify stakeholders

### Gradual Rollback (> 1 hour)
1. Enable read-only mode
2. Export modified data
3. Revert schema changes
4. Migrate data back
5. Restore service

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| API Response Time (p95) | < 200ms | Prometheus |
| API Availability | > 99.9% | Uptime monitoring |
| Bulk Import Speed | > 1000 records/sec | Job metrics |
| Cache Hit Rate | > 80% | Redis metrics |
| Error Rate | < 0.1% | Application logs |
| Database Connection Pool | < 80% utilized | Database metrics |
| Frontend Initial Load | < 1 second | RUM metrics |
| Frontend TTI | < 2 seconds | Lighthouse |
| React Query Cache Hit | > 70% | Custom metrics |
| WebSocket Reconnect Time | < 5 seconds | Client metrics |

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Database lock during migration | Use online schema changes |
| Memory leak in bulk import | Stream processing, batch limits |
| Cache stampede | Cache warming, jittered TTLs |
| API abuse | Rate limiting, API keys |
| Data corruption | Validation, transactions, backups |
| Large dataset rendering | Virtual scrolling, pagination |
| WebSocket connection loss | Automatic reconnection, offline queue |
| Bundle size bloat | Code splitting, lazy loading |

## Frontend Performance Optimizations

### 1. Bundle Optimization

```typescript
// Lazy loading for modals and heavy components
const StandForm = lazy(() => import('./components/StandForm'));
const StandImport = lazy(() => import('./components/StandImport'));
const MapPicker = lazy(() => import('@/shared/components/MapPicker'));

// Route-based code splitting
const StandsPage = lazy(() => import('./pages/StandsPage'));
```

### 2. Data Fetching Optimization

```typescript
// Prefetching on hover
const prefetchStand = (standId: string) => {
  queryClient.prefetchQuery({
    queryKey: [STANDS_QUERY_KEY, standId],
    queryFn: () => standsApi.get(standId),
    staleTime: 10 * 60 * 1000, // 10 minutes
  });
};

// Infinite scroll for large lists
export const useInfiniteStands = (filters: StandFilters) => {
  return useInfiniteQuery({
    queryKey: [STANDS_QUERY_KEY, 'infinite', filters],
    queryFn: ({ pageParam = 1 }) => 
      standsApi.list(filters, { page: pageParam, limit: 50 }),
    getNextPageParam: (lastPage) => 
      lastPage.pagination.page < lastPage.pagination.totalPages
        ? lastPage.pagination.page + 1
        : undefined,
  });
};
```

### 3. Rendering Optimization

```typescript
// Memoized components
export const StandRow = memo(({ stand, onEdit }: StandRowProps) => {
  return (
    <div className="grid grid-cols-9 gap-4 p-4">
      {/* Row content */}
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison for better performance
  return (
    prevProps.stand.id === nextProps.stand.id &&
    prevProps.stand.version === nextProps.stand.version
  );
});

// Debounced search
const debouncedSearch = useMemo(
  () => debounce((value: string) => {
    setFilters(prev => ({ ...prev, search: value }));
  }, 300),
  []
);
```

### 4. Image Optimization

```typescript
// Lazy loading images with intersection observer
const ImageWithLazyLoad: React.FC<{ src: string; alt: string }> = ({ src, alt }) => {
  const [isIntersecting, setIsIntersecting] = useState(false);
  const imgRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsIntersecting(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div ref={imgRef}>
      {isIntersecting ? (
        <img src={src} alt={alt} loading="lazy" />
      ) : (
        <div className="bg-gray-200 animate-pulse" />
      )}
    </div>
  );
};
```

### 5. State Management Optimization

```typescript
// Use valtio for fine-grained reactivity
import { proxy, useSnapshot } from 'valtio';

const filterState = proxy({
  search: '',
  status: undefined,
  terminal: undefined,
  aircraftSize: undefined,
});

// Component only re-renders when used properties change
export const useFilterState = () => {
  const snap = useSnapshot(filterState);
  return snap;
};
```

## Documentation

### API Documentation
- OpenAPI specification (automated)
- Postman collection
- Integration examples
- Error code reference

### Developer Documentation
- Architecture diagrams
- Code examples
- Testing guide
- Troubleshooting guide

### Operations Documentation
- Deployment procedures
- Monitoring setup
- Alert runbooks
- Backup procedures