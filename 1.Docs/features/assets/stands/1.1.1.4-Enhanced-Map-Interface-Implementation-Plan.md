# Implementation Plan: Enhanced Map Interface with Timeline

**Feature**: Interactive Map with Tooltips, Side Panel, and Timeline Controller  
**Version**: 1.1.1.4  
**Date**: January 2025  
**Owner**: Engineering Team  
**Status**: Ready for Implementation  
**PRD Reference**: 1.1.1.4-Enhanced-Map-Interface-PRD.md  
**TDD Reference**: 1.1.1.4-Enhanced-Map-Interface-TDD.md  
**Prerequisite**: Basic Map Interface (1.1.1.3) - **COMPLETED**

## Executive Summary

This implementation plan outlines the delivery of an enhanced interactive map interface that builds upon the existing basic map functionality (1.1.1.3) to provide rich contextual information through tooltips, detailed side panels, and a timeline controller for visualizing stand status changes over time. This feature will transform the stands management system into a comprehensive operational awareness tool.

## Current State Analysis

### âœ… Completed Foundation (1.1.1.3)
- **Basic Map Interface**: `StandMapInterface.tsx` with Leaflet integration
- **Map Optimization**: Clustering and performance optimizations
- **Responsive Design**: Mobile-friendly with fullscreen capability
- **Accessibility**: ARIA labels and keyboard navigation
- **API Integration**: Map data endpoint and caching

### ðŸ”„ Existing Database Schema
- **Stand Status History**: `StandStatusHistory` table exists but needs enhancement
- **Maintenance Records**: `StandMaintenanceRecord` table with scheduling support
- **Audit Events**: `AuditEvent` table for comprehensive logging
- **Adjacency Data**: `StandAdjacency` table for relationship mapping

### ðŸ“Š Current API Endpoints
- **Basic Stands**: `/api/stands` and `/api/assets/stands`
- **Stand Details**: `/api/stands/:id` with capabilities
- **Maintenance**: `/api/stands/:id/maintenance`
- **Statistics**: `/api/stands/stats`

## Implementation Strategy

### Phase-Based Approach (8 Weeks Total)

**Phase 1** (Weeks 1-2): **Foundation Enhancement & Timeline Data**
- Database schema enhancements
- Timeline API endpoints
- Basic timeline data structure

**Phase 2** (Weeks 3-4): **Interactive Components**
- Tooltip system implementation
- Side panel architecture
- Real-time data integration

**Phase 3** (Weeks 5-6): **Timeline Controller**
- Timeline visualization with D3.js
- Playback controls and scrubbing
- Animation system

**Phase 4** (Weeks 7-8): **Polish & Deployment**
- Performance optimization
- Comprehensive testing
- Documentation and deployment

## Phase 1: Foundation Enhancement & Timeline Data (Weeks 1-2)

### Week 1: Database Schema Enhancements

#### 1.1 Enhanced Status History Table
```sql
-- Enhance existing StandStatusHistory table
ALTER TABLE assets.stand_status_history 
ADD COLUMN IF NOT EXISTS organization_id UUID NOT NULL,
ADD COLUMN IF NOT EXISTS previous_status VARCHAR(50),
ADD COLUMN IF NOT EXISTS system_generated BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}',
ADD COLUMN IF NOT EXISTS changed_by_user UUID REFERENCES shared.users(id);

-- Add foreign key constraints
ALTER TABLE assets.stand_status_history 
ADD CONSTRAINT fk_stand_status_history_organization 
FOREIGN KEY (organization_id) REFERENCES shared.organizations(id);

-- Add performance indexes
CREATE INDEX idx_stand_status_history_timeline 
ON assets.stand_status_history (stand_id, changed_at DESC);

CREATE INDEX idx_stand_status_history_date_range 
ON assets.stand_status_history (organization_id, changed_at);
```

#### 1.2 Maintenance Records Enhancement
```sql
-- Add timeline-specific fields to maintenance records
ALTER TABLE assets.stand_maintenance_records 
ADD COLUMN IF NOT EXISTS timeline_color VARCHAR(7) DEFAULT '#f59e0b',
ADD COLUMN IF NOT EXISTS priority INTEGER DEFAULT 1,
ADD COLUMN IF NOT EXISTS estimated_duration_hours INTEGER,
ADD COLUMN IF NOT EXISTS actual_duration_hours INTEGER;

-- Add timeline index
CREATE INDEX idx_maintenance_timeline 
ON assets.stand_maintenance_records (stand_id, scheduled_start, scheduled_end);
```

### Week 2: Timeline API Endpoints

#### 2.1 Core Timeline Data Endpoint
**File**: `simple-db-api.js` (enhancement)
```javascript
// GET /api/stands/:standId/timeline
app.get('/api/stands/:standId/timeline', async (req, res) => {
  try {
    const { standId } = req.params;
    const { start, end, granularity = 'hour' } = req.query;
    const organizationId = req.headers['x-organization-id'];

    // Validate inputs
    const startDate = new Date(start);
    const endDate = new Date(end);
    
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ error: 'Invalid date range' });
    }

    // Get status history
    const statusHistory = await prisma.standStatusHistory.findMany({
      where: {
        standId,
        organizationId,
        changedAt: { gte: startDate, lte: endDate }
      },
      orderBy: { changedAt: 'asc' },
      include: {
        changedByUser: { select: { name: true, email: true } }
      }
    });

    // Get maintenance records
    const maintenanceRecords = await prisma.standMaintenanceRecord.findMany({
      where: {
        standId,
        organizationId,
        OR: [
          { scheduledStart: { gte: startDate, lte: endDate } },
          { scheduledEnd: { gte: startDate, lte: endDate } }
        ]
      },
      orderBy: { scheduledStart: 'asc' }
    });

    // Generate timeline data
    const timelineData = generateTimelineData(
      statusHistory, 
      maintenanceRecords, 
      startDate, 
      endDate, 
      granularity
    );

    res.json({
      standId,
      dateRange: { start: startDate, end: endDate },
      granularity,
      statusHistory,
      maintenanceRecords,
      timelineData
    });
  } catch (error) {
    console.error('Timeline API error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

#### 2.2 Bulk Timeline Endpoint
```javascript
// GET /api/stands/timeline
app.get('/api/stands/timeline', async (req, res) => {
  try {
    const { start, end, standIds } = req.query;
    const organizationId = req.headers['x-organization-id'];
    
    const standIdArray = standIds ? standIds.split(',') : [];
    
    // Get all stands if no specific IDs provided
    const targetStands = standIdArray.length > 0 ? 
      standIdArray : 
      await prisma.stand.findMany({
        where: { organizationId, isDeleted: false },
        select: { id: true }
      }).then(stands => stands.map(s => s.id));

    // Get timeline data for all stands
    const timelinePromises = targetStands.map(standId => 
      getTimelineData(standId, start, end, organizationId)
    );

    const timelineResults = await Promise.all(timelinePromises);
    
    res.json({
      dateRange: { start, end },
      stands: timelineResults.reduce((acc, result) => {
        acc[result.standId] = result;
        return acc;
      }, {})
    });
  } catch (error) {
    console.error('Bulk timeline API error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

#### 2.3 Stand Details Endpoint Enhancement
```javascript
// GET /api/stands/:standId/details
app.get('/api/stands/:standId/details', async (req, res) => {
  try {
    const { standId } = req.params;
    const organizationId = req.headers['x-organization-id'];

    const stand = await prisma.stand.findFirst({
      where: { id: standId, organizationId, isDeleted: false },
      include: {
        maintenanceRecords: {
          orderBy: { scheduledStart: 'desc' },
          take: 10
        },
        adjacentStands: {
          include: {
            adjacentStand: {
              select: { id: true, code: true, name: true }
            }
          }
        },
        capabilitySnapshots: {
          orderBy: { createdAt: 'desc' },
          take: 5
        }
      }
    });

    if (!stand) {
      return res.status(404).json({ error: 'Stand not found' });
    }

    res.json(stand);
  } catch (error) {
    console.error('Stand details API error:', error);
    res.status(500).json({ error: error.message });
  }
});
```

## Phase 2: Interactive Components (Weeks 3-4)

### Week 3: Tooltip System Implementation

#### 3.1 Enhanced Map Interface Component
**File**: `apps/web/src/features/stands/components/EnhancedStandMapInterface.tsx`
```typescript
'use client';

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { MapContainer, TileLayer, Marker } from 'react-leaflet';
import { motion, AnimatePresence } from 'framer-motion';
import { format, subDays } from 'date-fns';
import { useTimelineStore } from '../stores/timelineStore';
import { StandSidePanel } from './StandSidePanel';
import { TimelineController } from './TimelineController';
import { MapTooltip } from './MapTooltip';

interface EnhancedStandMapInterfaceProps {
  stands: StandMapData[];
  selectedStandId?: string;
  onStandSelect: (standId: string) => void;
  filters: StandFilters;
}

export const EnhancedStandMapInterface: React.FC<EnhancedStandMapInterfaceProps> = ({
  stands,
  selectedStandId,
  onStandSelect,
  filters
}) => {
  const [map, setMap] = useState<L.Map | null>(null);
  const [sidePanelOpen, setSidePanelOpen] = useState(false);
  const [hoveredStandId, setHoveredStandId] = useState<string | null>(null);
  const [tooltipPosition, setTooltipPosition] = useState<{ x: number; y: number } | null>(null);

  // Timeline state from Zustand store
  const {
    currentDate,
    isPlaying,
    playbackSpeed,
    dateRange,
    timelineData,
    setCurrentDate,
    setIsPlaying,
    setPlaybackSpeed,
    setDateRange,
    loadTimelineData
  } = useTimelineStore();

  // Initialize timeline with default date range (last 30 days)
  useEffect(() => {
    const endDate = new Date();
    const startDate = subDays(endDate, 30);
    setDateRange(startDate, endDate);
    setCurrentDate(endDate);
  }, []);

  // Load timeline data when date range changes
  useEffect(() => {
    if (dateRange.start && dateRange.end) {
      loadTimelineData(stands.map(s => s.id), dateRange.start, dateRange.end);
    }
  }, [dateRange, stands]);

  // Get current status for each stand based on timeline position
  const standsWithTimelineStatus = useMemo(() => {
    return stands.map(stand => {
      const standTimeline = timelineData[stand.id];
      if (!standTimeline || !currentDate) {
        return stand;
      }

      // Find the status at the current timeline position
      const timelinePoint = standTimeline.find(point => 
        point.timestamp <= currentDate
      );

      return {
        ...stand,
        status: timelinePoint?.status || stand.status,
        timelineEvents: timelinePoint?.events || []
      };
    });
  }, [stands, timelineData, currentDate]);

  // Handle marker interactions
  const handleMarkerClick = useCallback((standId: string) => {
    onStandSelect(standId);
    setSidePanelOpen(true);
  }, [onStandSelect]);

  const handleMarkerHover = useCallback((standId: string, event: L.LeafletMouseEvent) => {
    setHoveredStandId(standId);
    setTooltipPosition({
      x: event.containerPoint.x,
      y: event.containerPoint.y
    });
  }, []);

  const handleMarkerHoverEnd = useCallback(() => {
    setHoveredStandId(null);
    setTooltipPosition(null);
  }, []);

  // Create enhanced markers with timeline status
  const createEnhancedMarkerIcon = (stand: StandWithTimelineStatus, isSelected: boolean) => {
    const colors = {
      operational: '#10b981',
      maintenance: '#f59e0b',
      closed: '#ef4444'
    };

    const size = isSelected ? 36 : 28;
    const color = colors[stand.status as keyof typeof colors] || '#6b7280';
    const hasEvents = stand.timelineEvents && stand.timelineEvents.length > 0;

    return divIcon({
      html: `
        <div style="
          width: ${size}px;
          height: ${size}px;
          background-color: ${color};
          border: 3px solid white;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: 0 4px 8px rgba(0,0,0,0.2);
          transition: all 0.3s ease;
          ${isSelected ? 'box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5);' : ''}
          ${hasEvents ? 'animation: pulse 2s infinite;' : ''}
        ">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="white">
            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
          </svg>
        </div>
      `,
      className: 'enhanced-marker',
      iconSize: [size, size],
      iconAnchor: [size / 2, size]
    });
  };

  return (
    <div className="space-y-4">
      {/* Timeline Controller */}
      <TimelineController
        currentDate={currentDate}
        dateRange={dateRange}
        isPlaying={isPlaying}
        playbackSpeed={playbackSpeed}
        onDateChange={setCurrentDate}
        onPlayToggle={() => setIsPlaying(!isPlaying)}
        onSpeedChange={setPlaybackSpeed}
        onDateRangeChange={setDateRange}
        timelineData={timelineData}
      />

      {/* Enhanced Map */}
      <div className="relative bg-white rounded-lg shadow-sm border">
        <div className="flex items-center justify-between p-4 border-b">
          <div className="flex items-center space-x-2">
            <MapPin className="w-5 h-5 text-blue-600" />
            <h3 className="text-lg font-semibold">Stand Locations</h3>
            <span className="text-sm text-gray-500">
              ({standsWithTimelineStatus.length} stands)
            </span>
            {currentDate && (
              <span className="text-sm text-blue-600 font-medium">
                {format(currentDate, 'MMM dd, yyyy HH:mm')}
              </span>
            )}
          </div>
        </div>

        <div className="h-96 relative">
          <MapContainer
            center={[53.3498, -2.2744]} // Manchester Airport
            zoom={14}
            className="h-full w-full"
            ref={setMap}
          >
            <TileLayer
              attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
              url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            />
            
            <AnimatePresence>
              {standsWithTimelineStatus.map(stand => (
                <Marker
                  key={stand.id}
                  position={[stand.latitude, stand.longitude]}
                  icon={createEnhancedMarkerIcon(stand, stand.id === selectedStandId)}
                  eventHandlers={{
                    click: () => handleMarkerClick(stand.id),
                    mouseover: (e) => handleMarkerHover(stand.id, e),
                    mouseout: handleMarkerHoverEnd
                  }}
                />
              ))}
            </AnimatePresence>
          </MapContainer>

          {/* Tooltip */}
          <AnimatePresence>
            {hoveredStandId && tooltipPosition && (
              <MapTooltip
                stand={standsWithTimelineStatus.find(s => s.id === hoveredStandId)!}
                position={tooltipPosition}
                currentDate={currentDate}
              />
            )}
          </AnimatePresence>
        </div>
      </div>

      {/* Side Panel */}
      <AnimatePresence>
        {sidePanelOpen && selectedStandId && (
          <StandSidePanel
            standId={selectedStandId}
            onClose={() => setSidePanelOpen(false)}
            currentDate={currentDate}
          />
        )}
      </AnimatePresence>
    </div>
  );
};
```

#### 3.2 Map Tooltip Component
**File**: `apps/web/src/features/stands/components/MapTooltip.tsx`
```typescript
import React from 'react';
import { motion } from 'framer-motion';
import { format } from 'date-fns';
import { MapPin, Clock, Wrench, AlertTriangle } from 'lucide-react';

interface MapTooltipProps {
  stand: StandWithTimelineStatus;
  position: { x: number; y: number };
  currentDate: Date;
}

export const MapTooltip: React.FC<MapTooltipProps> = ({
  stand,
  position,
  currentDate
}) => {
  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'maintenance':
        return <Wrench className="w-4 h-4 text-yellow-600" />;
      case 'closed':
        return <AlertTriangle className="w-4 h-4 text-red-600" />;
      default:
        return <MapPin className="w-4 h-4 text-green-600" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'operational':
        return 'bg-green-100 text-green-800 border-green-200';
      case 'maintenance':
        return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'closed':
        return 'bg-red-100 text-red-800 border-red-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{ duration: 0.2 }}
      className="absolute z-50 pointer-events-none"
      style={{
        left: position.x + 10,
        top: position.y - 10,
        transform: 'translateY(-100%)'
      }}
    >
      <div className="bg-white rounded-lg shadow-lg border border-gray-200 p-3 max-w-xs">
        <div className="flex items-center justify-between mb-2">
          <div className="flex items-center space-x-2">
            <h4 className="font-semibold text-gray-900">{stand.code}</h4>
            {getStatusIcon(stand.status)}
          </div>
          <span className={`px-2 py-1 rounded-full text-xs font-medium border ${getStatusColor(stand.status)}`}>
            {stand.status}
          </span>
        </div>
        
        <p className="text-sm text-gray-600 mb-2">{stand.name}</p>
        
        <div className="space-y-1 text-xs text-gray-500">
          <div className="flex items-center justify-between">
            <span>Terminal:</span>
            <span className="font-medium">{stand.terminal_code}</span>
          </div>
          <div className="flex items-center justify-between">
            <span>Aircraft Size:</span>
            <span className="font-medium">{stand.aircraft_size_category}</span>
          </div>
          <div className="flex items-center justify-between">
            <span>Max Weight:</span>
            <span className="font-medium">{stand.max_weight_kg.toLocaleString()} kg</span>
          </div>
        </div>

        {/* Timeline events */}
        {stand.timelineEvents && stand.timelineEvents.length > 0 && (
          <div className="mt-2 pt-2 border-t border-gray-200">
            <div className="flex items-center space-x-1 text-xs text-gray-500 mb-1">
              <Clock className="w-3 h-3" />
              <span>Recent Events:</span>
            </div>
            <div className="space-y-1">
              {stand.timelineEvents.slice(0, 2).map((event, index) => (
                <div key={index} className="text-xs text-gray-600">
                  <span className="font-medium">
                    {event.type === 'status_change' ? 'Status Change' : 
                     event.type === 'maintenance_start' ? 'Maintenance Started' :
                     'Maintenance Ended'}
                  </span>
                  {event.reason && (
                    <span className="text-gray-500"> - {event.reason}</span>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}

        <div className="mt-2 pt-2 border-t border-gray-200 text-xs text-gray-500">
          <div className="flex items-center space-x-1">
            <Clock className="w-3 h-3" />
            <span>Timeline: {format(currentDate, 'MMM dd, HH:mm')}</span>
          </div>
        </div>
      </div>
    </motion.div>
  );
};
```

### Week 4: Side Panel Architecture

#### 4.1 Side Panel Component
**File**: `apps/web/src/features/stands/components/StandSidePanel.tsx`
```typescript
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { X, MapPin, Settings, History, Network, Edit, FileText, Download } from 'lucide-react';
import { format } from 'date-fns';

interface StandSidePanelProps {
  standId: string;
  onClose: () => void;
  currentDate: Date;
}

export const StandSidePanel: React.FC<StandSidePanelProps> = ({
  standId,
  onClose,
  currentDate
}) => {
  const [activeTab, setActiveTab] = useState<'overview' | 'maintenance' | 'history' | 'adjacency'>('overview');
  const [standDetails, setStandDetails] = useState<StandDetails | null>(null);
  const [loading, setLoading] = useState(true);

  // Load stand details
  useEffect(() => {
    const loadStandDetails = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/stands/${standId}/details`);
        const data = await response.json();
        setStandDetails(data);
      } catch (error) {
        console.error('Failed to load stand details:', error);
      } finally {
        setLoading(false);
      }
    };

    loadStandDetails();
  }, [standId]);

  const tabs = [
    { id: 'overview', label: 'Overview', icon: MapPin },
    { id: 'maintenance', label: 'Maintenance', icon: Settings },
    { id: 'history', label: 'History', icon: History },
    { id: 'adjacency', label: 'Adjacency', icon: Network }
  ];

  if (loading) {
    return (
      <motion.div
        initial={{ x: 400, opacity: 0 }}
        animate={{ x: 0, opacity: 1 }}
        exit={{ x: 400, opacity: 0 }}
        className="fixed right-0 top-0 h-full w-96 bg-white shadow-xl border-l border-gray-200 z-50"
      >
        <div className="p-6 flex items-center justify-center h-full">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      </motion.div>
    );
  }

  if (!standDetails) {
    return null;
  }

  return (
    <motion.div
      initial={{ x: 400, opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      exit={{ x: 400, opacity: 0 }}
      className="fixed right-0 top-0 h-full w-96 bg-white shadow-xl border-l border-gray-200 z-50 overflow-hidden"
    >
      {/* Header */}
      <div className="p-4 border-b border-gray-200 bg-gray-50">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className={`w-4 h-4 rounded-full ${
              standDetails.status === 'operational' ? 'bg-green-500' :
              standDetails.status === 'maintenance' ? 'bg-yellow-500' :
              'bg-red-500'
            }`}></div>
            <div>
              <h2 className="text-lg font-semibold text-gray-900">{standDetails.code}</h2>
              <p className="text-sm text-gray-600">{standDetails.name}</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-md"
          >
            <X className="w-5 h-5" />
          </button>
        </div>
        
        <div className="mt-3 flex items-center space-x-2">
          <span className={`px-2 py-1 rounded-full text-xs font-medium ${
            standDetails.status === 'operational' ? 'bg-green-100 text-green-800' :
            standDetails.status === 'maintenance' ? 'bg-yellow-100 text-yellow-800' :
            'bg-red-100 text-red-800'
          }`}>
            {standDetails.status}
          </span>
          <span className="text-xs text-gray-500">
            as of {format(currentDate, 'MMM dd, HH:mm')}
          </span>
        </div>
      </div>

      {/* Tabs */}
      <div className="border-b border-gray-200">
        <nav className="flex">
          {tabs.map(tab => {
            const Icon = tab.icon;
            return (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id as any)}
                className={`flex items-center space-x-2 px-4 py-3 text-sm font-medium border-b-2 transition-colors ${
                  activeTab === tab.id
                    ? 'border-blue-500 text-blue-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700'
                }`}
              >
                <Icon className="w-4 h-4" />
                <span>{tab.label}</span>
              </button>
            );
          })}
        </nav>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        {activeTab === 'overview' && (
          <OverviewTab standDetails={standDetails} />
        )}
        {activeTab === 'maintenance' && (
          <MaintenanceTab standId={standId} currentDate={currentDate} />
        )}
        {activeTab === 'history' && (
          <HistoryTab standId={standId} currentDate={currentDate} />
        )}
        {activeTab === 'adjacency' && (
          <AdjacencyTab standId={standId} />
        )}
      </div>

      {/* Actions */}
      <div className="p-4 border-t border-gray-200 bg-gray-50">
        <div className="flex space-x-2">
          <button className="flex items-center space-x-2 px-3 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700">
            <Edit className="w-4 h-4" />
            <span>Edit</span>
          </button>
          <button className="flex items-center space-x-2 px-3 py-2 text-sm bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">
            <FileText className="w-4 h-4" />
            <span>Maintenance</span>
          </button>
          <button className="flex items-center space-x-2 px-3 py-2 text-sm bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">
            <Download className="w-4 h-4" />
            <span>Export</span>
          </button>
        </div>
      </div>
    </motion.div>
  );
};
```

## Phase 3: Timeline Controller (Weeks 5-6)

### Week 5: Timeline Visualization with D3.js

#### 5.1 Timeline Controller Component
**File**: `apps/web/src/features/stands/components/TimelineController.tsx`
```typescript
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { Play, Pause, SkipBack, SkipForward, Calendar, Clock } from 'lucide-react';
import { format, addHours, subHours } from 'date-fns';
import * as d3 from 'd3';

interface TimelineControllerProps {
  currentDate: Date;
  dateRange: { start: Date; end: Date };
  isPlaying: boolean;
  playbackSpeed: number;
  onDateChange: (date: Date) => void;
  onPlayToggle: () => void;
  onSpeedChange: (speed: number) => void;
  onDateRangeChange: (start: Date, end: Date) => void;
  timelineData: Record<string, TimelineDataPoint[]>;
}

export const TimelineController: React.FC<TimelineControllerProps> = ({
  currentDate,
  dateRange,
  isPlaying,
  playbackSpeed,
  onDateChange,
  onPlayToggle,
  onSpeedChange,
  onDateRangeChange,
  timelineData
}) => {
  const timelineRef = useRef<SVGSVGElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);

  // Timeline dimensions
  const timelineWidth = 800;
  const timelineHeight = 60;
  const margin = { top: 10, right: 20, bottom: 30, left: 20 };

  // Create scales
  const xScale = d3.scaleTime()
    .domain([dateRange.start, dateRange.end])
    .range([margin.left, timelineWidth - margin.right]);

  const yScale = d3.scaleLinear()
    .domain([0, 1])
    .range([timelineHeight - margin.bottom, margin.top]);

  // Auto-play functionality
  useEffect(() => {
    if (!isPlaying) return;

    const interval = setInterval(() => {
      const nextDate = addHours(currentDate, playbackSpeed);
      if (nextDate <= dateRange.end) {
        onDateChange(nextDate);
      } else {
        onPlayToggle(); // Stop at end
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [isPlaying, currentDate, playbackSpeed, dateRange.end, onDateChange, onPlayToggle]);

  // Handle timeline drag
  const handleTimelineDrag = (event: React.MouseEvent<SVGSVGElement>) => {
    if (!isDragging) return;

    const rect = timelineRef.current?.getBoundingClientRect();
    if (!rect) return;

    const x = event.clientX - rect.left;
    const newDate = xScale.invert(x);

    // Clamp to date range
    const clampedDate = new Date(Math.max(
      dateRange.start.getTime(),
      Math.min(dateRange.end.getTime(), newDate.getTime())
    ));

    onDateChange(clampedDate);
  };

  // Get all events for timeline visualization
  const allEvents = Object.values(timelineData).flat().filter(point => 
    point.events && point.events.length > 0
  );

  // Speed options
  const speedOptions = [0.5, 1, 2, 4, 8];

  return (
    <div className="bg-white rounded-lg shadow-sm border p-4">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center space-x-2">
          <Clock className="w-5 h-5 text-blue-600" />
          <h3 className="text-lg font-semibold">Timeline Controller</h3>
        </div>
        
        <div className="flex items-center space-x-2">
          <button
            onClick={() => setShowDatePicker(!showDatePicker)}
            className="flex items-center space-x-1 px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-md"
          >
            <Calendar className="w-4 h-4" />
            <span>Date Range</span>
          </button>
        </div>
      </div>

      {/* Date Range Picker */}
      {showDatePicker && (
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -10 }}
          className="mb-4 p-3 bg-gray-50 rounded-lg"
        >
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Start Date
              </label>
              <input
                type="datetime-local"
                value={format(dateRange.start, "yyyy-MM-dd'T'HH:mm")}
                onChange={(e) => onDateRangeChange(new Date(e.target.value), dateRange.end)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                End Date
              </label>
              <input
                type="datetime-local"
                value={format(dateRange.end, "yyyy-MM-dd'T'HH:mm")}
                onChange={(e) => onDateRangeChange(dateRange.start, new Date(e.target.value))}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>
        </motion.div>
      )}

      {/* Timeline Visualization */}
      <div className="mb-4">
        <svg
          ref={timelineRef}
          width={timelineWidth}
          height={timelineHeight}
          className="border rounded cursor-pointer"
          onMouseDown={() => setIsDragging(true)}
          onMouseUp={() => setIsDragging(false)}
          onMouseLeave={() => setIsDragging(false)}
          onMouseMove={handleTimelineDrag}
        >
          {/* Timeline background */}
          <rect
            x={margin.left}
            y={margin.top}
            width={timelineWidth - margin.left - margin.right}
            height={timelineHeight - margin.top - margin.bottom}
            fill="#f8fafc"
            stroke="#e2e8f0"
          />

          {/* Event markers */}
          {allEvents.map((point, index) => (
            <circle
              key={index}
              cx={xScale(point.timestamp)}
              cy={yScale(0.5)}
              r={3}
              fill={point.events[0]?.type === 'maintenance_start' ? '#f59e0b' : '#10b981'}
              stroke="white"
              strokeWidth={1}
            />
          ))}

          {/* Current position indicator */}
          <line
            x1={xScale(currentDate)}
            y1={margin.top}
            x2={xScale(currentDate)}
            y2={timelineHeight - margin.bottom}
            stroke="#3b82f6"
            strokeWidth={2}
          />

          {/* Current position handle */}
          <circle
            cx={xScale(currentDate)}
            cy={yScale(0.5)}
            r={6}
            fill="#3b82f6"
            stroke="white"
            strokeWidth={2}
            className="cursor-grab active:cursor-grabbing"
          />

          {/* Time axis */}
          <g transform={`translate(0, ${timelineHeight - margin.bottom})`}>
            {xScale.ticks(5).map(tick => (
              <g key={tick.getTime()}>
                <line
                  x1={xScale(tick)}
                  y1={0}
                  x2={xScale(tick)}
                  y2={5}
                  stroke="#6b7280"
                />
                <text
                  x={xScale(tick)}
                  y={18}
                  textAnchor="middle"
                  fontSize="12"
                  fill="#6b7280"
                >
                  {format(tick, 'MMM dd')}
                </text>
              </g>
            ))}
          </g>
        </svg>
      </div>

      {/* Playback Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <button
            onClick={() => onDateChange(subHours(currentDate, 1))}
            className="p-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-md"
            disabled={currentDate <= dateRange.start}
          >
            <SkipBack className="w-4 h-4" />
          </button>
          
          <button
            onClick={onPlayToggle}
            className="p-2 text-white bg-blue-600 hover:bg-blue-700 rounded-md"
          >
            {isPlaying ? <Pause className="w-4 h-4" /> : <Play className="w-4 h-4" />}
          </button>
          
          <button
            onClick={() => onDateChange(addHours(currentDate, 1))}
            className="p-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-md"
            disabled={currentDate >= dateRange.end}
          >
            <SkipForward className="w-4 h-4" />
          </button>
        </div>

        <div className="flex items-center space-x-2">
          <span className="text-sm text-gray-600">Speed:</span>
          <select
            value={playbackSpeed}
            onChange={(e) => onSpeedChange(Number(e.target.value))}
            className="px-2 py-1 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            {speedOptions.map(speed => (
              <option key={speed} value={speed}>
                {speed}x
              </option>
            ))}
          </select>
        </div>

        <div className="text-sm text-gray-600">
          {format(currentDate, 'MMM dd, yyyy HH:mm')}
        </div>
      </div>
    </div>
  );
};
```

### Week 6: State Management & Animation System

#### 6.1 Timeline Store (Zustand)
**File**: `apps/web/src/features/stands/stores/timelineStore.ts`
```typescript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

interface TimelineState {
  currentDate: Date;
  dateRange: { start: Date; end: Date };
  isPlaying: boolean;
  playbackSpeed: number;
  timelineData: Record<string, TimelineDataPoint[]>;
  loading: boolean;
  error: string | null;
}

interface TimelineActions {
  setCurrentDate: (date: Date) => void;
  setDateRange: (start: Date, end: Date) => void;
  setIsPlaying: (playing: boolean) => void;
  setPlaybackSpeed: (speed: number) => void;
  loadTimelineData: (standIds: string[], start: Date, end: Date) => Promise<void>;
  clearTimelineData: () => void;
}

export const useTimelineStore = create<TimelineState & TimelineActions>()(
  devtools(
    (set, get) => ({
      // State
      currentDate: new Date(),
      dateRange: { start: new Date(), end: new Date() },
      isPlaying: false,
      playbackSpeed: 1,
      timelineData: {},
      loading: false,
      error: null,

      // Actions
      setCurrentDate: (date) => set({ currentDate: date }),
      
      setDateRange: (start, end) => set({ 
        dateRange: { start, end },
        currentDate: end // Set current date to end of range
      }),
      
      setIsPlaying: (playing) => set({ isPlaying: playing }),
      
      setPlaybackSpeed: (speed) => set({ playbackSpeed: speed }),
      
      loadTimelineData: async (standIds, start, end) => {
        set({ loading: true, error: null });
        
        try {
          const response = await fetch(
            `/api/stands/timeline?start=${start.toISOString()}&end=${end.toISOString()}&standIds=${standIds.join(',')}`
          );
          
          if (!response.ok) {
            throw new Error('Failed to load timeline data');
          }
          
          const data = await response.json();
          set({ timelineData: data.stands, loading: false });
        } catch (error) {
          set({ 
            error: error instanceof Error ? error.message : 'Unknown error',
            loading: false 
          });
        }
      },
      
      clearTimelineData: () => set({ timelineData: {}, error: null })
    }),
    {
      name: 'timeline-store'
    }
  )
);
```

#### 6.2 Package Dependencies Installation
```bash
# Install required packages
pnpm add leaflet react-leaflet @types/leaflet d3 @types/d3 framer-motion date-fns zustand socket.io-client @headlessui/react @heroicons/react

# Install development dependencies
pnpm add -D @testing-library/react @testing-library/jest-dom @playwright/test
```

## Phase 4: Polish & Deployment (Weeks 7-8)

### Week 7: Performance Optimization & Testing

#### 7.1 Performance Optimizations
- **Data Virtualization**: Implement timeline data chunking for large datasets
- **Marker Clustering**: Enhanced clustering for timeline-enabled markers
- **Memory Management**: Efficient cleanup of timeline data and animations
- **Caching Strategy**: Redis caching for timeline data
- **Real-time Updates**: WebSocket integration for live status changes

#### 7.2 Comprehensive Testing
- **Unit Tests**: Component testing with Jest and React Testing Library
- **Integration Tests**: API endpoint testing
- **E2E Tests**: Playwright tests for timeline interactions
- **Performance Tests**: Load testing for timeline data
- **Accessibility Tests**: Screen reader and keyboard navigation testing

### Week 8: Documentation & Deployment

#### 8.1 Documentation
- **API Documentation**: OpenAPI specs for timeline endpoints
- **Component Documentation**: Storybook stories for UI components
- **User Guide**: Interactive timeline usage guide
- **Performance Guide**: Optimization recommendations

#### 8.2 Deployment & Monitoring
- **Production Deployment**: Railway deployment with environment variables
- **Monitoring**: Performance metrics and error tracking
- **Analytics**: User interaction tracking for timeline features
- **Rollback Plan**: Graceful degradation strategies

## Success Criteria & Validation

### Functional Requirements âœ…
- [ ] Tooltips display comprehensive stand information on hover
- [ ] Side panel shows detailed stand information across all tabs
- [ ] Timeline controller accurately visualizes status changes over time
- [ ] All interactions meet specified performance requirements
- [ ] Real-time data synchronization maintains accuracy

### Performance Requirements âœ…
- [ ] Timeline data loads within 3 seconds for 30-day range
- [ ] Smooth 30fps animation during timeline scrubbing
- [ ] Tooltip appears within 300ms of hover
- [ ] Side panel opens within 500ms of marker click
- [ ] Memory usage remains efficient with 12+ months of data

### User Experience Requirements âœ…
- [ ] Intuitive interaction patterns require minimal learning
- [ ] Information hierarchy supports quick decision-making
- [ ] Timeline provides valuable operational insights
- [ ] Mobile experience maintains full functionality
- [ ] Accessibility standards (WCAG 2.1 AA) fully met

### Technical Requirements âœ…
- [ ] Efficient data loading and caching strategies
- [ ] Scalable architecture supports future enhancements
- [ ] Robust error handling and graceful degradation
- [ ] Comprehensive security and audit compliance
- [ ] Clean integration with existing codebase

## Risk Mitigation

### Technical Risks
- **Timeline Performance**: Implement data virtualization and progressive loading
- **Memory Usage**: Efficient data structures and cleanup strategies
- **Real-time Sync**: Conflict resolution and data validation
- **Browser Compatibility**: Comprehensive testing across target browsers

### User Experience Risks
- **Information Overload**: Progressive disclosure and smart defaults
- **Complex Timeline**: User testing and iterative design refinement
- **Mobile Limitations**: Mobile-first design approach and touch optimization

### Deployment Risks
- **Data Migration**: Careful schema migration with rollback procedures
- **Performance Impact**: Gradual rollout with monitoring
- **User Adoption**: Training materials and onboarding flows

## Monitoring & Success Metrics

### Key Performance Indicators
- **User Engagement**: 85% of users interact with tooltips within first session
- **Timeline Usage**: 60% of users explore historical data using timeline
- **Information Accessibility**: 100% of stand details accessible within 2 clicks
- **Performance**: Timeline scrubbing maintains 30fps smooth animation
- **Data Accuracy**: Real-time sync with maintenance and status data

### Monitoring Setup
- **Performance Monitoring**: Timeline interaction metrics and load times
- **Error Tracking**: Component error rates and API failures
- **User Analytics**: Feature usage patterns and adoption rates
- **Business Metrics**: Operational efficiency improvements

## Conclusion

This implementation plan provides a comprehensive roadmap for delivering the Enhanced Map Interface with Timeline feature. The phased approach ensures systematic development while building upon the existing foundation. The focus on performance, user experience, and technical excellence will result in a powerful operational awareness tool that significantly enhances the CapaCity Planner system.

The timeline functionality will provide unprecedented visibility into stand operations, enabling better decision-making and operational planning. The rich interactive components will transform how users interact with stand data, moving from static tables to dynamic, context-aware interfaces.

Success will be measured not just by technical completion, but by user adoption, operational efficiency improvements, and the foundation laid for future enhancements to the platform. 