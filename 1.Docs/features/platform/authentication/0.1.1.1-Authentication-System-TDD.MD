# TDD: Authentication & Identity Management System

**Feature**: Comprehensive Authentication & Identity Management  
**Version**: 0.1.1.1  
**Date**: January 2025  
**Owner**: Engineering Team  
**Status**: Ready for Implementation  
**PRD Reference**: 0.1.1.1-Authentication-System-PRD.MD

## Table of Contents

1. [Technical Overview](#technical-overview)
2. [Architecture Design](#architecture-design)
3. [Database Design](#database-design)
4. [API Design](#api-design)
5. [Security Implementation](#security-implementation)
6. [Frontend Implementation](#frontend-implementation)
7. [Middleware & Authorization](#middleware--authorization)
8. [Session Management](#session-management)
9. [Testing Strategy](#testing-strategy)
10. [Migration Plan](#migration-plan)
11. [Monitoring & Observability](#monitoring--observability)
12. [Deployment Strategy](#deployment-strategy)

## Technical Overview

### System Context

The Authentication & Identity Management system will be implemented as a foundational platform service that provides secure user authentication, session management, and role-based access control for all modules within the CapaCity Planner platform. This system will replace the current basic admin authentication with a comprehensive, production-ready solution.

### Key Technical Decisions

1. **Hybrid Authentication Strategy**: Combine session-based authentication for web UI with JWT tokens for API access
2. **Password Security**: Implement bcrypt hashing with configurable salt rounds and password policies
3. **Multi-Tenant Architecture**: Organization-scoped data isolation with secure tenant context
4. **Middleware-First Design**: Centralized authentication/authorization through Express middleware
5. **Event-Driven Audit**: Comprehensive audit logging with real-time security event monitoring

### Technology Stack

- **Frontend**: Next.js 14+ with TypeScript, React Hook Form, Zod validation
- **Backend**: Node.js 20+, Express 4.18+, PostgreSQL 14+
- **Authentication**: iron-session for web sessions, jsonwebtoken for API tokens
- **Password Security**: bcrypt with 12 salt rounds
- **Database**: PostgreSQL with enhanced user schema and audit tables
- **Caching**: Redis for session storage and permission caching
- **Monitoring**: OpenTelemetry with security event tracking

## Architecture Design

### Component Architecture

```mermaid
graph TB
    subgraph "Frontend Layer"
        A[Login UI] --> B[Session Context]
        B --> C[Protected Routes]
        C --> D[User Management UI]
    end
    
    subgraph "API Gateway"
        E[Authentication Middleware] --> F[Authorization Middleware]
        F --> G[Security Headers]
        G --> H[Rate Limiting]
    end
    
    subgraph "Authentication Service"
        I[Auth Controller] --> J[Password Service]
        I --> K[Session Service]
        I --> L[JWT Service]
        J --> M[bcrypt Handler]
        K --> N[Iron Session]
        L --> O[Token Validator]
    end
    
    subgraph "User Management Service"
        P[User Service] --> Q[Role Service]
        P --> R[Organization Service]
        Q --> S[Permission Engine]
    end
    
    subgraph "Data Layer"
        T[User Repository] --> U[(PostgreSQL)]
        V[Session Store] --> W[(Redis)]
        X[Audit Logger] --> Y[Audit Repository]
    end
    
    subgraph "Security Layer"
        Z[Security Monitor] --> AA[Event Publisher]
        AA --> BB[Alert System]
    end
    
    A --> E
    E --> I
    I --> P
    P --> T
    K --> V
    I --> X
    Z --> X
```

### Authentication Flow Architecture

```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant AuthAPI
    participant UserService
    participant Database
    participant AuditLog
    participant SessionStore

    User->>Frontend: Enter credentials
    Frontend->>AuthAPI: POST /auth/login
    AuthAPI->>UserService: Validate credentials
    UserService->>Database: Query user by email
    Database-->>UserService: User data
    UserService->>UserService: Verify password with bcrypt
    UserService-->>AuthAPI: Authentication result
    AuthAPI->>SessionStore: Create session
    AuthAPI->>AuditLog: Log login event
    AuthAPI-->>Frontend: Session cookie + JWT token
    Frontend->>Frontend: Store user context
    Frontend-->>User: Redirect to dashboard
```

### Multi-Tenant Security Architecture

```mermaid
graph TB
    subgraph "Organization A"
        A1[Users] --> A2[Roles]
        A2 --> A3[Permissions]
        A3 --> A4[Resources]
    end
    
    subgraph "Organization B"
        B1[Users] --> B2[Roles]
        B2 --> B3[Permissions]
        B3 --> B4[Resources]
    end
    
    subgraph "Security Context"
        C[Tenant Isolation] --> D[Row Level Security]
        D --> E[Permission Checks]
        E --> F[Audit Logging]
    end
    
    A4 --> C
    B4 --> C
```

## Database Design

### Enhanced User Schema

```sql
-- Enhanced Users table with security fields
CREATE TABLE public.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  email_verified BOOLEAN DEFAULT false,
  password_hash VARCHAR(255) NOT NULL,
  password_salt VARCHAR(255) NOT NULL,
  password_changed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  password_reset_token VARCHAR(255),
  password_reset_expires TIMESTAMP WITH TIME ZONE,
  
  -- User Information
  name VARCHAR(255) NOT NULL,
  first_name VARCHAR(100),
  last_name VARCHAR(100),
  phone VARCHAR(50),
  timezone VARCHAR(50) DEFAULT 'UTC',
  locale VARCHAR(10) DEFAULT 'en',
  
  -- Organization and Role
  organization_id UUID NOT NULL REFERENCES public.organizations(id),
  role VARCHAR(50) NOT NULL DEFAULT 'requester',
  permissions JSONB DEFAULT '[]',
  
  -- Account Status
  is_active BOOLEAN DEFAULT true,
  is_verified BOOLEAN DEFAULT false,
  is_locked BOOLEAN DEFAULT false,
  locked_until TIMESTAMP WITH TIME ZONE,
  
  -- Security Tracking
  failed_login_attempts INTEGER DEFAULT 0,
  last_login_at TIMESTAMP WITH TIME ZONE,
  last_login_ip INET,
  last_password_change TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  -- MFA Support
  mfa_enabled BOOLEAN DEFAULT false,
  mfa_secret VARCHAR(255),
  backup_codes JSONB DEFAULT '[]',
  
  -- Audit Fields
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID,
  updated_by UUID,
  
  -- Indexes
  CONSTRAINT users_email_organization_unique UNIQUE (email, organization_id),
  CONSTRAINT users_valid_role CHECK (role IN ('admin_support', 'client_admin', 'asset_owner', 'airport_planner', 'key_stakeholder', 'third_party_contractor', 'requester'))
);

-- Indexes for performance
CREATE INDEX idx_users_email ON public.users(email);
CREATE INDEX idx_users_organization_id ON public.users(organization_id);
CREATE INDEX idx_users_role ON public.users(role);
CREATE INDEX idx_users_is_active ON public.users(is_active);
CREATE INDEX idx_users_last_login ON public.users(last_login_at);
```

### Session Management Schema

```sql
-- Sessions table for server-side session storage
CREATE TABLE public.user_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  session_token VARCHAR(255) UNIQUE NOT NULL,
  
  -- Session Data
  session_data JSONB NOT NULL,
  user_agent TEXT,
  ip_address INET,
  
  -- Expiration
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  -- Security
  is_active BOOLEAN DEFAULT true,
  revoked_at TIMESTAMP WITH TIME ZONE,
  revoked_reason VARCHAR(255)
);

-- Indexes for session management
CREATE INDEX idx_sessions_user_id ON public.user_sessions(user_id);
CREATE INDEX idx_sessions_token ON public.user_sessions(session_token);
CREATE INDEX idx_sessions_expires ON public.user_sessions(expires_at);
CREATE INDEX idx_sessions_active ON public.user_sessions(is_active);
```

### Role-Based Access Control Schema

```sql
-- Roles table
CREATE TABLE public.roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(50) UNIQUE NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  description TEXT,
  permissions JSONB DEFAULT '[]',
  is_system_role BOOLEAN DEFAULT false,
  organization_id UUID REFERENCES public.organizations(id),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID,
  updated_by UUID
);

-- Permissions table
CREATE TABLE public.permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) UNIQUE NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  description TEXT,
  resource VARCHAR(50) NOT NULL,
  action VARCHAR(50) NOT NULL,
  module VARCHAR(50) NOT NULL,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  CONSTRAINT permissions_resource_action_unique UNIQUE (resource, action, module)
);

-- User-Role assignments
CREATE TABLE public.user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  role_id UUID NOT NULL REFERENCES public.roles(id) ON DELETE CASCADE,
  assigned_by UUID REFERENCES public.users(id),
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE,
  
  CONSTRAINT user_roles_unique UNIQUE (user_id, role_id)
);
```

### Enhanced Audit Schema

```sql
-- Enhanced audit_logs table
CREATE TABLE public.audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Entity Information
  entity_type VARCHAR(50) NOT NULL,
  entity_id UUID NOT NULL,
  
  -- Action Information
  action VARCHAR(50) NOT NULL,
  action_category VARCHAR(50) NOT NULL, -- 'authentication', 'authorization', 'data_access', 'administration'
  
  -- User Context
  performed_by UUID,
  performed_by_email VARCHAR(255),
  impersonated_by UUID, -- For admin impersonation
  
  -- Request Context
  ip_address INET,
  user_agent TEXT,
  request_id UUID,
  session_id UUID,
  
  -- Organization Context
  organization_id UUID,
  
  -- Change Details
  changes JSONB,
  old_values JSONB,
  new_values JSONB,
  
  -- Security Context
  security_level VARCHAR(20) DEFAULT 'normal', -- 'low', 'normal', 'high', 'critical'
  risk_score INTEGER DEFAULT 0,
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  
  -- Timestamps
  performed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  -- Indexes
  CONSTRAINT audit_logs_valid_action_category CHECK (action_category IN ('authentication', 'authorization', 'data_access', 'administration', 'security'))
);

-- Indexes for audit queries
CREATE INDEX idx_audit_logs_entity ON public.audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_logs_performed_by ON public.audit_logs(performed_by);
CREATE INDEX idx_audit_logs_performed_at ON public.audit_logs(performed_at);
CREATE INDEX idx_audit_logs_organization ON public.audit_logs(organization_id);
CREATE INDEX idx_audit_logs_action_category ON public.audit_logs(action_category);
CREATE INDEX idx_audit_logs_security_level ON public.audit_logs(security_level);
```

## API Design

### Authentication Endpoints

```typescript
// Authentication API specification
interface AuthenticationAPI {
  // Login endpoint
  'POST /api/auth/login': {
    request: {
      email: string;
      password: string;
      rememberMe?: boolean;
      mfaToken?: string;
    };
    response: {
      success: boolean;
      user: UserProfile;
      token: string;
      expiresAt: string;
      permissions: string[];
    };
  };

  // Logout endpoint
  'POST /api/auth/logout': {
    request: {};
    response: {
      success: boolean;
    };
  };

  // Token refresh
  'POST /api/auth/refresh': {
    request: {
      refreshToken: string;
    };
    response: {
      token: string;
      expiresAt: string;
    };
  };

  // Password reset request
  'POST /api/auth/forgot-password': {
    request: {
      email: string;
    };
    response: {
      success: boolean;
      message: string;
    };
  };

  // Password reset
  'POST /api/auth/reset-password': {
    request: {
      token: string;
      newPassword: string;
      confirmPassword: string;
    };
    response: {
      success: boolean;
      message: string;
    };
  };

  // Change password
  'POST /api/auth/change-password': {
    request: {
      currentPassword: string;
      newPassword: string;
      confirmPassword: string;
    };
    response: {
      success: boolean;
      message: string;
    };
  };

  // User profile
  'GET /api/auth/profile': {
    response: {
      user: UserProfile;
      permissions: string[];
      organization: OrganizationProfile;
    };
  };

  // Update profile
  'PUT /api/auth/profile': {
    request: {
      name?: string;
      phone?: string;
      timezone?: string;
      locale?: string;
    };
    response: {
      success: boolean;
      user: UserProfile;
    };
  };
}
```

### User Management Endpoints

```typescript
// User Management API (Admin only)
interface UserManagementAPI {
  // List users
  'GET /api/admin/users': {
    query: {
      page?: number;
      limit?: number;
      search?: string;
      role?: string;
      status?: 'active' | 'inactive' | 'locked';
      organizationId?: string;
    };
    response: {
      users: UserProfile[];
      pagination: PaginationInfo;
    };
  };

  // Create user
  'POST /api/admin/users': {
    request: {
      email: string;
      name: string;
      role: string;
      organizationId: string;
      sendInvitation?: boolean;
    };
    response: {
      success: boolean;
      user: UserProfile;
      invitationToken?: string;
    };
  };

  // Update user
  'PUT /api/admin/users/:id': {
    request: {
      name?: string;
      role?: string;
      isActive?: boolean;
      permissions?: string[];
    };
    response: {
      success: boolean;
      user: UserProfile;
    };
  };

  // Delete user
  'DELETE /api/admin/users/:id': {
    response: {
      success: boolean;
      message: string;
    };
  };

  // User audit log
  'GET /api/admin/users/:id/audit': {
    query: {
      page?: number;
      limit?: number;
      action?: string;
      dateFrom?: string;
      dateTo?: string;
    };
    response: {
      auditLogs: AuditLogEntry[];
      pagination: PaginationInfo;
    };
  };
}
```

## Security Implementation

### Password Security Service

```typescript
// Password security implementation
import bcrypt from 'bcryptjs';
import crypto from 'crypto';

export class PasswordService {
  private static readonly SALT_ROUNDS = 12;
  private static readonly MIN_PASSWORD_LENGTH = 8;
  private static readonly MAX_PASSWORD_LENGTH = 128;

  static async hashPassword(password: string): Promise<{
    hash: string;
    salt: string;
  }> {
    // Validate password requirements
    this.validatePasswordRequirements(password);
    
    // Generate salt
    const salt = await bcrypt.genSalt(this.SALT_ROUNDS);
    
    // Hash password
    const hash = await bcrypt.hash(password, salt);
    
    return { hash, salt };
  }

  static async verifyPassword(
    password: string,
    hash: string
  ): Promise<boolean> {
    try {
      return await bcrypt.compare(password, hash);
    } catch (error) {
      console.error('Password verification error:', error);
      return false;
    }
  }

  static validatePasswordRequirements(password: string): void {
    const errors: string[] = [];

    if (password.length < this.MIN_PASSWORD_LENGTH) {
      errors.push(`Password must be at least ${this.MIN_PASSWORD_LENGTH} characters long`);
    }

    if (password.length > this.MAX_PASSWORD_LENGTH) {
      errors.push(`Password must be no more than ${this.MAX_PASSWORD_LENGTH} characters long`);
    }

    if (!/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter');
    }

    if (!/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter');
    }

    if (!/\d/.test(password)) {
      errors.push('Password must contain at least one number');
    }

    if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      errors.push('Password must contain at least one special character');
    }

    if (errors.length > 0) {
      throw new Error(`Password validation failed: ${errors.join(', ')}`);
    }
  }

  static generateSecureToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }

  static generatePasswordResetToken(): {
    token: string;
    expires: Date;
  } {
    const token = this.generateSecureToken(32);
    const expires = new Date();
    expires.setHours(expires.getHours() + 1); // 1 hour expiration
    
    return { token, expires };
  }
}
```

### JWT Token Service

```typescript
// JWT token service implementation
import jwt from 'jsonwebtoken';
import { User } from '@prisma/client';

export interface JWTPayload {
  userId: string;
  email: string;
  organizationId: string;
  role: string;
  permissions: string[];
  iat: number;
  exp: number;
}

export class JWTService {
  private static readonly ACCESS_TOKEN_EXPIRY = '15m';
  private static readonly REFRESH_TOKEN_EXPIRY = '7d';
  private static readonly JWT_SECRET = process.env.JWT_SECRET!;
  private static readonly JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;

  static generateAccessToken(user: User, permissions: string[]): string {
    const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
      userId: user.id,
      email: user.email,
      organizationId: user.organizationId,
      role: user.role,
      permissions,
    };

    return jwt.sign(payload, this.JWT_SECRET, {
      expiresIn: this.ACCESS_TOKEN_EXPIRY,
      issuer: 'capacity-planner',
      audience: 'capacity-planner-api',
    });
  }

  static generateRefreshToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'refresh' },
      this.JWT_REFRESH_SECRET,
      {
        expiresIn: this.REFRESH_TOKEN_EXPIRY,
        issuer: 'capacity-planner',
        audience: 'capacity-planner-api',
      }
    );
  }

  static verifyAccessToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, this.JWT_SECRET, {
        issuer: 'capacity-planner',
        audience: 'capacity-planner-api',
      }) as JWTPayload;
    } catch (error) {
      throw new Error('Invalid or expired access token');
    }
  }

  static verifyRefreshToken(token: string): { userId: string; type: string } {
    try {
      return jwt.verify(token, this.JWT_REFRESH_SECRET, {
        issuer: 'capacity-planner',
        audience: 'capacity-planner-api',
      }) as { userId: string; type: string };
    } catch (error) {
      throw new Error('Invalid or expired refresh token');
    }
  }

  static decodeToken(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload;
    } catch (error) {
      return null;
    }
  }
}
```

### Session Management Service

```typescript
// Session management with iron-session
import { IronSessionOptions } from 'iron-session';
import { sealData, unsealData } from 'iron-session';

export interface SessionData {
  user?: {
    id: string;
    email: string;
    name: string;
    role: string;
    organizationId: string;
    permissions: string[];
    isAdmin: boolean;
  };
  sessionId: string;
  createdAt: number;
  lastAccessedAt: number;
  ipAddress?: string;
  userAgent?: string;
}

export class SessionService {
  private static readonly SESSION_OPTIONS: IronSessionOptions = {
    password: process.env.SESSION_SECRET!,
    cookieName: 'capacity-planner-session',
    cookieOptions: {
      secure: process.env.NODE_ENV === 'production',
      httpOnly: true,
      sameSite: 'lax',
      maxAge: 86400 * 30, // 30 days
      path: '/',
    },
  };

  static async createSession(
    user: SessionData['user'],
    request: {
      ip?: string;
      userAgent?: string;
    }
  ): Promise<string> {
    const sessionData: SessionData = {
      user,
      sessionId: crypto.randomUUID(),
      createdAt: Date.now(),
      lastAccessedAt: Date.now(),
      ipAddress: request.ip,
      userAgent: request.userAgent,
    };

    const sealed = await sealData(sessionData, this.SESSION_OPTIONS);
    
    return `${this.SESSION_OPTIONS.cookieName}=${sealed}; Path=/; ${
      this.SESSION_OPTIONS.cookieOptions?.secure ? 'Secure; ' : ''
    }HttpOnly; SameSite=${this.SESSION_OPTIONS.cookieOptions?.sameSite || 'Lax'}; Max-Age=${
      this.SESSION_OPTIONS.cookieOptions?.maxAge || 86400
    }`;
  }

  static async getSession(cookies: string): Promise<SessionData | null> {
    const sessionCookie = this.parseCookies(cookies)[this.SESSION_OPTIONS.cookieName];
    
    if (!sessionCookie) {
      return null;
    }

    try {
      const sessionData = await unsealData<SessionData>(sessionCookie, this.SESSION_OPTIONS);
      
      // Check session expiration
      const now = Date.now();
      const maxAge = (this.SESSION_OPTIONS.cookieOptions?.maxAge || 86400) * 1000;
      
      if (now - sessionData.createdAt > maxAge) {
        return null;
      }

      // Update last accessed time
      sessionData.lastAccessedAt = now;
      
      return sessionData;
    } catch (error) {
      console.error('Session validation error:', error);
      return null;
    }
  }

  static async updateSession(
    sessionData: SessionData,
    updates: Partial<SessionData>
  ): Promise<string> {
    const updatedSession = {
      ...sessionData,
      ...updates,
      lastAccessedAt: Date.now(),
    };

    const sealed = await sealData(updatedSession, this.SESSION_OPTIONS);
    
    return `${this.SESSION_OPTIONS.cookieName}=${sealed}; Path=/; ${
      this.SESSION_OPTIONS.cookieOptions?.secure ? 'Secure; ' : ''
    }HttpOnly; SameSite=${this.SESSION_OPTIONS.cookieOptions?.sameSite || 'Lax'}; Max-Age=${
      this.SESSION_OPTIONS.cookieOptions?.maxAge || 86400
    }`;
  }

  static clearSession(): string {
    return `${this.SESSION_OPTIONS.cookieName}=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; HttpOnly`;
  }

  private static parseCookies(cookieString: string): Record<string, string> {
    return cookieString.split(';').reduce((acc, cookie) => {
      const [key, value] = cookie.trim().split('=');
      if (key && value) {
        acc[key] = value;
      }
      return acc;
    }, {} as Record<string, string>);
  }
}
```

## Middleware & Authorization

### Authentication Middleware

```typescript
// Authentication middleware implementation
import { Request, Response, NextFunction } from 'express';
import { JWTService, JWTPayload } from '../services/jwt.service';
import { SessionService } from '../services/session.service';
import { AuditService } from '../services/audit.service';

export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    name: string;
    role: string;
    organizationId: string;
    permissions: string[];
    isAdmin: boolean;
  };
  sessionId?: string;
  authMethod?: 'session' | 'jwt';
}

export const authenticationMiddleware = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    let user = null;
    let sessionId = null;
    let authMethod: 'session' | 'jwt' = 'session';

    // Try JWT authentication first (for API requests)
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      
      try {
        const payload = JWTService.verifyAccessToken(token);
        user = {
          id: payload.userId,
          email: payload.email,
          name: '', // Will be populated from database if needed
          role: payload.role,
          organizationId: payload.organizationId,
          permissions: payload.permissions,
          isAdmin: payload.role === 'admin_support' || payload.role === 'client_admin',
        };
        authMethod = 'jwt';
        sessionId = `jwt-${payload.userId}`;
      } catch (error) {
        // JWT verification failed, try session authentication
      }
    }

    // Try session authentication (for web requests)
    if (!user && req.headers.cookie) {
      const sessionData = await SessionService.getSession(req.headers.cookie);
      
      if (sessionData && sessionData.user) {
        user = sessionData.user;
        sessionId = sessionData.sessionId;
        authMethod = 'session';
      }
    }

    // If no valid authentication found
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required',
        code: 'UNAUTHENTICATED',
      });
    }

    // Attach user context to request
    req.user = user;
    req.sessionId = sessionId;
    req.authMethod = authMethod;

    // Log authentication event
    await AuditService.logEvent({
      entityType: 'authentication',
      entityId: user.id,
      action: 'authenticated',
      actionCategory: 'authentication',
      performedBy: user.id,
      performedByEmail: user.email,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      sessionId,
      organizationId: user.organizationId,
      metadata: {
        authMethod,
        endpoint: req.path,
        method: req.method,
      },
    });

    next();
  } catch (error) {
    console.error('Authentication middleware error:', error);
    
    // Log security event
    await AuditService.logEvent({
      entityType: 'security',
      entityId: 'system',
      action: 'authentication_error',
      actionCategory: 'security',
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      metadata: {
        error: error.message,
        endpoint: req.path,
        method: req.method,
      },
      securityLevel: 'high',
    });

    res.status(500).json({
      success: false,
      error: 'Authentication system error',
      code: 'AUTH_ERROR',
    });
  }
};
```

### Authorization Middleware

```typescript
// Authorization middleware implementation
import { Response, NextFunction } from 'express';
import { AuthenticatedRequest } from './authentication.middleware';
import { PermissionService } from '../services/permission.service';
import { AuditService } from '../services/audit.service';

export interface AuthorizationOptions {
  permissions?: string[];
  roles?: string[];
  requireAll?: boolean; // Default: false (require any)
  organizationScoped?: boolean; // Default: true
}

export const authorizationMiddleware = (options: AuthorizationOptions = {}) => {
  return async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
  ) => {
    try {
      const user = req.user;
      
      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required',
          code: 'UNAUTHENTICATED',
        });
      }

      // Check role-based access
      if (options.roles && options.roles.length > 0) {
        const hasRole = options.roles.includes(user.role);
        
        if (!hasRole) {
          await AuditService.logEvent({
            entityType: 'authorization',
            entityId: user.id,
            action: 'access_denied',
            actionCategory: 'authorization',
            performedBy: user.id,
            performedByEmail: user.email,
            ipAddress: req.ip,
            userAgent: req.headers['user-agent'],
            sessionId: req.sessionId,
            organizationId: user.organizationId,
            metadata: {
              requiredRoles: options.roles,
              userRole: user.role,
              endpoint: req.path,
              method: req.method,
            },
            securityLevel: 'high',
          });

          return res.status(403).json({
            success: false,
            error: 'Insufficient permissions',
            code: 'FORBIDDEN',
          });
        }
      }

      // Check permission-based access
      if (options.permissions && options.permissions.length > 0) {
        const hasPermission = await PermissionService.checkPermissions(
          user.permissions,
          options.permissions,
          options.requireAll || false
        );

        if (!hasPermission) {
          await AuditService.logEvent({
            entityType: 'authorization',
            entityId: user.id,
            action: 'access_denied',
            actionCategory: 'authorization',
            performedBy: user.id,
            performedByEmail: user.email,
            ipAddress: req.ip,
            userAgent: req.headers['user-agent'],
            sessionId: req.sessionId,
            organizationId: user.organizationId,
            metadata: {
              requiredPermissions: options.permissions,
              userPermissions: user.permissions,
              endpoint: req.path,
              method: req.method,
            },
            securityLevel: 'high',
          });

          return res.status(403).json({
            success: false,
            error: 'Insufficient permissions',
            code: 'FORBIDDEN',
          });
        }
      }

      // Organization scoping (default: enabled)
      if (options.organizationScoped !== false) {
        // Add organization context to request
        req.headers['x-organization-id'] = user.organizationId;
      }

      // Log successful authorization
      await AuditService.logEvent({
        entityType: 'authorization',
        entityId: user.id,
        action: 'access_granted',
        actionCategory: 'authorization',
        performedBy: user.id,
        performedByEmail: user.email,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        sessionId: req.sessionId,
        organizationId: user.organizationId,
        metadata: {
          endpoint: req.path,
          method: req.method,
          permissions: options.permissions,
          roles: options.roles,
        },
      });

      next();
    } catch (error) {
      console.error('Authorization middleware error:', error);
      
      await AuditService.logEvent({
        entityType: 'security',
        entityId: 'system',
        action: 'authorization_error',
        actionCategory: 'security',
        performedBy: req.user?.id,
        performedByEmail: req.user?.email,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent'],
        sessionId: req.sessionId,
        organizationId: req.user?.organizationId,
        metadata: {
          error: error.message,
          endpoint: req.path,
          method: req.method,
        },
        securityLevel: 'critical',
      });

      res.status(500).json({
        success: false,
        error: 'Authorization system error',
        code: 'AUTH_ERROR',
      });
    }
  };
};

// Helper function to create authorization middleware
export const requireAuth = (options: AuthorizationOptions = {}) => {
  return [authenticationMiddleware, authorizationMiddleware(options)];
};

// Common authorization presets
export const requireAdmin = () => requireAuth({
  roles: ['admin_support', 'client_admin'],
});

export const requireAssetOwner = () => requireAuth({
  roles: ['admin_support', 'client_admin', 'asset_owner'],
});

export const requirePermission = (permissions: string | string[]) => requireAuth({
  permissions: Array.isArray(permissions) ? permissions : [permissions],
});
```

## Frontend Implementation

### Authentication Context

```typescript
// Authentication context for React
import React, { createContext, useContext, useEffect, useState } from 'react';

interface User {
  id: string;
  email: string;
  name: string;
  role: string;
  organizationId: string;
  permissions: string[];
  isAdmin: boolean;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<void>;
  hasPermission: (permission: string) => boolean;
  hasRole: (role: string) => boolean;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check for existing session on mount
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      const response = await fetch('/api/auth/profile', {
        credentials: 'include',
      });

      if (response.ok) {
        const data = await response.json();
        setUser(data.user);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Login failed');
    }

    const data = await response.json();
    setUser(data.user);
    
    // Store JWT token for API requests
    localStorage.setItem('authToken', data.token);
  };

  const logout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include',
      });
    } catch (error) {
      console.error('Logout error:', error);
    }

    setUser(null);
    localStorage.removeItem('authToken');
  };

  const refreshToken = async () => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include',
      });

      if (response.ok) {
        const data = await response.json();
        localStorage.setItem('authToken', data.token);
      }
    } catch (error) {
      console.error('Token refresh failed:', error);
    }
  };

  const hasPermission = (permission: string): boolean => {
    return user?.permissions.includes(permission) || user?.isAdmin || false;
  };

  const hasRole = (role: string): boolean => {
    return user?.role === role || user?.isAdmin || false;
  };

  const value: AuthContextType = {
    user,
    loading,
    login,
    logout,
    refreshToken,
    hasPermission,
    hasRole,
    isAuthenticated: !!user,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

### Protected Route Component

```typescript
// Protected route component
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredPermissions?: string[];
  requiredRoles?: string[];
  requireAll?: boolean;
  fallback?: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  children,
  requiredPermissions = [],
  requiredRoles = [],
  requireAll = false,
  fallback = <Navigate to="/login" replace />,
}) => {
  const { user, loading, hasPermission, hasRole } = useAuth();
  const location = useLocation();

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // Check role requirements
  if (requiredRoles.length > 0) {
    const hasRequiredRole = requireAll
      ? requiredRoles.every(role => hasRole(role))
      : requiredRoles.some(role => hasRole(role));

    if (!hasRequiredRole) {
      return fallback || <Navigate to="/unauthorized" replace />;
    }
  }

  // Check permission requirements
  if (requiredPermissions.length > 0) {
    const hasRequiredPermission = requireAll
      ? requiredPermissions.every(permission => hasPermission(permission))
      : requiredPermissions.some(permission => hasPermission(permission));

    if (!hasRequiredPermission) {
      return fallback || <Navigate to="/unauthorized" replace />;
    }
  }

  return <>{children}</>;
};
```

### Login Form Component

```typescript
// Login form component
import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
  rememberMe: z.boolean().optional(),
});

type LoginFormData = z.infer<typeof loginSchema>;

export const LoginForm: React.FC = () => {
  const { login } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const [error, setError] = useState<string>('');
  const [loading, setLoading] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  const from = location.state?.from?.pathname || '/dashboard';

  const onSubmit = async (data: LoginFormData) => {
    setError('');
    setLoading(true);

    try {
      await login(data.email, data.password);
      navigate(from, { replace: true });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Login failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Sign in to CapaCity Planner
          </h2>
        </div>
        
        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="email" className="sr-only">
                Email address
              </label>
              <input
                {...register('email')}
                type="email"
                autoComplete="email"
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Email address"
              />
              {errors.email && (
                <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
              )}
            </div>
            
            <div>
              <label htmlFor="password" className="sr-only">
                Password
              </label>
              <input
                {...register('password')}
                type="password"
                autoComplete="current-password"
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Password"
              />
              {errors.password && (
                <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                {...register('rememberMe')}
                type="checkbox"
                className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
              />
              <label htmlFor="rememberMe" className="ml-2 block text-sm text-gray-900">
                Remember me
              </label>
            </div>

            <div className="text-sm">
              <a href="/forgot-password" className="font-medium text-indigo-600 hover:text-indigo-500">
                Forgot your password?
              </a>
            </div>
          </div>

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <p className="text-sm text-red-800">{error}</p>
            </div>
          )}

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
            >
              {loading ? 'Signing in...' : 'Sign in'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};
```

## Testing Strategy

### Unit Tests

```typescript
// Password service unit tests
import { PasswordService } from '../services/password.service';

describe('PasswordService', () => {
  describe('hashPassword', () => {
    it('should hash password with salt', async () => {
      const password = 'TestPassword123!';
      const result = await PasswordService.hashPassword(password);
      
      expect(result.hash).toBeDefined();
      expect(result.salt).toBeDefined();
      expect(result.hash).not.toBe(password);
    });

    it('should throw error for weak password', async () => {
      const weakPassword = '123';
      
      await expect(PasswordService.hashPassword(weakPassword))
        .rejects.toThrow('Password validation failed');
    });
  });

  describe('verifyPassword', () => {
    it('should verify correct password', async () => {
      const password = 'TestPassword123!';
      const { hash } = await PasswordService.hashPassword(password);
      
      const isValid = await PasswordService.verifyPassword(password, hash);
      expect(isValid).toBe(true);
    });

    it('should reject incorrect password', async () => {
      const password = 'TestPassword123!';
      const wrongPassword = 'WrongPassword123!';
      const { hash } = await PasswordService.hashPassword(password);
      
      const isValid = await PasswordService.verifyPassword(wrongPassword, hash);
      expect(isValid).toBe(false);
    });
  });
});
```

### Integration Tests

```typescript
// Authentication integration tests
import request from 'supertest';
import { app } from '../app';
import { prisma } from '../lib/prisma';

describe('Authentication Integration', () => {
  beforeEach(async () => {
    // Clean up test data
    await prisma.user.deleteMany({
      where: { email: { contains: 'test' } },
    });
  });

  describe('POST /api/auth/login', () => {
    it('should login with valid credentials', async () => {
      // Create test user
      const user = await prisma.user.create({
        data: {
          email: 'test@example.com',
          name: 'Test User',
          passwordHash: await PasswordService.hashPassword('TestPassword123!').then(r => r.hash),
          role: 'requester',
          organizationId: 'test-org-id',
        },
      });

      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'TestPassword123!',
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.user.email).toBe('test@example.com');
      expect(response.body.token).toBeDefined();
    });

    it('should reject invalid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'nonexistent@example.com',
          password: 'wrongpassword',
        });

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toBe('Invalid credentials');
    });
  });
});
```

### Security Tests

```typescript
// Security-focused tests
describe('Security Tests', () => {
  describe('Rate Limiting', () => {
    it('should block excessive login attempts', async () => {
      const loginAttempts = Array(6).fill(null).map(() =>
        request(app)
          .post('/api/auth/login')
          .send({
            email: 'test@example.com',
            password: 'wrongpassword',
          })
      );

      const responses = await Promise.all(loginAttempts);
      const lastResponse = responses[responses.length - 1];

      expect(lastResponse.status).toBe(429);
      expect(lastResponse.body.error).toContain('Too many');
    });
  });

  describe('JWT Security', () => {
    it('should reject tampered JWT tokens', async () => {
      const tamperedToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';

      const response = await request(app)
        .get('/api/auth/profile')
        .set('Authorization', `Bearer ${tamperedToken}`);

      expect(response.status).toBe(401);
      expect(response.body.code).toBe('UNAUTHENTICATED');
    });
  });

  describe('Session Security', () => {
    it('should use secure session cookies in production', () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'production';

      const sessionCookie = SessionService.createSession(mockUser, {});
      expect(sessionCookie).toContain('Secure');
      expect(sessionCookie).toContain('HttpOnly');
      expect(sessionCookie).toContain('SameSite=Lax');

      process.env.NODE_ENV = originalEnv;
    });
  });
});
```

## Migration Plan

### Phase 1: Database Migration

```sql
-- Migration: Add authentication fields to users table
ALTER TABLE public.users 
ADD COLUMN password_hash VARCHAR(255),
ADD COLUMN password_salt VARCHAR(255),
ADD COLUMN password_changed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
ADD COLUMN password_reset_token VARCHAR(255),
ADD COLUMN password_reset_expires TIMESTAMP WITH TIME ZONE,
ADD COLUMN failed_login_attempts INTEGER DEFAULT 0,
ADD COLUMN last_login_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN last_login_ip INET,
ADD COLUMN is_locked BOOLEAN DEFAULT false,
ADD COLUMN locked_until TIMESTAMP WITH TIME ZONE,
ADD COLUMN mfa_enabled BOOLEAN DEFAULT false,
ADD COLUMN mfa_secret VARCHAR(255),
ADD COLUMN backup_codes JSONB DEFAULT '[]';

-- Create sessions table
CREATE TABLE public.user_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  session_token VARCHAR(255) UNIQUE NOT NULL,
  session_data JSONB NOT NULL,
  user_agent TEXT,
  ip_address INET,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  is_active BOOLEAN DEFAULT true,
  revoked_at TIMESTAMP WITH TIME ZONE,
  revoked_reason VARCHAR(255)
);

-- Create roles and permissions tables
CREATE TABLE public.roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(50) UNIQUE NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  description TEXT,
  permissions JSONB DEFAULT '[]',
  is_system_role BOOLEAN DEFAULT false,
  organization_id UUID REFERENCES public.organizations(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID,
  updated_by UUID
);

CREATE TABLE public.permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) UNIQUE NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  description TEXT,
  resource VARCHAR(50) NOT NULL,
  action VARCHAR(50) NOT NULL,
  module VARCHAR(50) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  CONSTRAINT permissions_resource_action_unique UNIQUE (resource, action, module)
);

-- Enhanced audit logs
ALTER TABLE public.audit_logs 
ADD COLUMN action_category VARCHAR(50) NOT NULL DEFAULT 'data_access',
ADD COLUMN performed_by_email VARCHAR(255),
ADD COLUMN impersonated_by UUID,
ADD COLUMN request_id UUID,
ADD COLUMN session_id UUID,
ADD COLUMN security_level VARCHAR(20) DEFAULT 'normal',
ADD COLUMN risk_score INTEGER DEFAULT 0,
ADD COLUMN old_values JSONB,
ADD COLUMN new_values JSONB;
```

### Phase 2: Data Migration

```typescript
// Data migration script
import { PrismaClient } from '@prisma/client';
import { PasswordService } from '../services/password.service';

const prisma = new PrismaClient();

async function migrateUserPasswords() {
  console.log('Starting password migration...');
  
  // Get all users without password hashes
  const users = await prisma.user.findMany({
    where: {
      passwordHash: null,
    },
  });

  console.log(`Found ${users.length} users to migrate`);

  for (const user of users) {
    // Generate temporary password or use default
    const tempPassword = process.env.DEFAULT_USER_PASSWORD || 'TempPassword123!';
    const { hash, salt } = await PasswordService.hashPassword(tempPassword);

    await prisma.user.update({
      where: { id: user.id },
      data: {
        passwordHash: hash,
        passwordSalt: salt,
        passwordChangedAt: new Date(),
      },
    });

    console.log(`Migrated password for user: ${user.email}`);
  }

  console.log('Password migration completed');
}

async function createDefaultRoles() {
  console.log('Creating default roles...');

  const defaultRoles = [
    {
      name: 'admin_support',
      displayName: 'Admin Support',
      description: 'Full system administration access',
      permissions: ['*'],
      isSystemRole: true,
    },
    {
      name: 'client_admin',
      displayName: 'Client Admin',
      description: 'Organization-level administration',
      permissions: ['organization.*', 'user.*'],
      isSystemRole: true,
    },
    {
      name: 'asset_owner',
      displayName: 'Asset Owner',
      description: 'Asset management permissions',
      permissions: ['asset.*'],
      isSystemRole: true,
    },
    {
      name: 'airport_planner',
      displayName: 'Airport Planner',
      description: 'Planning and analysis access',
      permissions: ['planning.*', 'analysis.*'],
      isSystemRole: true,
    },
    {
      name: 'key_stakeholder',
      displayName: 'Key Stakeholder',
      description: 'Read-only access to key metrics',
      permissions: ['dashboard.read', 'reports.read'],
      isSystemRole: true,
    },
    {
      name: 'third_party_contractor',
      displayName: 'Third-Party Contractor',
      description: 'Limited access to specific functions',
      permissions: ['work_request.read', 'work_request.create'],
      isSystemRole: true,
    },
    {
      name: 'requester',
      displayName: 'Requester',
      description: 'Basic user access for work requests',
      permissions: ['work_request.create', 'work_request.read_own'],
      isSystemRole: true,
    },
  ];

  for (const roleData of defaultRoles) {
    await prisma.role.upsert({
      where: { name: roleData.name },
      update: {},
      create: roleData,
    });

    console.log(`Created role: ${roleData.name}`);
  }

  console.log('Default roles created');
}

async function runMigration() {
  try {
    await migrateUserPasswords();
    await createDefaultRoles();
    console.log('Migration completed successfully');
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

runMigration();
```

### Phase 3: Deployment Steps

```bash
#!/bin/bash
# Deployment script for authentication system

echo "Starting authentication system deployment..."

# 1. Backup current database
echo "Creating database backup..."
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql

# 2. Run database migrations
echo "Running database migrations..."
npx prisma migrate deploy

# 3. Run data migration
echo "Running data migration..."
npm run migrate:auth-data

# 4. Install new dependencies
echo "Installing dependencies..."
npm install bcryptjs jsonwebtoken iron-session

# 5. Update environment variables
echo "Updating environment variables..."
# Add new required environment variables
# SESSION_SECRET, JWT_SECRET, JWT_REFRESH_SECRET

# 6. Deploy application
echo "Deploying application..."
npm run build
npm run start

# 7. Verify deployment
echo "Verifying deployment..."
curl -f http://localhost:3000/api/health || exit 1

echo "Authentication system deployment completed successfully!"
```

## Monitoring & Observability

### Security Metrics

```typescript
// Security monitoring service
import { EventEmitter } from 'events';

export class SecurityMonitor extends EventEmitter {
  private static instance: SecurityMonitor;
  private metrics: Map<string, number> = new Map();
  private alerts: Array<SecurityAlert> = [];

  static getInstance(): SecurityMonitor {
    if (!SecurityMonitor.instance) {
      SecurityMonitor.instance = new SecurityMonitor();
    }
    return SecurityMonitor.instance;
  }

  // Track security events
  trackEvent(event: SecurityEvent) {
    const key = `${event.type}_${event.severity}`;
    this.metrics.set(key, (this.metrics.get(key) || 0) + 1);

    // Check for security alerts
    this.checkSecurityThresholds(event);
    
    // Emit event for real-time monitoring
    this.emit('securityEvent', event);
  }

  // Check security thresholds
  private checkSecurityThresholds(event: SecurityEvent) {
    const thresholds = {
      failed_login: 5,
      unauthorized_access: 3,
      suspicious_activity: 2,
    };

    const count = this.metrics.get(`${event.type}_high`) || 0;
    const threshold = thresholds[event.type] || 10;

    if (count >= threshold) {
      this.createAlert({
        type: 'security_threshold_exceeded',
        severity: 'high',
        message: `Security threshold exceeded for ${event.type}`,
        metadata: { count, threshold, event },
      });
    }
  }

  // Create security alert
  private createAlert(alert: SecurityAlert) {
    this.alerts.push(alert);
    this.emit('securityAlert', alert);
    
    // Send to monitoring system
    this.sendToMonitoring(alert);
  }

  // Send to external monitoring
  private sendToMonitoring(alert: SecurityAlert) {
    // Integration with monitoring systems
    // (Prometheus, Grafana, PagerDuty, etc.)
  }
}

interface SecurityEvent {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  userId?: string;
  organizationId?: string;
  ipAddress?: string;
  userAgent?: string;
  metadata?: any;
}

interface SecurityAlert {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  metadata?: any;
  createdAt?: Date;
}
```

### Performance Monitoring

```typescript
// Performance monitoring for authentication
import { performance } from 'perf_hooks';

export class AuthPerformanceMonitor {
  private static metrics: Map<string, number[]> = new Map();

  static trackAuthenticationTime(operation: string, startTime: number) {
    const duration = performance.now() - startTime;
    
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, []);
    }
    
    this.metrics.get(operation)!.push(duration);
    
    // Keep only last 1000 measurements
    if (this.metrics.get(operation)!.length > 1000) {
      this.metrics.get(operation)!.shift();
    }
  }

  static getMetrics() {
    const result: Record<string, any> = {};
    
    for (const [operation, durations] of this.metrics.entries()) {
      result[operation] = {
        count: durations.length,
        average: durations.reduce((a, b) => a + b, 0) / durations.length,
        min: Math.min(...durations),
        max: Math.max(...durations),
        p95: this.percentile(durations, 95),
        p99: this.percentile(durations, 99),
      };
    }
    
    return result;
  }

  private static percentile(values: number[], p: number): number {
    const sorted = values.slice().sort((a, b) => a - b);
    const index = Math.ceil((p / 100) * sorted.length) - 1;
    return sorted[index];
  }
}

// Usage in authentication middleware
export const performanceTrackingMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const startTime = performance.now();
  
  res.on('finish', () => {
    AuthPerformanceMonitor.trackAuthenticationTime('authentication', startTime);
  });
  
  next();
};
```

## Deployment Strategy

### Environment Configuration

```typescript
// Environment configuration
export const authConfig = {
  // Password security
  bcryptRounds: parseInt(process.env.BCRYPT_ROUNDS || '12'),
  passwordMinLength: parseInt(process.env.PASSWORD_MIN_LENGTH || '8'),
  passwordMaxLength: parseInt(process.env.PASSWORD_MAX_LENGTH || '128'),
  
  // JWT configuration
  jwtSecret: process.env.JWT_SECRET!,
  jwtRefreshSecret: process.env.JWT_REFRESH_SECRET!,
  jwtExpiry: process.env.JWT_EXPIRY || '15m',
  refreshTokenExpiry: process.env.REFRESH_TOKEN_EXPIRY || '7d',
  
  // Session configuration
  sessionSecret: process.env.SESSION_SECRET!,
  sessionMaxAge: parseInt(process.env.SESSION_MAX_AGE || '2592000'), // 30 days
  
  // Security settings
  maxLoginAttempts: parseInt(process.env.MAX_LOGIN_ATTEMPTS || '5'),
  lockoutDuration: parseInt(process.env.LOCKOUT_DURATION || '1800'), // 30 minutes
  
  // Rate limiting
  loginRateLimit: parseInt(process.env.LOGIN_RATE_LIMIT || '5'),
  loginRateWindow: parseInt(process.env.LOGIN_RATE_WINDOW || '900'), // 15 minutes
  
  // MFA settings
  mfaEnabled: process.env.MFA_ENABLED === 'true',
  mfaIssuer: process.env.MFA_ISSUER || 'CapaCity Planner',
  
  // Audit settings
  auditRetentionDays: parseInt(process.env.AUDIT_RETENTION_DAYS || '90'),
  
  // Email settings (for password reset)
  emailService: process.env.EMAIL_SERVICE || 'smtp',
  smtpHost: process.env.SMTP_HOST,
  smtpPort: parseInt(process.env.SMTP_PORT || '587'),
  smtpUser: process.env.SMTP_USER,
  smtpPass: process.env.SMTP_PASS,
};

// Validate required environment variables
export function validateAuthConfig() {
  const required = [
    'JWT_SECRET',
    'JWT_REFRESH_SECRET',
    'SESSION_SECRET',
    'DATABASE_URL',
  ];
  
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
}
```

### Production Deployment Checklist

```markdown
# Authentication System Deployment Checklist

## Pre-Deployment
- [ ] Environment variables configured
- [ ] Database migrations tested
- [ ] Security review completed
- [ ] Performance testing completed
- [ ] Backup strategy verified

## Deployment
- [ ] Database backup created
- [ ] Migrations executed
- [ ] Application deployed
- [ ] Health checks passing
- [ ] Monitoring configured

## Post-Deployment
- [ ] Authentication flows tested
- [ ] User management tested
- [ ] Security monitoring active
- [ ] Performance metrics baseline established
- [ ] Documentation updated

## Security Verification
- [ ] Password hashing working correctly
- [ ] JWT tokens secure and valid
- [ ] Session management secure
- [ ] Rate limiting active
- [ ] Audit logging functional
- [ ] HTTPS enforced in production

## Monitoring Setup
- [ ] Security alerts configured
- [ ] Performance dashboards created
- [ ] Log aggregation active
- [ ] Error tracking enabled
- [ ] Uptime monitoring configured
```

---

**Document Status**: Ready for Implementation  
**Implementation Priority**: Phase 1 - Core Authentication (Week 1)  
**Review Date**: Weekly during implementation phase  
**Dependencies**: PostgreSQL database, Redis (optional), Email service setup 