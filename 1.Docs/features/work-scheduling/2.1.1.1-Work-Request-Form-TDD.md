# TDD: Work Request Form for Stand Maintenance

**Feature**: Comprehensive Work Request Form for Stand Maintenance and Operations  
**Version**: 2.1.1.1  
**Date**: January 2025  
**Owner**: Engineering Team  
**Status**: Ready for Implementation  
**PRD Reference**: 2.1.1.1-Work-Request-Form-PRD.md

## Technical Overview

This TDD defines the complete technical implementation for the work request form system that integrates with the Assets Module to enable users to create, submit, and track maintenance and operational work requests against aircraft stands. The implementation follows a modular architecture with secure data handling, real-time validation, and comprehensive audit trails.

## Architecture Overview

### System Components
- **Frontend**: React-based form interface with TypeScript
- **Backend**: Node.js/Express API with PostgreSQL database
- **Integration Layer**: RESTful APIs for Assets Module communication
- **Validation Engine**: Multi-stage validation with real-time feedback
- **Audit System**: Comprehensive logging and event tracking
- **File Storage**: Secure attachment handling with virus scanning

### Technology Stack
- **Frontend**: React 18+, TypeScript, React Hook Form, Zod validation
- **Backend**: Node.js 20+, Express 4.18+, PostgreSQL 14+
- **Database**: PostgreSQL with JSONB support and GIN indexes
- **Caching**: Redis for validation results and stand data
- **File Storage**: AWS S3 or local filesystem with encryption
- **Security**: JWT authentication, RBAC authorization, field-level encryption

## Database Schema Design

### Extensible Architecture for Multiple Asset Types

The database schema is designed to be extensible for future asset types (airfield, baggage, terminals, etc.) while maintaining the current focus on stands. This approach uses a generic work request structure with asset-type-specific configurations.

### Core Tables

#### WorkRequest Table (Generic for All Asset Types)
```sql
CREATE TABLE work.work_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL,
  
  -- Asset Integration (Generic)
  asset_id UUID NOT NULL, -- Reference to any asset table
  asset_type VARCHAR(50) NOT NULL, -- 'stand', 'airfield', 'baggage', 'terminal', etc.
  asset_schema VARCHAR(50) NOT NULL, -- 'assets', 'airfield', 'baggage', etc.
  asset_code VARCHAR(50) NOT NULL, -- Denormalized for performance
  asset_name VARCHAR(200) NOT NULL, -- Denormalized for performance
  asset_location VARCHAR(200), -- Terminal, zone, area, etc.
  asset_metadata JSONB DEFAULT '{}', -- Asset-specific metadata
  
  -- Request Classification
  work_type VARCHAR(50) NOT NULL, -- 'maintenance', 'inspection', 'repair', 'modification', 'emergency'
  category VARCHAR(50) NOT NULL, -- 'routine', 'corrective', 'preventive', 'emergency'
  priority VARCHAR(20) NOT NULL DEFAULT 'medium', -- 'critical', 'high', 'medium', 'low'
  urgency VARCHAR(20) NOT NULL DEFAULT 'scheduled', -- 'immediate', 'scheduled', 'routine'
  impact_level VARCHAR(20) NOT NULL DEFAULT 'medium', -- 'full_closure', 'partial_restriction', 'no_impact'
  
  -- Request Details
  title VARCHAR(200) NOT NULL,
  description TEXT NOT NULL,
  location_details TEXT, -- Specific location within asset
  safety_considerations TEXT, -- Safety hazards, PPE requirements
  
  -- Scheduling
  requested_start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  requested_end_date TIMESTAMP WITH TIME ZONE,
  estimated_duration_minutes INTEGER,
  deadline TIMESTAMP WITH TIME ZONE,
  preferred_time_windows JSONB DEFAULT '[]', -- Array of time windows
  blackout_periods JSONB DEFAULT '[]', -- Array of blackout periods
  seasonal_constraints JSONB DEFAULT '{}', -- Weather/seasonal constraints
  
  -- Resource Requirements
  estimated_personnel_count INTEGER,
  required_skills JSONB DEFAULT '[]', -- Array of required skills
  required_equipment JSONB DEFAULT '[]', -- Array of required equipment
  estimated_materials_cost DECIMAL(10,2),
  
  -- Budget and Cost
  budget_code VARCHAR(50),
  estimated_total_cost DECIMAL(10,2),
  cost_center VARCHAR(50),
  purchase_order_number VARCHAR(50),
  vendor_information JSONB DEFAULT '{}',
  
  -- Stakeholder Information
  requested_by UUID NOT NULL, -- User ID
  requestor_name VARCHAR(100) NOT NULL,
  requestor_email VARCHAR(255) NOT NULL,
  requestor_phone VARCHAR(50),
  department VARCHAR(100),
  primary_contact_id UUID,
  secondary_contact_id UUID,
  
  -- Approval and Workflow
  approval_required BOOLEAN DEFAULT true,
  approval_level VARCHAR(20) DEFAULT 'standard', -- 'standard', 'elevated', 'executive'
  current_approver_id UUID,
  approval_deadline TIMESTAMP WITH TIME ZONE,
  
  -- Status and Lifecycle
  status VARCHAR(30) NOT NULL DEFAULT 'draft', -- 'draft', 'submitted', 'under_review', 'approved', 'rejected', 'cancelled', 'in_progress', 'completed'
  status_reason TEXT,
  submission_date TIMESTAMP WITH TIME ZONE,
  review_started_date TIMESTAMP WITH TIME ZONE,
  approved_date TIMESTAMP WITH TIME ZONE,
  completed_date TIMESTAMP WITH TIME ZONE,
  
  -- Regulatory and Compliance
  regulatory_approval_required BOOLEAN DEFAULT false,
  regulatory_reference VARCHAR(100),
  compliance_notes TEXT,
  
  -- Attachments and Documentation
  attachments JSONB DEFAULT '[]', -- Array of attachment metadata
  related_documents JSONB DEFAULT '[]', -- Array of related document references
  
  -- Metadata and Versioning
  version INTEGER DEFAULT 1,
  is_template BOOLEAN DEFAULT false,
  template_id UUID, -- Reference to template used
  metadata JSONB DEFAULT '{}',
  
  -- Audit Fields
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID NOT NULL,
  updated_by UUID NOT NULL,
  
  -- Constraints
  CONSTRAINT work_requests_dates_check CHECK (
    requested_start_date < COALESCE(requested_end_date, requested_start_date + INTERVAL '1 day')
  ),
  CONSTRAINT work_requests_cost_check CHECK (
    estimated_total_cost >= 0 AND estimated_materials_cost >= 0
  ),
  CONSTRAINT work_requests_asset_type_check CHECK (
    asset_type IN ('stand', 'airfield', 'baggage', 'terminal', 'gate', 'runway', 'taxiway')
  )
);

-- Indexes for performance
CREATE INDEX idx_work_requests_org_status ON work.work_requests(organization_id, status);
CREATE INDEX idx_work_requests_asset ON work.work_requests(asset_id, asset_type, status);
CREATE INDEX idx_work_requests_asset_type ON work.work_requests(asset_type, status);
CREATE INDEX idx_work_requests_requestor ON work.work_requests(requested_by, status);
CREATE INDEX idx_work_requests_dates ON work.work_requests(requested_start_date, requested_end_date);
CREATE INDEX idx_work_requests_priority ON work.work_requests(priority, urgency, status);
CREATE INDEX idx_work_requests_approval ON work.work_requests(current_approver_id, status) WHERE approval_required = true;
CREATE INDEX idx_work_requests_created_at ON work.work_requests(created_at DESC);
CREATE INDEX idx_work_requests_submission_date ON work.work_requests(submission_date DESC) WHERE submission_date IS NOT NULL;

-- GIN indexes for JSONB fields
CREATE INDEX idx_work_requests_skills ON work.work_requests USING gin(required_skills);
CREATE INDEX idx_work_requests_equipment ON work.work_requests USING gin(required_equipment);
CREATE INDEX idx_work_requests_attachments ON work.work_requests USING gin(attachments);
CREATE INDEX idx_work_requests_metadata ON work.work_requests USING gin(metadata);
CREATE INDEX idx_work_requests_asset_metadata ON work.work_requests USING gin(asset_metadata);
```

#### WorkRequestAssetAssociation Table (Generic for All Asset Types)
```sql
CREATE TABLE work.work_request_asset_associations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_request_id UUID NOT NULL REFERENCES work.work_requests(id) ON DELETE CASCADE,
  asset_id UUID NOT NULL, -- Reference to any asset table
  asset_type VARCHAR(50) NOT NULL, -- 'stand', 'airfield', 'baggage', etc.
  asset_schema VARCHAR(50) NOT NULL, -- Schema where asset resides
  asset_code VARCHAR(50) NOT NULL, -- Denormalized
  asset_name VARCHAR(200) NOT NULL, -- Denormalized
  association_type VARCHAR(30) NOT NULL DEFAULT 'primary', -- 'primary', 'secondary', 'affected'
  impact_level VARCHAR(20) NOT NULL DEFAULT 'medium', -- 'full_closure', 'partial_restriction', 'no_impact'
  specific_areas JSONB DEFAULT '[]', -- Array of specific areas within asset
  constraints JSONB DEFAULT '{}', -- Asset-specific constraints
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID NOT NULL,
  
  UNIQUE(work_request_id, asset_id, asset_type)
);

CREATE INDEX idx_work_request_assets_request ON work.work_request_asset_associations(work_request_id);
CREATE INDEX idx_work_request_assets_asset ON work.work_request_asset_associations(asset_id, asset_type);
CREATE INDEX idx_work_request_assets_type ON work.work_request_asset_associations(asset_type);
```

#### AssetTypeConfiguration Table (For Future Extensibility)
```sql
CREATE TABLE work.asset_type_configurations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL,
  asset_type VARCHAR(50) NOT NULL, -- 'stand', 'airfield', 'baggage', etc.
  asset_schema VARCHAR(50) NOT NULL, -- Database schema
  asset_table VARCHAR(50) NOT NULL, -- Table name
  display_name VARCHAR(100) NOT NULL, -- User-friendly name
  description TEXT,
  
  -- Form Configuration
  form_config JSONB NOT NULL, -- Form field configurations
  validation_rules JSONB DEFAULT '{}', -- Validation rules
  workflow_config JSONB DEFAULT '{}', -- Approval workflow configuration
  
  -- Integration Configuration
  api_endpoints JSONB DEFAULT '{}', -- API endpoints for this asset type
  permissions JSONB DEFAULT '[]', -- Required permissions
  
  -- Status and Metadata
  is_active BOOLEAN DEFAULT true,
  sort_order INTEGER DEFAULT 0,
  metadata JSONB DEFAULT '{}',
  
  -- Audit Fields
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID NOT NULL,
  updated_by UUID NOT NULL,
  
  UNIQUE(organization_id, asset_type)
);

CREATE INDEX idx_asset_type_configs_org ON work.asset_type_configurations(organization_id, is_active);
CREATE INDEX idx_asset_type_configs_type ON work.asset_type_configurations(asset_type, is_active);
```

#### WorkRequestStandAssociation Table
```sql
CREATE TABLE work.work_request_stand_associations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_request_id UUID NOT NULL REFERENCES work.work_requests(id) ON DELETE CASCADE,
  stand_id UUID NOT NULL, -- Reference to assets.stands.id
  stand_code VARCHAR(20) NOT NULL, -- Denormalized
  association_type VARCHAR(30) NOT NULL DEFAULT 'primary', -- 'primary', 'secondary', 'affected'
  impact_level VARCHAR(20) NOT NULL DEFAULT 'medium', -- 'full_closure', 'partial_restriction', 'no_impact'
  specific_areas JSONB DEFAULT '[]', -- Array of specific areas within stand
  constraints JSONB DEFAULT '{}', -- Stand-specific constraints
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID NOT NULL,
  
  UNIQUE(work_request_id, stand_id)
);

CREATE INDEX idx_work_request_stands_request ON work.work_request_stand_associations(work_request_id);
CREATE INDEX idx_work_request_stands_stand ON work.work_request_stand_associations(stand_id);
```

#### WorkRequestAttachment Table
```sql
CREATE TABLE work.work_request_attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_request_id UUID NOT NULL REFERENCES work.work_requests(id) ON DELETE CASCADE,
  file_name VARCHAR(255) NOT NULL,
  original_name VARCHAR(255) NOT NULL,
  file_size BIGINT NOT NULL,
  mime_type VARCHAR(100) NOT NULL,
  file_path TEXT NOT NULL,
  file_hash VARCHAR(64) NOT NULL, -- SHA-256 hash
  is_secure BOOLEAN DEFAULT false,
  encryption_key_id UUID, -- Reference to encryption key
  virus_scan_status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'clean', 'infected', 'error'
  virus_scan_date TIMESTAMP WITH TIME ZONE,
  uploaded_by UUID NOT NULL,
  uploaded_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  CONSTRAINT attachment_size_check CHECK (file_size > 0 AND file_size <= 104857600) -- 100MB max
);

CREATE INDEX idx_work_request_attachments_request ON work.work_request_attachments(work_request_id);
CREATE INDEX idx_work_request_attachments_scan ON work.work_request_attachments(virus_scan_status, virus_scan_date);
```

#### WorkRequestStatusHistory Table
```sql
CREATE TABLE work.work_request_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_request_id UUID NOT NULL REFERENCES work.work_requests(id) ON DELETE CASCADE,
  from_status VARCHAR(30),
  to_status VARCHAR(30) NOT NULL,
  reason TEXT,
  comments TEXT,
  changed_by UUID NOT NULL,
  changed_by_name VARCHAR(100) NOT NULL,
  changed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  metadata JSONB DEFAULT '{}',
  
  CONSTRAINT status_transition_check CHECK (from_status != to_status OR from_status IS NULL)
);

CREATE INDEX idx_work_request_status_history_request ON work.work_request_status_history(work_request_id, changed_at DESC);
CREATE INDEX idx_work_request_status_history_user ON work.work_request_status_history(changed_by, changed_at DESC);
```

#### WorkRequestApproval Table
```sql
CREATE TABLE work.work_request_approvals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_request_id UUID NOT NULL REFERENCES work.work_requests(id) ON DELETE CASCADE,
  approver_id UUID NOT NULL,
  approver_name VARCHAR(100) NOT NULL,
  approver_role VARCHAR(50) NOT NULL,
  approval_level VARCHAR(20) NOT NULL, -- 'standard', 'elevated', 'executive'
  sequence_order INTEGER NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected', 'delegated'
  decision_date TIMESTAMP WITH TIME ZONE,
  comments TEXT,
  conditions TEXT, -- Approval conditions
  delegated_to UUID, -- If delegated
  is_required BOOLEAN DEFAULT true,
  timeout_date TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(work_request_id, approver_id, sequence_order)
);

CREATE INDEX idx_work_request_approvals_request ON work.work_request_approvals(work_request_id, sequence_order);
CREATE INDEX idx_work_request_approvals_approver ON work.work_request_approvals(approver_id, status);
CREATE INDEX idx_work_request_approvals_timeout ON work.work_request_approvals(timeout_date) WHERE status = 'pending';
```

#### WorkRequestTemplate Table
```sql
CREATE TABLE work.work_request_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  category VARCHAR(50) NOT NULL,
  work_type VARCHAR(50) NOT NULL,
  
  -- Template Configuration
  template_data JSONB NOT NULL, -- Complete template structure
  default_values JSONB DEFAULT '{}', -- Default field values
  required_fields JSONB DEFAULT '[]', -- Array of required field names
  conditional_logic JSONB DEFAULT '{}', -- Field visibility/requirement logic
  
  -- Usage and Permissions
  is_active BOOLEAN DEFAULT true,
  is_public BOOLEAN DEFAULT false, -- Available to all users in org
  usage_count INTEGER DEFAULT 0,
  created_by UUID NOT NULL,
  allowed_roles JSONB DEFAULT '[]', -- Array of roles that can use template
  
  -- Audit Fields
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_by UUID NOT NULL,
  
  UNIQUE(organization_id, name)
);

CREATE INDEX idx_work_request_templates_org ON work.work_request_templates(organization_id, is_active);
CREATE INDEX idx_work_request_templates_category ON work.work_request_templates(category, is_active);
CREATE INDEX idx_work_request_templates_usage ON work.work_request_templates(usage_count DESC);
```

### Supporting Tables

#### WorkRequestComment Table
```sql
CREATE TABLE work.work_request_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_request_id UUID NOT NULL REFERENCES work.work_requests(id) ON DELETE CASCADE,
  parent_comment_id UUID REFERENCES work.work_request_comments(id),
  comment_text TEXT NOT NULL,
  comment_type VARCHAR(30) DEFAULT 'general', -- 'general', 'approval', 'technical', 'internal'
  is_internal BOOLEAN DEFAULT false,
  is_system_generated BOOLEAN DEFAULT false,
  mentioned_users JSONB DEFAULT '[]', -- Array of mentioned user IDs
  attachments JSONB DEFAULT '[]', -- Array of attachment references
  
  -- Audit Fields
  commented_by UUID NOT NULL,
  commenter_name VARCHAR(100) NOT NULL,
  commented_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  edited_at TIMESTAMP WITH TIME ZONE,
  edited_by UUID,
  
  CONSTRAINT comment_text_check CHECK (char_length(comment_text) >= 1 AND char_length(comment_text) <= 5000)
);

CREATE INDEX idx_work_request_comments_request ON work.work_request_comments(work_request_id, commented_at DESC);
CREATE INDEX idx_work_request_comments_user ON work.work_request_comments(commented_by, commented_at DESC);
CREATE INDEX idx_work_request_comments_parent ON work.work_request_comments(parent_comment_id);
```

#### WorkRequestNotification Table
```sql
CREATE TABLE work.work_request_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_request_id UUID NOT NULL REFERENCES work.work_requests(id) ON DELETE CASCADE,
  recipient_id UUID NOT NULL,
  recipient_email VARCHAR(255) NOT NULL,
  notification_type VARCHAR(50) NOT NULL, -- 'submitted', 'approved', 'rejected', 'comment_added', 'status_changed'
  subject VARCHAR(255) NOT NULL,
  body TEXT NOT NULL,
  priority VARCHAR(20) DEFAULT 'normal', -- 'high', 'normal', 'low'
  
  -- Delivery Status
  status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'sent', 'delivered', 'failed', 'bounced'
  sent_at TIMESTAMP WITH TIME ZONE,
  delivered_at TIMESTAMP WITH TIME ZONE,
  failed_at TIMESTAMP WITH TIME ZONE,
  retry_count INTEGER DEFAULT 0,
  error_message TEXT,
  
  -- Metadata
  channel VARCHAR(20) DEFAULT 'email', -- 'email', 'sms', 'push', 'in_app'
  template_id UUID,
  variables JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  CONSTRAINT notification_retry_check CHECK (retry_count >= 0 AND retry_count <= 5)
);

CREATE INDEX idx_work_request_notifications_request ON work.work_request_notifications(work_request_id);
CREATE INDEX idx_work_request_notifications_recipient ON work.work_request_notifications(recipient_id, status);
CREATE INDEX idx_work_request_notifications_status ON work.work_request_notifications(status, created_at);
CREATE INDEX idx_work_request_notifications_retry ON work.work_request_notifications(status, retry_count) WHERE status = 'failed';
```

## API Design

### Core Endpoints

#### Work Request CRUD Operations

```typescript
// GET /api/v1/work/requests
interface GetWorkRequestsRequest {
  page?: number;
  pageSize?: number;
  status?: WorkRequestStatus[];
  priority?: Priority[];
  workType?: WorkType[];
  assetId?: string;
  requestedBy?: string;
  dateRange?: {
    start: string;
    end: string;
  };
  sortBy?: 'createdAt' | 'priority' | 'requestedStartDate';
  sortOrder?: 'asc' | 'desc';
}

interface GetWorkRequestsResponse {
  success: boolean;
  data: {
    requests: WorkRequestSummary[];
    pagination: {
      page: number;
      pageSize: number;
      total: number;
      totalPages: number;
    };
  };
}

// POST /api/v1/work/requests
interface CreateWorkRequestRequest {
  assetId: string;
  workType: WorkType;
  category: WorkCategory;
  priority: Priority;
  urgency: Urgency;
  impactLevel: ImpactLevel;
  title: string;
  description: string;
  locationDetails?: string;
  safetyConsiderations?: string;
  requestedStartDate: string;
  requestedEndDate?: string;
  estimatedDurationMinutes?: number;
  deadline?: string;
  preferredTimeWindows?: TimeWindow[];
  blackoutPeriods?: BlackoutPeriod[];
  seasonalConstraints?: SeasonalConstraints;
  estimatedPersonnelCount?: number;
  requiredSkills?: string[];
  requiredEquipment?: string[];
  estimatedMaterialsCost?: number;
  budgetCode?: string;
  estimatedTotalCost?: number;
  costCenter?: string;
  purchaseOrderNumber?: string;
  vendorInformation?: VendorInformation;
  primaryContactId?: string;
  secondaryContactId?: string;
  regulatoryApprovalRequired?: boolean;
  regulatoryReference?: string;
  complianceNotes?: string;
  templateId?: string;
  metadata?: Record<string, any>;
}

interface CreateWorkRequestResponse {
  success: boolean;
  data: {
    workRequest: WorkRequestDetail;
    validationResults: ValidationResult[];
  };
}

// GET /api/v1/work/requests/:id
interface GetWorkRequestResponse {
  success: boolean;
  data: {
    workRequest: WorkRequestDetail;
    statusHistory: StatusHistoryEntry[];
    approvals: ApprovalEntry[];
    comments: CommentEntry[];
    attachments: AttachmentEntry[];
  };
}

// PUT /api/v1/work/requests/:id
interface UpdateWorkRequestRequest extends Partial<CreateWorkRequestRequest> {
  version: number;
  statusReason?: string;
}

interface UpdateWorkRequestResponse {
  success: boolean;
  data: {
    workRequest: WorkRequestDetail;
    validationResults: ValidationResult[];
  };
}

// DELETE /api/v1/work/requests/:id
interface DeleteWorkRequestResponse {
  success: boolean;
  data: {
    deletedAt: string;
    deletedBy: string;
  };
}
```

#### Assets Integration Endpoints

```typescript
// GET /api/v1/work/assets/stands
interface GetStandsForWorkRequestRequest {
  search?: string;
  terminal?: string;
  status?: StandStatus[];
  capabilities?: StandCapabilityFilter;
  includeMaintenanceSchedule?: boolean;
  page?: number;
  pageSize?: number;
}

interface GetStandsForWorkRequestResponse {
  success: boolean;
  data: {
    stands: StandSummaryForWorkRequest[];
    pagination: PaginationInfo;
  };
}

// GET /api/v1/work/assets/stands/:id
interface GetStandDetailsForWorkRequestResponse {
  success: boolean;
  data: {
    stand: StandDetailForWorkRequest;
    currentStatus: StandStatus;
    maintenanceSchedule: MaintenanceScheduleEntry[];
    capabilities: StandCapabilities;
    adjacentStands: AdjacentStandInfo[];
  };
}

// GET /api/v1/work/assets/stands/:id/availability
interface GetStandAvailabilityRequest {
  startDate: string;
  endDate: string;
  granularity?: 'hour' | 'day';
}

interface GetStandAvailabilityResponse {
  success: boolean;
  data: {
    availability: AvailabilitySlot[];
    conflicts: ConflictInfo[];
    recommendations: AvailabilityRecommendation[];
  };
}
```

#### Template Management Endpoints

```typescript
// GET /api/v1/work/templates
interface GetTemplatesRequest {
  category?: string;
  workType?: WorkType;
  isPublic?: boolean;
  page?: number;
  pageSize?: number;
}

interface GetTemplatesResponse {
  success: boolean;
  data: {
    templates: WorkRequestTemplate[];
    pagination: PaginationInfo;
  };
}

// POST /api/v1/work/templates
interface CreateTemplateRequest {
  name: string;
  description?: string;
  category: string;
  workType: WorkType;
  templateData: WorkRequestTemplateData;
  defaultValues?: Record<string, any>;
  requiredFields?: string[];
  conditionalLogic?: ConditionalLogic;
  isPublic?: boolean;
  allowedRoles?: string[];
}

interface CreateTemplateResponse {
  success: boolean;
  data: {
    template: WorkRequestTemplate;
  };
}

// POST /api/v1/work/templates/:id/apply
interface ApplyTemplateRequest {
  overrides?: Record<string, any>;
  assetId?: string;
}

interface ApplyTemplateResponse {
  success: boolean;
  data: {
    workRequestData: CreateWorkRequestRequest;
    appliedValues: Record<string, any>;
  };
}
```

#### Approval Workflow Endpoints

```typescript
// GET /api/v1/work/requests/:id/approvals
interface GetApprovalsResponse {
  success: boolean;
  data: {
    approvals: ApprovalEntry[];
    currentApprover: ApproverInfo;
    nextApprovers: ApproverInfo[];
    approvalChain: ApprovalChainEntry[];
  };
}

// POST /api/v1/work/requests/:id/approve
interface ApproveWorkRequestRequest {
  decision: 'approve' | 'reject' | 'delegate';
  comments?: string;
  conditions?: string;
  delegatedTo?: string;
}

interface ApproveWorkRequestResponse {
  success: boolean;
  data: {
    approval: ApprovalEntry;
    nextApprover?: ApproverInfo;
    workRequestStatus: WorkRequestStatus;
  };
}

// POST /api/v1/work/requests/:id/submit
interface SubmitWorkRequestResponse {
  success: boolean;
  data: {
    workRequest: WorkRequestDetail;
    approvalChain: ApprovalChainEntry[];
    estimatedApprovalTime: number; // in hours
  };
}
```

#### File Upload Endpoints

```typescript
// POST /api/v1/work/requests/:id/attachments
interface UploadAttachmentRequest {
  file: File;
  description?: string;
  isSecure?: boolean;
}

interface UploadAttachmentResponse {
  success: boolean;
  data: {
    attachment: AttachmentEntry;
    virusScanStatus: VirusScanStatus;
  };
}

// GET /api/v1/work/requests/:id/attachments/:attachmentId
interface DownloadAttachmentResponse {
  success: boolean;
  data: {
    url: string;
    expiresAt: string;
  };
}

// DELETE /api/v1/work/requests/:id/attachments/:attachmentId
interface DeleteAttachmentResponse {
  success: boolean;
  data: {
    deletedAt: string;
  };
}
```

#### Validation and Analytics Endpoints

```typescript
// POST /api/v1/work/requests/validate
interface ValidateWorkRequestRequest {
  workRequestData: CreateWorkRequestRequest;
  validationLevel?: 'basic' | 'standard' | 'comprehensive';
}

interface ValidateWorkRequestResponse {
  success: boolean;
  data: {
    isValid: boolean;
    validationResults: ValidationResult[];
    warnings: ValidationWarning[];
    suggestions: ValidationSuggestion[];
  };
}

// GET /api/v1/work/analytics/dashboard
interface GetAnalyticsDashboardResponse {
  success: boolean;
  data: {
    summary: {
      totalRequests: number;
      pendingApproval: number;
      inProgress: number;
      completed: number;
      averageApprovalTime: number;
    };
    trends: {
      requestsByType: ChartData[];
      requestsByPriority: ChartData[];
      completionTrends: ChartData[];
    };
    performance: {
      averageProcessingTime: number;
      approvalBottlenecks: BottleneckInfo[];
      standUtilization: StandUtilizationInfo[];
    };
  };
}
```

## Frontend Implementation

### Form Architecture

#### React Component Structure
```typescript
// Main form component
interface WorkRequestFormProps {
  mode: 'create' | 'edit' | 'view';
  initialData?: WorkRequestData;
  onSubmit: (data: CreateWorkRequestRequest) => Promise<void>;
  onSave: (data: CreateWorkRequestRequest) => Promise<void>;
  onCancel: () => void;
}

const WorkRequestForm: React.FC<WorkRequestFormProps> = ({
  mode,
  initialData,
  onSubmit,
  onSave,
  onCancel
}) => {
  const form = useForm<CreateWorkRequestRequest>({
    resolver: zodResolver(workRequestSchema),
    defaultValues: initialData || getDefaultValues(),
    mode: 'onChange'
  });

  const { data: stands, isLoading: standsLoading } = useStands();
  const { data: templates } = useTemplates();
  const { mutate: validateRequest } = useValidateWorkRequest();
  const { mutate: saveAsDraft } = useSaveWorkRequestDraft();

  return (
    <FormProvider {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="work-request-form">
        <FormProgress currentStep={currentStep} totalSteps={6} />
        
        <div className="form-sections">
          <StandSelectionSection />
          <RequestDetailsSection />
          <SchedulingSection />
          <ResourcesSection />
          <ApprovalSection />
          <ReviewSection />
        </div>
        
        <FormActions
          mode={mode}
          onSave={onSave}
          onCancel={onCancel}
          isValid={form.formState.isValid}
          isDirty={form.formState.isDirty}
        />
      </form>
    </FormProvider>
  );
};
```

#### Stand Selection Component
```typescript
interface StandSelectionSectionProps {
  onStandSelect: (stand: StandSummary) => void;
  selectedStands: StandSummary[];
  multiSelect?: boolean;
}

const StandSelectionSection: React.FC<StandSelectionSectionProps> = ({
  onStandSelect,
  selectedStands,
  multiSelect = false
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [filters, setFilters] = useState<StandFilters>({});
  
  const { data: stands, isLoading, error } = useStands({
    search: searchTerm,
    ...filters,
    includeMaintenanceSchedule: true
  });

  const { data: standDetails } = useStandDetails(
    selectedStands[0]?.id,
    { enabled: selectedStands.length > 0 }
  );

  return (
    <div className="stand-selection-section">
      <div className="section-header">
        <h3>Select Stand(s)</h3>
        <p>Choose the stand(s) that require work</p>
      </div>
      
      <div className="stand-search">
        <SearchInput
          value={searchTerm}
          onChange={setSearchTerm}
          placeholder="Search stands by code, name, or terminal..."
          debounceMs={300}
        />
        
        <StandFilters
          filters={filters}
          onChange={setFilters}
          availableTerminals={availableTerminals}
        />
      </div>
      
      <div className="stands-grid">
        {isLoading ? (
          <StandSelectionSkeleton />
        ) : (
          stands?.map(stand => (
            <StandCard
              key={stand.id}
              stand={stand}
              selected={selectedStands.some(s => s.id === stand.id)}
              onSelect={onStandSelect}
              showMaintenanceStatus
              showCapabilities
            />
          ))
        )}
      </div>
      
      {selectedStands.length > 0 && (
        <SelectedStandsPreview
          stands={selectedStands}
          onRemove={onStandRemove}
          standDetails={standDetails}
        />
      )}
    </div>
  );
};
```

#### Form Validation System
```typescript
// Zod schema for work request validation
const workRequestSchema = z.object({
  assetId: z.string().uuid('Please select a valid stand'),
  workType: z.enum(['maintenance', 'inspection', 'repair', 'modification', 'emergency']),
  category: z.enum(['routine', 'corrective', 'preventive', 'emergency']),
  priority: z.enum(['critical', 'high', 'medium', 'low']),
  urgency: z.enum(['immediate', 'scheduled', 'routine']),
  impactLevel: z.enum(['full_closure', 'partial_restriction', 'no_impact']),
  title: z.string()
    .min(5, 'Title must be at least 5 characters')
    .max(200, 'Title cannot exceed 200 characters'),
  description: z.string()
    .min(20, 'Description must be at least 20 characters')
    .max(5000, 'Description cannot exceed 5000 characters'),
  requestedStartDate: z.string()
    .datetime('Please select a valid start date')
    .refine(date => new Date(date) > new Date(), 'Start date must be in the future'),
  requestedEndDate: z.string()
    .datetime('Please select a valid end date')
    .optional(),
  estimatedDurationMinutes: z.number()
    .min(15, 'Minimum duration is 15 minutes')
    .max(10080, 'Maximum duration is 7 days')
    .optional(),
  budgetCode: z.string()
    .regex(/^[A-Z0-9-]+$/, 'Budget code must contain only uppercase letters, numbers, and hyphens')
    .optional(),
  estimatedTotalCost: z.number()
    .min(0, 'Cost cannot be negative')
    .max(1000000, 'Cost cannot exceed $1,000,000')
    .optional(),
  requiredSkills: z.array(z.string()).optional(),
  requiredEquipment: z.array(z.string()).optional(),
  regulatoryApprovalRequired: z.boolean().optional(),
  safetyConsiderations: z.string()
    .max(2000, 'Safety considerations cannot exceed 2000 characters')
    .optional(),
}).refine(data => {
  if (data.requestedEndDate) {
    return new Date(data.requestedEndDate) > new Date(data.requestedStartDate);
  }
  return true;
}, {
  message: 'End date must be after start date',
  path: ['requestedEndDate']
}).refine(data => {
  if (data.priority === 'critical' && data.urgency === 'routine') {
    return false;
  }
  return true;
}, {
  message: 'Critical priority requests cannot have routine urgency',
  path: ['urgency']
});

// Custom validation hooks
const useFormValidation = () => {
  const { mutate: validateRequest } = useMutation({
    mutationFn: async (data: CreateWorkRequestRequest) => {
      const response = await fetch('/api/v1/work/requests/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ workRequestData: data })
      });
      return response.json();
    },
    onSuccess: (result) => {
      // Handle validation results
      if (!result.data.isValid) {
        // Show validation errors
        result.data.validationResults.forEach(error => {
          form.setError(error.field, { message: error.message });
        });
      }
    }
  });

  return { validateRequest };
};
```

### Real-time Features

#### Auto-save Implementation
```typescript
const useAutoSave = (formData: CreateWorkRequestRequest) => {
  const { mutate: saveAsDraft } = useMutation({
    mutationFn: async (data: CreateWorkRequestRequest) => {
      const response = await fetch('/api/v1/work/requests/drafts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      return response.json();
    }
  });

  const debouncedSave = useCallback(
    debounce((data: CreateWorkRequestRequest) => {
      if (Object.keys(data).length > 0) {
        saveAsDraft(data);
      }
    }, 2000),
    [saveAsDraft]
  );

  useEffect(() => {
    debouncedSave(formData);
  }, [formData, debouncedSave]);

  return { saveAsDraft };
};
```

#### Real-time Validation
```typescript
const useRealtimeValidation = () => {
  const [validationResults, setValidationResults] = useState<ValidationResult[]>([]);
  const [isValidating, setIsValidating] = useState(false);

  const validateField = useCallback(
    debounce(async (fieldName: string, value: any) => {
      setIsValidating(true);
      try {
        const response = await fetch('/api/v1/work/requests/validate-field', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ field: fieldName, value })
        });
        const result = await response.json();
        
        setValidationResults(prev => ({
          ...prev,
          [fieldName]: result.data.validationResult
        }));
      } catch (error) {
        console.error('Validation error:', error);
      } finally {
        setIsValidating(false);
      }
    }, 500),
    []
  );

  return { validateField, validationResults, isValidating };
};
```

## Security Implementation

### Authentication and Authorization

#### JWT Token Validation
```typescript
interface JWTPayload {
  userId: string;
  organizationId: string;
  permissions: string[];
  role: string;
  exp: number;
  iat: number;
}

const authMiddleware = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'Authentication token required'
      });
    }

    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;
    
    // Validate token expiration
    if (payload.exp < Date.now() / 1000) {
      return res.status(401).json({
        success: false,
        error: 'Token expired'
      });
    }

    // Attach user context to request
    req.user = {
      id: payload.userId,
      organizationId: payload.organizationId,
      permissions: payload.permissions,
      role: payload.role
    };

    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      error: 'Invalid authentication token'
    });
  }
};
```

#### Role-Based Access Control
```typescript
const workRequestPermissions = {
  CREATE: 'work_request.create',
  READ: 'work_request.read',
  UPDATE: 'work_request.update',
  DELETE: 'work_request.delete',
  APPROVE: 'work_request.approve',
  ADMIN: 'work_request.admin'
};

const requirePermission = (permission: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
    }

    const hasPermission = req.user.permissions.includes(permission) ||
                         req.user.permissions.includes('admin') ||
                         req.user.role === 'admin';

    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        error: 'Insufficient permissions'
      });
    }

    next();
  };
};

// Usage in routes
router.post('/requests', 
  authMiddleware, 
  requirePermission(workRequestPermissions.CREATE),
  createWorkRequest
);
```

### Data Encryption

#### Field-Level Encryption
```typescript
import crypto from 'crypto';

class FieldEncryption {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;
  private readonly ivLength = 16;
  private readonly tagLength = 16;

  constructor(private readonly encryptionKey: string) {}

  encrypt(data: string): EncryptedField {
    const iv = crypto.randomBytes(this.ivLength);
    const cipher = crypto.createCipher(this.algorithm, this.encryptionKey);
    cipher.setAAD(Buffer.from('work-request-data'));

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const tag = cipher.getAuthTag();

    return {
      data: encrypted,
      iv: iv.toString('hex'),
      tag: tag.toString('hex'),
      algorithm: this.algorithm
    };
  }

  decrypt(encryptedField: EncryptedField): string {
    const decipher = crypto.createDecipher(
      encryptedField.algorithm,
      this.encryptionKey
    );
    
    decipher.setAAD(Buffer.from('work-request-data'));
    decipher.setAuthTag(Buffer.from(encryptedField.tag, 'hex'));

    let decrypted = decipher.update(encryptedField.data, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}

// Usage in service layer
const encryptSensitiveFields = (workRequest: CreateWorkRequestRequest) => {
  const encryption = new FieldEncryption(process.env.FIELD_ENCRYPTION_KEY!);
  
  const sensitiveFields = ['safetyConsiderations', 'complianceNotes'];
  const encrypted = { ...workRequest };

  sensitiveFields.forEach(field => {
    if (encrypted[field]) {
      encrypted[field] = encryption.encrypt(encrypted[field]);
    }
  });

  return encrypted;
};
```

### File Upload Security

#### Virus Scanning Integration
```typescript
import { ClamAV } from 'clamscan';

class VirusScanService {
  private clamav: ClamAV;

  constructor() {
    this.clamav = new ClamAV({
      removeInfected: true,
      quarantineInfected: process.env.QUARANTINE_PATH,
      scanLog: process.env.SCAN_LOG_PATH,
      debugMode: process.env.NODE_ENV === 'development'
    });
  }

  async scanFile(filePath: string): Promise<VirusScanResult> {
    try {
      const result = await this.clamav.scanFile(filePath);
      
      return {
        isClean: result.isInfected === false,
        virusName: result.viruses?.[0] || null,
        scanDate: new Date(),
        scanEngine: 'ClamAV',
        engineVersion: await this.clamav.getVersion()
      };
    } catch (error) {
      console.error('Virus scan error:', error);
      return {
        isClean: false,
        virusName: null,
        scanDate: new Date(),
        scanEngine: 'ClamAV',
        engineVersion: null,
        error: error.message
      };
    }
  }
}

// File upload middleware with virus scanning
const uploadMiddleware = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, process.env.TEMP_UPLOAD_PATH);
    },
    filename: (req, file, cb) => {
      const uniqueName = `${uuidv4()}-${file.originalname}`;
      cb(null, uniqueName);
    }
  }),
  limits: {
    fileSize: 100 * 1024 * 1024, // 100MB
    files: 10
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = [
      'application/pdf',
      'image/jpeg',
      'image/png',
      'image/gif',
      'text/plain',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];

    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('File type not allowed'));
    }
  }
});

const processFileUpload = async (req: Request, res: Response) => {
  const virusScanService = new VirusScanService();
  const uploadedFiles = req.files as Express.Multer.File[];

  for (const file of uploadedFiles) {
    // Scan for viruses
    const scanResult = await virusScanService.scanFile(file.path);
    
    if (!scanResult.isClean) {
      // Remove infected file
      fs.unlinkSync(file.path);
      
      return res.status(400).json({
        success: false,
        error: 'File contains virus',
        details: scanResult.virusName
      });
    }

    // Move to secure storage
    const securePath = await moveToSecureStorage(file);
    
    // Save attachment record
    await saveAttachmentRecord({
      workRequestId: req.params.id,
      fileName: securePath,
      originalName: file.originalname,
      fileSize: file.size,
      mimeType: file.mimetype,
      virusScanResult: scanResult,
      uploadedBy: req.user.id
    });
  }

  res.json({
    success: true,
    data: {
      attachments: uploadedFiles.map(file => ({
        id: file.filename,
        originalName: file.originalname,
        size: file.size,
        mimeType: file.mimetype
      }))
    }
  });
};
```

## Performance Optimization

### Database Optimization

#### Query Optimization
```sql
-- Optimized query for work request listing with filters
EXPLAIN ANALYZE
SELECT 
  wr.id,
  wr.title,
  wr.work_type,
  wr.priority,
  wr.status,
  wr.requested_start_date,
  wr.asset_code,
  wr.requestor_name,
  wr.created_at,
  COUNT(wra.id) as approval_count,
  COUNT(wrc.id) as comment_count
FROM work.work_requests wr
LEFT JOIN work.work_request_approvals wra ON wr.id = wra.work_request_id
LEFT JOIN work.work_request_comments wrc ON wr.id = wrc.work_request_id
WHERE 
  wr.organization_id = $1
  AND wr.status = ANY($2)
  AND wr.requested_start_date >= $3
  AND wr.requested_start_date <= $4
GROUP BY wr.id
ORDER BY wr.created_at DESC
LIMIT $5 OFFSET $6;

-- Materialized view for dashboard analytics
CREATE MATERIALIZED VIEW work.work_request_analytics AS
SELECT 
  organization_id,
  DATE_TRUNC('day', created_at) as date,
  work_type,
  priority,
  status,
  COUNT(*) as request_count,
  AVG(EXTRACT(EPOCH FROM (completed_date - created_at))/3600) as avg_completion_hours,
  AVG(estimated_total_cost) as avg_cost
FROM work.work_requests
WHERE created_at >= NOW() - INTERVAL '1 year'
GROUP BY organization_id, DATE_TRUNC('day', created_at), work_type, priority, status;

-- Refresh materialized view daily
CREATE OR REPLACE FUNCTION refresh_work_request_analytics()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY work.work_request_analytics;
END;
$$ LANGUAGE plpgsql;

-- Schedule refresh
SELECT cron.schedule('refresh-work-analytics', '0 2 * * *', 'SELECT refresh_work_request_analytics()');
```

#### Connection Pooling
```typescript
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20, // Maximum number of connections
  idleTimeoutMillis: 30000, // Close idle connections after 30 seconds
  connectionTimeoutMillis: 2000, // Return error after 2 seconds if no connection available
  maxUses: 7500, // Close connection after 7500 uses
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Connection health check
const checkDatabaseHealth = async (): Promise<boolean> => {
  try {
    const client = await pool.connect();
    await client.query('SELECT 1');
    client.release();
    return true;
  } catch (error) {
    console.error('Database health check failed:', error);
    return false;
  }
};
```

### Caching Strategy

#### Redis Implementation
```typescript
import Redis from 'ioredis';

class CacheService {
  private redis: Redis;

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
      lazyConnect: true
    });
  }

  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await this.redis.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set(key: string, value: any, ttlSeconds: number = 3600): Promise<void> {
    try {
      await this.redis.setex(key, ttlSeconds, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  async invalidate(pattern: string): Promise<void> {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    } catch (error) {
      console.error('Cache invalidation error:', error);
    }
  }
}

// Cache middleware for API endpoints
const cacheMiddleware = (ttlSeconds: number = 300) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const cacheKey = `work-request:${req.method}:${req.originalUrl}:${req.user?.organizationId}`;
    const cacheService = new CacheService();

    try {
      const cachedData = await cacheService.get(cacheKey);
      if (cachedData) {
        return res.json(cachedData);
      }

      // Override res.json to cache the response
      const originalJson = res.json;
      res.json = function(data: any) {
        if (res.statusCode === 200) {
          cacheService.set(cacheKey, data, ttlSeconds);
        }
        return originalJson.call(this, data);
      };

      next();
    } catch (error) {
      console.error('Cache middleware error:', error);
      next();
    }
  };
};
```

## Testing Strategy

### Unit Testing

#### Service Layer Tests
```typescript
import { WorkRequestService } from '../services/WorkRequestService';
import { MockPrismaClient } from '../__mocks__/prisma';
import { MockCacheService } from '../__mocks__/cache';

describe('WorkRequestService', () => {
  let service: WorkRequestService;
  let mockPrisma: MockPrismaClient;
  let mockCache: MockCacheService;

  beforeEach(() => {
    mockPrisma = new MockPrismaClient();
    mockCache = new MockCacheService();
    service = new WorkRequestService(mockPrisma, mockCache);
  });

  describe('createWorkRequest', () => {
    it('should create a work request with valid data', async () => {
      const requestData = {
        assetId: 'stand-123',
        workType: 'maintenance',
        title: 'Routine maintenance',
        description: 'Monthly safety inspection',
        requestedStartDate: '2024-02-01T08:00:00Z',
        priority: 'medium',
        urgency: 'scheduled',
        impactLevel: 'partial_restriction'
      };

      const mockStand = {
        id: 'stand-123',
        code: 'A01',
        name: 'Stand A01',
        organizationId: 'org-123'
      };

      mockPrisma.stand.findUnique.mockResolvedValue(mockStand);
      mockPrisma.workRequest.create.mockResolvedValue({
        id: 'request-123',
        ...requestData,
        status: 'draft'
      });

      const result = await service.createWorkRequest(
        'org-123',
        'user-123',
        requestData
      );

      expect(result.success).toBe(true);
      expect(result.data.workRequest.id).toBe('request-123');
      expect(mockPrisma.workRequest.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          assetId: 'stand-123',
          title: 'Routine maintenance',
          status: 'draft'
        })
      });
    });

    it('should validate stand exists and belongs to organization', async () => {
      const requestData = {
        assetId: 'invalid-stand',
        workType: 'maintenance',
        title: 'Test request',
        description: 'Test description',
        requestedStartDate: '2024-02-01T08:00:00Z',
        priority: 'medium',
        urgency: 'scheduled',
        impactLevel: 'partial_restriction'
      };

      mockPrisma.stand.findUnique.mockResolvedValue(null);

      const result = await service.createWorkRequest(
        'org-123',
        'user-123',
        requestData
      );

      expect(result.success).toBe(false);
      expect(result.error).toContain('Stand not found');
    });

    it('should handle database errors gracefully', async () => {
      const requestData = {
        assetId: 'stand-123',
        workType: 'maintenance',
        title: 'Test request',
        description: 'Test description',
        requestedStartDate: '2024-02-01T08:00:00Z',
        priority: 'medium',
        urgency: 'scheduled',
        impactLevel: 'partial_restriction'
      };

      mockPrisma.stand.findUnique.mockRejectedValue(new Error('Database error'));

      const result = await service.createWorkRequest(
        'org-123',
        'user-123',
        requestData
      );

      expect(result.success).toBe(false);
      expect(result.error).toContain('Database error');
    });
  });

  describe('validateWorkRequest', () => {
    it('should validate required fields', async () => {
      const invalidData = {
        assetId: '',
        workType: 'invalid-type',
        title: 'x', // Too short
        description: 'y', // Too short
        requestedStartDate: '2020-01-01T00:00:00Z', // Past date
        priority: 'invalid-priority',
        urgency: 'invalid-urgency',
        impactLevel: 'invalid-impact'
      };

      const result = await service.validateWorkRequest(invalidData);

      expect(result.isValid).toBe(false);
      expect(result.validationResults).toHaveLength(8);
      expect(result.validationResults[0].field).toBe('assetId');
      expect(result.validationResults[0].message).toContain('required');
    });

    it('should validate business rules', async () => {
      const invalidData = {
        assetId: 'stand-123',
        workType: 'maintenance',
        title: 'Critical routine maintenance',
        description: 'This is a critical priority request with routine urgency',
        requestedStartDate: '2024-02-01T08:00:00Z',
        requestedEndDate: '2024-01-31T08:00:00Z', // End before start
        priority: 'critical',
        urgency: 'routine', // Invalid combination
        impactLevel: 'no_impact'
      };

      const result = await service.validateWorkRequest(invalidData);

      expect(result.isValid).toBe(false);
      expect(result.validationResults.some(r => 
        r.message.includes('End date must be after start date')
      )).toBe(true);
      expect(result.validationResults.some(r => 
        r.message.includes('Critical priority requests cannot have routine urgency')
      )).toBe(true);
    });
  });
});
```

### Integration Testing

#### API Endpoint Tests
```typescript
import request from 'supertest';
import { app } from '../app';
import { setupTestDatabase, cleanupTestDatabase } from '../test-utils/database';

describe('Work Request API', () => {
  let authToken: string;
  let organizationId: string;
  let standId: string;

  beforeAll(async () => {
    await setupTestDatabase();
    
    // Create test organization and user
    const authResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'testpassword'
      });

    authToken = authResponse.body.token;
    organizationId = authResponse.body.user.organizationId;

    // Create test stand
    const standResponse = await request(app)
      .post('/api/v1/assets/stands')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        code: 'TEST01',
        name: 'Test Stand 01',
        terminal: 'T1',
        status: 'operational'
      });

    standId = standResponse.body.data.stand.id;
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  describe('POST /api/v1/work/requests', () => {
    it('should create a work request with valid data', async () => {
      const requestData = {
        assetId: standId,
        workType: 'maintenance',
        category: 'routine',
        priority: 'medium',
        urgency: 'scheduled',
        impactLevel: 'partial_restriction',
        title: 'Monthly safety inspection',
        description: 'Routine monthly safety inspection of stand equipment and markings',
        requestedStartDate: '2024-02-15T08:00:00Z',
        requestedEndDate: '2024-02-15T12:00:00Z',
        estimatedDurationMinutes: 240,
        budgetCode: 'MAINT-2024-001',
        estimatedTotalCost: 2500.00
      };

      const response = await request(app)
        .post('/api/v1/work/requests')
        .set('Authorization', `Bearer ${authToken}`)
        .send(requestData);

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data.workRequest.id).toBeDefined();
      expect(response.body.data.workRequest.title).toBe(requestData.title);
      expect(response.body.data.workRequest.status).toBe('draft');
    });

    it('should return validation errors for invalid data', async () => {
      const invalidData = {
        assetId: 'invalid-id',
        workType: 'invalid-type',
        title: 'x',
        description: 'y',
        requestedStartDate: '2020-01-01T00:00:00Z',
        priority: 'invalid-priority'
      };

      const response = await request(app)
        .post('/api/v1/work/requests')
        .set('Authorization', `Bearer ${authToken}`)
        .send(invalidData);

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toContain('validation');
      expect(response.body.details).toBeInstanceOf(Array);
      expect(response.body.details.length).toBeGreaterThan(0);
    });

    it('should require authentication', async () => {
      const response = await request(app)
        .post('/api/v1/work/requests')
        .send({
          assetId: standId,
          workType: 'maintenance',
          title: 'Test request',
          description: 'Test description'
        });

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toContain('Authentication');
    });
  });

  describe('GET /api/v1/work/requests', () => {
    let workRequestId: string;

    beforeEach(async () => {
      // Create a test work request
      const createResponse = await request(app)
        .post('/api/v1/work/requests')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          assetId: standId,
          workType: 'maintenance',
          category: 'routine',
          priority: 'medium',
          urgency: 'scheduled',
          impactLevel: 'partial_restriction',
          title: 'Test maintenance request',
          description: 'Test description for maintenance request',
          requestedStartDate: '2024-02-15T08:00:00Z'
        });

      workRequestId = createResponse.body.data.workRequest.id;
    });

    it('should return paginated work requests', async () => {
      const response = await request(app)
        .get('/api/v1/work/requests')
        .set('Authorization', `Bearer ${authToken}`)
        .query({
          page: 1,
          pageSize: 10
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.requests).toBeInstanceOf(Array);
      expect(response.body.data.pagination).toMatchObject({
        page: 1,
        pageSize: 10,
        total: expect.any(Number),
        totalPages: expect.any(Number)
      });
    });

    it('should filter work requests by status', async () => {
      const response = await request(app)
        .get('/api/v1/work/requests')
        .set('Authorization', `Bearer ${authToken}`)
        .query({
          status: ['draft', 'submitted']
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.requests.every(r => 
        ['draft', 'submitted'].includes(r.status)
      )).toBe(true);
    });

    it('should filter work requests by asset', async () => {
      const response = await request(app)
        .get('/api/v1/work/requests')
        .set('Authorization', `Bearer ${authToken}`)
        .query({
          assetId: standId
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.requests.every(r => 
        r.assetId === standId
      )).toBe(true);
    });
  });

  describe('GET /api/v1/work/requests/:id', () => {
    let workRequestId: string;

    beforeEach(async () => {
      const createResponse = await request(app)
        .post('/api/v1/work/requests')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          assetId: standId,
          workType: 'maintenance',
          category: 'routine',
          priority: 'medium',
          urgency: 'scheduled',
          impactLevel: 'partial_restriction',
          title: 'Test maintenance request',
          description: 'Test description for maintenance request',
          requestedStartDate: '2024-02-15T08:00:00Z'
        });

      workRequestId = createResponse.body.data.workRequest.id;
    });

    it('should return work request details', async () => {
      const response = await request(app)
        .get(`/api/v1/work/requests/${workRequestId}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.workRequest.id).toBe(workRequestId);
      expect(response.body.data.workRequest.title).toBe('Test maintenance request');
      expect(response.body.data.statusHistory).toBeInstanceOf(Array);
      expect(response.body.data.approvals).toBeInstanceOf(Array);
      expect(response.body.data.comments).toBeInstanceOf(Array);
      expect(response.body.data.attachments).toBeInstanceOf(Array);
    });

    it('should return 404 for non-existent work request', async () => {
      const response = await request(app)
        .get('/api/v1/work/requests/non-existent-id')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(404);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toContain('not found');
    });
  });
});
```

### End-to-End Testing

#### Form Interaction Tests
```typescript
import { test, expect } from '@playwright/test';

test.describe('Work Request Form', () => {
  test.beforeEach(async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[data-testid="email"]', 'test@example.com');
    await page.fill('[data-testid="password"]', 'testpassword');
    await page.click('[data-testid="login-button"]');
    
    // Navigate to work request form
    await page.goto('/work/requests/new');
  });

  test('should create a work request successfully', async ({ page }) => {
    // Step 1: Select stand
    await page.click('[data-testid="stand-search"]');
    await page.fill('[data-testid="stand-search"]', 'A01');
    await page.click('[data-testid="stand-option-A01"]');
    
    // Verify stand details are displayed
    await expect(page.locator('[data-testid="selected-stand-details"]')).toBeVisible();
    await expect(page.locator('[data-testid="stand-code"]')).toHaveText('A01');
    
    // Step 2: Fill request details
    await page.selectOption('[data-testid="work-type"]', 'maintenance');
    await page.selectOption('[data-testid="priority"]', 'medium');
    await page.selectOption('[data-testid="urgency"]', 'scheduled');
    await page.selectOption('[data-testid="impact-level"]', 'partial_restriction');
    
    await page.fill('[data-testid="title"]', 'Monthly safety inspection');
    await page.fill('[data-testid="description"]', 'Routine monthly safety inspection of stand equipment and markings');
    
    // Step 3: Set scheduling
    await page.fill('[data-testid="requested-start-date"]', '2024-02-15T08:00');
    await page.fill('[data-testid="requested-end-date"]', '2024-02-15T12:00');
    await page.fill('[data-testid="estimated-duration"]', '240');
    
    // Step 4: Add resources
    await page.fill('[data-testid="budget-code"]', 'MAINT-2024-001');
    await page.fill('[data-testid="estimated-cost"]', '2500.00');
    
    // Step 5: Review and submit
    await page.click('[data-testid="next-button"]');
    await page.click('[data-testid="next-button"]');
    await page.click('[data-testid="next-button"]');
    await page.click('[data-testid="next-button"]');
    
    // Verify review section
    await expect(page.locator('[data-testid="review-title"]')).toHaveText('Monthly safety inspection');
    await expect(page.locator('[data-testid="review-stand"]')).toHaveText('A01');
    await expect(page.locator('[data-testid="review-cost"]')).toHaveText('$2,500.00');
    
    // Submit
    await page.click('[data-testid="submit-button"]');
    
    // Verify success
    await expect(page.locator('[data-testid="success-message"]')).toBeVisible();
    await expect(page.locator('[data-testid="work-request-id"]')).toBeVisible();
  });

  test('should validate form fields', async ({ page }) => {
    // Try to submit without required fields
    await page.click('[data-testid="submit-button"]');
    
    // Verify validation errors
    await expect(page.locator('[data-testid="error-asset-id"]')).toHaveText('Please select a stand');
    await expect(page.locator('[data-testid="error-title"]')).toHaveText('Title is required');
    await expect(page.locator('[data-testid="error-description"]')).toHaveText('Description is required');
    
    // Fill with invalid data
    await page.fill('[data-testid="title"]', 'x'); // Too short
    await page.fill('[data-testid="description"]', 'y'); // Too short
    await page.fill('[data-testid="requested-start-date"]', '2020-01-01T00:00'); // Past date
    
    // Verify real-time validation
    await expect(page.locator('[data-testid="error-title"]')).toHaveText('Title must be at least 5 characters');
    await expect(page.locator('[data-testid="error-description"]')).toHaveText('Description must be at least 20 characters');
    await expect(page.locator('[data-testid="error-start-date"]')).toHaveText('Start date must be in the future');
  });

  test('should auto-save draft', async ({ page }) => {
    // Fill some fields
    await page.fill('[data-testid="title"]', 'Draft work request');
    await page.fill('[data-testid="description"]', 'This is a draft work request for testing auto-save functionality');
    
    // Wait for auto-save
    await page.waitForTimeout(3000);
    
    // Verify draft saved indicator
    await expect(page.locator('[data-testid="draft-saved"]')).toBeVisible();
    
    // Refresh page
    await page.reload();
    
    // Verify draft is restored
    await expect(page.locator('[data-testid="title"]')).toHaveValue('Draft work request');
    await expect(page.locator('[data-testid="description"]')).toHaveValue('This is a draft work request for testing auto-save functionality');
  });

  test('should handle file uploads', async ({ page }) => {
    // Navigate to attachments section
    await page.click('[data-testid="attachments-tab"]');
    
    // Upload file
    const fileInput = page.locator('[data-testid="file-upload"]');
    await fileInput.setInputFiles('test-files/sample-document.pdf');
    
    // Verify upload progress
    await expect(page.locator('[data-testid="upload-progress"]')).toBeVisible();
    
    // Verify file appears in list
    await expect(page.locator('[data-testid="attachment-list"]')).toContainText('sample-document.pdf');
    
    // Verify file size and type
    await expect(page.locator('[data-testid="file-info"]')).toContainText('PDF');
    await expect(page.locator('[data-testid="file-size"]')).toContainText('KB');
    
    // Test file removal
    await page.click('[data-testid="remove-attachment"]');
    await expect(page.locator('[data-testid="attachment-list"]')).not.toContainText('sample-document.pdf');
  });
});
```

## Repository Table View Implementation

### Overview

The repository table view provides users with a comprehensive interface to view, filter, sort, and manage their submitted work requests. This view serves as the primary dashboard for tracking request status and accessing request details.

### Frontend Implementation

#### Repository Table Component
```typescript
interface WorkRequestRepositoryProps {
  userId?: string; // If provided, shows only user's requests
  showAllRequests?: boolean; // Admin view to see all requests
  assetType?: string; // Filter by asset type
  defaultFilters?: WorkRequestFilters;
}

const WorkRequestRepository: React.FC<WorkRequestRepositoryProps> = ({
  userId,
  showAllRequests = false,
  assetType,
  defaultFilters = {}
}) => {
  const [filters, setFilters] = useState<WorkRequestFilters>({
    status: [],
    priority: [],
    workType: [],
    dateRange: null,
    assetType: assetType ? [assetType] : [],
    requestedBy: showAllRequests ? undefined : userId,
    ...defaultFilters
  });
  
  const [sorting, setSorting] = useState<SortConfig>({
    field: 'submissionDate',
    direction: 'desc'
  });
  
  const [pagination, setPagination] = useState<PaginationConfig>({
    page: 1,
    pageSize: 25
  });

  const { data, isLoading, error, refetch } = useWorkRequests({
    filters,
    sorting,
    pagination
  });

  const { mutate: updateStatus } = useUpdateWorkRequestStatus();
  const { mutate: deleteRequest } = useDeleteWorkRequest();

  return (
    <div className="work-request-repository">
      <div className="repository-header">
        <div className="header-content">
          <h2>Work Requests</h2>
          <p>Manage and track your work requests</p>
        </div>
        
        <div className="header-actions">
          <Button
            variant="primary"
            onClick={() => navigate('/work/requests/new')}
            icon={<PlusIcon />}
          >
            New Request
          </Button>
          
          <Button
            variant="secondary"
            onClick={() => refetch()}
            icon={<RefreshIcon />}
          >
            Refresh
          </Button>
        </div>
      </div>

      <div className="repository-filters">
        <WorkRequestFilters
          filters={filters}
          onChange={setFilters}
          showAllRequestsToggle={showAllRequests}
          availableAssetTypes={availableAssetTypes}
        />
      </div>

      <div className="repository-table-container">
        <WorkRequestTable
          data={data?.requests || []}
          loading={isLoading}
          sorting={sorting}
          onSortChange={setSorting}
          onStatusUpdate={updateStatus}
          onDelete={deleteRequest}
          onView={(id) => navigate(`/work/requests/${id}`)}
          onEdit={(id) => navigate(`/work/requests/${id}/edit`)}
          showActions={true}
        />
      </div>

      <div className="repository-pagination">
        <Pagination
          current={pagination.page}
          pageSize={pagination.pageSize}
          total={data?.pagination.total || 0}
          onChange={(page, pageSize) => setPagination({ page, pageSize })}
          showSizeChanger
          showQuickJumper
          showTotal={(total, range) => 
            `${range[0]}-${range[1]} of ${total} requests`
          }
        />
      </div>
    </div>
  );
};
```

#### Advanced Filtering Component
```typescript
interface WorkRequestFiltersProps {
  filters: WorkRequestFilters;
  onChange: (filters: WorkRequestFilters) => void;
  showAllRequestsToggle?: boolean;
  availableAssetTypes: AssetType[];
}

const WorkRequestFilters: React.FC<WorkRequestFiltersProps> = ({
  filters,
  onChange,
  showAllRequestsToggle,
  availableAssetTypes
}) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const handleFilterChange = (key: string, value: any) => {
    onChange({
      ...filters,
      [key]: value
    });
  };

  const clearFilters = () => {
    onChange({
      status: [],
      priority: [],
      workType: [],
      assetType: [],
      dateRange: null,
      requestedBy: undefined
    });
  };

  const hasActiveFilters = Object.values(filters).some(value => 
    Array.isArray(value) ? value.length > 0 : value !== null && value !== undefined
  );

  return (
    <div className="work-request-filters">
      <div className="filters-row">
        <div className="filter-group">
          <label>Status</label>
          <MultiSelect
            value={filters.status}
            onChange={(value) => handleFilterChange('status', value)}
            options={[
              { value: 'draft', label: 'Draft' },
              { value: 'submitted', label: 'Submitted' },
              { value: 'under_review', label: 'Under Review' },
              { value: 'approved', label: 'Approved' },
              { value: 'rejected', label: 'Rejected' },
              { value: 'in_progress', label: 'In Progress' },
              { value: 'completed', label: 'Completed' },
              { value: 'cancelled', label: 'Cancelled' }
            ]}
            placeholder="All Statuses"
          />
        </div>

        <div className="filter-group">
          <label>Priority</label>
          <MultiSelect
            value={filters.priority}
            onChange={(value) => handleFilterChange('priority', value)}
            options={[
              { value: 'critical', label: 'Critical', color: '#ff4d4f' },
              { value: 'high', label: 'High', color: '#ff7a45' },
              { value: 'medium', label: 'Medium', color: '#ffa940' },
              { value: 'low', label: 'Low', color: '#52c41a' }
            ]}
            placeholder="All Priorities"
          />
        </div>

        <div className="filter-group">
          <label>Work Type</label>
          <MultiSelect
            value={filters.workType}
            onChange={(value) => handleFilterChange('workType', value)}
            options={[
              { value: 'maintenance', label: 'Maintenance' },
              { value: 'inspection', label: 'Inspection' },
              { value: 'repair', label: 'Repair' },
              { value: 'modification', label: 'Modification' },
              { value: 'emergency', label: 'Emergency' }
            ]}
            placeholder="All Work Types"
          />
        </div>

        <div className="filter-group">
          <label>Asset Type</label>
          <MultiSelect
            value={filters.assetType}
            onChange={(value) => handleFilterChange('assetType', value)}
            options={availableAssetTypes.map(type => ({
              value: type.key,
              label: type.displayName
            }))}
            placeholder="All Asset Types"
          />
        </div>

        <div className="filter-actions">
          <Button
            variant="text"
            onClick={() => setIsExpanded(!isExpanded)}
            icon={isExpanded ? <ChevronUpIcon /> : <ChevronDownIcon />}
          >
            {isExpanded ? 'Less' : 'More'} Filters
          </Button>
          
          {hasActiveFilters && (
            <Button
              variant="text"
              onClick={clearFilters}
              icon={<ClearIcon />}
            >
              Clear All
            </Button>
          )}
        </div>
      </div>

      {isExpanded && (
        <div className="filters-expanded">
          <div className="filter-group">
            <label>Date Range</label>
            <DateRangePicker
              value={filters.dateRange}
              onChange={(value) => handleFilterChange('dateRange', value)}
              placeholder="Select date range"
            />
          </div>

          <div className="filter-group">
            <label>Asset Code/Name</label>
            <Input
              value={filters.assetSearch}
              onChange={(e) => handleFilterChange('assetSearch', e.target.value)}
              placeholder="Search by asset code or name"
            />
          </div>

          <div className="filter-group">
            <label>Budget Code</label>
            <Input
              value={filters.budgetCode}
              onChange={(e) => handleFilterChange('budgetCode', e.target.value)}
              placeholder="Search by budget code"
            />
          </div>

          {showAllRequestsToggle && (
            <div className="filter-group">
              <label>Requestor</label>
              <UserSelect
                value={filters.requestedBy}
                onChange={(value) => handleFilterChange('requestedBy', value)}
                placeholder="All requestors"
              />
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

#### Repository Table Component
```typescript
interface WorkRequestTableProps {
  data: WorkRequestSummary[];
  loading: boolean;
  sorting: SortConfig;
  onSortChange: (sorting: SortConfig) => void;
  onStatusUpdate: (id: string, status: string) => void;
  onDelete: (id: string) => void;
  onView: (id: string) => void;
  onEdit: (id: string) => void;
  showActions: boolean;
}

const WorkRequestTable: React.FC<WorkRequestTableProps> = ({
  data,
  loading,
  sorting,
  onSortChange,
  onStatusUpdate,
  onDelete,
  onView,
  onEdit,
  showActions
}) => {
  const [selectedRows, setSelectedRows] = useState<string[]>([]);

  const columns = [
    {
      key: 'id',
      title: 'Request ID',
      dataIndex: 'id',
      width: 120,
      fixed: 'left',
      render: (id: string) => (
        <Button
          variant="link"
          onClick={() => onView(id)}
          className="request-id-link"
        >
          {id.slice(0, 8)}...
        </Button>
      )
    },
    {
      key: 'title',
      title: 'Title',
      dataIndex: 'title',
      width: 250,
      sortable: true,
      render: (title: string, record: WorkRequestSummary) => (
        <div className="request-title">
          <div className="title-text">{title}</div>
          <div className="title-meta">
            <span className="asset-info">
              {record.assetCode} - {record.assetName}
            </span>
          </div>
        </div>
      )
    },
    {
      key: 'status',
      title: 'Status',
      dataIndex: 'status',
      width: 120,
      sortable: true,
      render: (status: string) => (
        <StatusBadge status={status} />
      )
    },
    {
      key: 'priority',
      title: 'Priority',
      dataIndex: 'priority',
      width: 100,
      sortable: true,
      render: (priority: string) => (
        <PriorityBadge priority={priority} />
      )
    },
    {
      key: 'workType',
      title: 'Work Type',
      dataIndex: 'workType',
      width: 120,
      sortable: true,
      render: (workType: string) => (
        <WorkTypeBadge workType={workType} />
      )
    },
    {
      key: 'assetType',
      title: 'Asset Type',
      dataIndex: 'assetType',
      width: 100,
      sortable: true,
      render: (assetType: string) => (
        <AssetTypeBadge assetType={assetType} />
      )
    },
    {
      key: 'requestedStartDate',
      title: 'Requested Start',
      dataIndex: 'requestedStartDate',
      width: 150,
      sortable: true,
      render: (date: string) => (
        <div className="date-display">
          <div className="date">{formatDate(date)}</div>
          <div className="time">{formatTime(date)}</div>
        </div>
      )
    },
    {
      key: 'estimatedCost',
      title: 'Est. Cost',
      dataIndex: 'estimatedTotalCost',
      width: 120,
      sortable: true,
      render: (cost: number) => (
        cost ? formatCurrency(cost) : '-'
      )
    },
    {
      key: 'requestorName',
      title: 'Requestor',
      dataIndex: 'requestorName',
      width: 150,
      sortable: true,
      render: (name: string, record: WorkRequestSummary) => (
        <div className="requestor-info">
          <div className="name">{name}</div>
          <div className="department">{record.department}</div>
        </div>
      )
    },
    {
      key: 'submissionDate',
      title: 'Submitted',
      dataIndex: 'submissionDate',
      width: 150,
      sortable: true,
      render: (date: string) => (
        date ? (
          <div className="date-display">
            <div className="date">{formatDate(date)}</div>
            <div className="time">{formatTime(date)}</div>
          </div>
        ) : (
          <span className="draft-indicator">Draft</span>
        )
      )
    },
    {
      key: 'actions',
      title: 'Actions',
      width: 120,
      fixed: 'right',
      render: (record: WorkRequestSummary) => (
        <div className="action-buttons">
          <Tooltip title="View Details">
            <Button
              size="small"
              icon={<EyeIcon />}
              onClick={() => onView(record.id)}
            />
          </Tooltip>
          
          {record.status === 'draft' && (
            <Tooltip title="Edit">
              <Button
                size="small"
                icon={<EditIcon />}
                onClick={() => onEdit(record.id)}
              />
            </Tooltip>
          )}
          
          {['draft', 'submitted'].includes(record.status) && (
            <Tooltip title="Cancel">
              <Button
                size="small"
                icon={<CancelIcon />}
                onClick={() => onStatusUpdate(record.id, 'cancelled')}
                danger
              />
            </Tooltip>
          )}
          
          <Dropdown
            menu={{
              items: [
                {
                  key: 'duplicate',
                  label: 'Duplicate',
                  icon: <CopyIcon />
                },
                {
                  key: 'export',
                  label: 'Export',
                  icon: <ExportIcon />
                },
                {
                  key: 'delete',
                  label: 'Delete',
                  icon: <DeleteIcon />,
                  danger: true,
                  disabled: !['draft', 'cancelled'].includes(record.status)
                }
              ],
              onClick: ({ key }) => handleMenuAction(key, record)
            }}
          >
            <Button size="small" icon={<MoreIcon />} />
          </Dropdown>
        </div>
      )
    }
  ];

  const handleMenuAction = (action: string, record: WorkRequestSummary) => {
    switch (action) {
      case 'duplicate':
        // Navigate to form with pre-filled data
        navigate(`/work/requests/new?duplicate=${record.id}`);
        break;
      case 'export':
        // Export single request
        exportWorkRequest(record.id);
        break;
      case 'delete':
        // Show confirmation dialog
        showDeleteConfirmation(record.id);
        break;
    }
  };

  return (
    <div className="work-request-table">
      {selectedRows.length > 0 && (
        <div className="bulk-actions">
          <span>{selectedRows.length} requests selected</span>
          <Button
            size="small"
            onClick={() => bulkUpdateStatus(selectedRows, 'cancelled')}
          >
            Cancel Selected
          </Button>
          <Button
            size="small"
            onClick={() => bulkExport(selectedRows)}
          >
            Export Selected
          </Button>
        </div>
      )}

      <Table
        columns={columns}
        dataSource={data}
        loading={loading}
        rowKey="id"
        scroll={{ x: 1200 }}
        pagination={false}
        rowSelection={{
          selectedRowKeys: selectedRows,
          onChange: setSelectedRows,
          getCheckboxProps: (record) => ({
            disabled: record.status === 'completed'
          })
        }}
        sortDirections={['descend', 'ascend']}
        onChange={(pagination, filters, sorter) => {
          if (sorter && !Array.isArray(sorter)) {
            onSortChange({
              field: sorter.field as string,
              direction: sorter.order === 'ascend' ? 'asc' : 'desc'
            });
          }
        }}
      />
    </div>
  );
};
```

#### Status and Badge Components
```typescript
const StatusBadge: React.FC<{ status: string }> = ({ status }) => {
  const statusConfig = {
    draft: { color: '#8c8c8c', text: 'Draft' },
    submitted: { color: '#1890ff', text: 'Submitted' },
    under_review: { color: '#fa8c16', text: 'Under Review' },
    approved: { color: '#52c41a', text: 'Approved' },
    rejected: { color: '#ff4d4f', text: 'Rejected' },
    in_progress: { color: '#722ed1', text: 'In Progress' },
    completed: { color: '#52c41a', text: 'Completed' },
    cancelled: { color: '#8c8c8c', text: 'Cancelled' }
  };

  const config = statusConfig[status] || statusConfig.draft;

  return (
    <Badge
      color={config.color}
      text={config.text}
      className={`status-badge status-${status}`}
    />
  );
};

const PriorityBadge: React.FC<{ priority: string }> = ({ priority }) => {
  const priorityConfig = {
    critical: { color: '#ff4d4f', text: 'Critical', icon: <AlertIcon /> },
    high: { color: '#ff7a45', text: 'High', icon: <HighIcon /> },
    medium: { color: '#ffa940', text: 'Medium', icon: <MediumIcon /> },
    low: { color: '#52c41a', text: 'Low', icon: <LowIcon /> }
  };

  const config = priorityConfig[priority] || priorityConfig.medium;

  return (
    <Badge
      color={config.color}
      text={config.text}
      icon={config.icon}
      className={`priority-badge priority-${priority}`}
    />
  );
};

const WorkTypeBadge: React.FC<{ workType: string }> = ({ workType }) => {
  const workTypeConfig = {
    maintenance: { color: '#1890ff', text: 'Maintenance' },
    inspection: { color: '#52c41a', text: 'Inspection' },
    repair: { color: '#fa8c16', text: 'Repair' },
    modification: { color: '#722ed1', text: 'Modification' },
    emergency: { color: '#ff4d4f', text: 'Emergency' }
  };

  const config = workTypeConfig[workType] || workTypeConfig.maintenance;

  return (
    <Badge
      color={config.color}
      text={config.text}
      className={`work-type-badge work-type-${workType}`}
    />
  );
};

const AssetTypeBadge: React.FC<{ assetType: string }> = ({ assetType }) => {
  const assetTypeConfig = {
    stand: { color: '#1890ff', text: 'Stand', icon: <StandIcon /> },
    airfield: { color: '#52c41a', text: 'Airfield', icon: <AirfieldIcon /> },
    baggage: { color: '#fa8c16', text: 'Baggage', icon: <BaggageIcon /> },
    terminal: { color: '#722ed1', text: 'Terminal', icon: <TerminalIcon /> },
    gate: { color: '#eb2f96', text: 'Gate', icon: <GateIcon /> },
    runway: { color: '#13c2c2', text: 'Runway', icon: <RunwayIcon /> },
    taxiway: { color: '#a0d911', text: 'Taxiway', icon: <TaxiwayIcon /> }
  };

  const config = assetTypeConfig[assetType] || { color: '#8c8c8c', text: assetType };

  return (
    <Badge
      color={config.color}
      text={config.text}
      icon={config.icon}
      className={`asset-type-badge asset-type-${assetType}`}
    />
  );
};
```

### Repository API Endpoints

#### Enhanced Work Request Listing
```typescript
// GET /api/v1/work/requests
interface GetWorkRequestsRequest {
  page?: number;
  pageSize?: number;
  
  // Status Filters
  status?: WorkRequestStatus[];
  priority?: Priority[];
  urgency?: Urgency[];
  workType?: WorkType[];
  
  // Asset Filters
  assetType?: string[];
  assetId?: string;
  assetCode?: string;
  assetSearch?: string; // Search in asset name/code
  
  // User Filters
  requestedBy?: string;
  currentApprover?: string;
  department?: string;
  
  // Date Filters
  submissionDateStart?: string;
  submissionDateEnd?: string;
  requestedStartDateStart?: string;
  requestedStartDateEnd?: string;
  deadlineStart?: string;
  deadlineEnd?: string;
  
  // Cost Filters
  budgetCode?: string;
  costCenter?: string;
  minCost?: number;
  maxCost?: number;
  
  // Search and Sorting
  search?: string; // Global search across title, description
  sortBy?: 'createdAt' | 'submissionDate' | 'priority' | 'requestedStartDate' | 'title' | 'status';
  sortOrder?: 'asc' | 'desc';
  
  // View Options
  includeDetails?: boolean;
  includeCounts?: boolean;
  includeAssetInfo?: boolean;
}

interface GetWorkRequestsResponse {
  success: boolean;
  data: {
    requests: WorkRequestSummary[];
    pagination: {
      page: number;
      pageSize: number;
      total: number;
      totalPages: number;
    };
    summary?: {
      totalRequests: number;
      byStatus: Record<string, number>;
      byPriority: Record<string, number>;
      byAssetType: Record<string, number>;
      totalEstimatedCost: number;
    };
    filters?: {
      availableAssetTypes: AssetType[];
      availableDepartments: string[];
      dateRange: {
        earliest: string;
        latest: string;
      };
    };
  };
}

// GET /api/v1/work/requests/dashboard
interface GetWorkRequestDashboardResponse {
  success: boolean;
  data: {
    counts: {
      total: number;
      draft: number;
      submitted: number;
      underReview: number;
      approved: number;
      inProgress: number;
      completed: number;
      overdue: number;
    };
    recentRequests: WorkRequestSummary[];
    pendingApprovals: WorkRequestSummary[];
    upcomingWork: WorkRequestSummary[];
    costSummary: {
      totalEstimated: number;
      totalApproved: number;
      averageCost: number;
    };
    trends: {
      requestsByWeek: ChartData[];
      completionRate: number;
      averageApprovalTime: number;
    };
  };
}

// POST /api/v1/work/requests/bulk-actions
interface BulkActionRequest {
  requestIds: string[];
  action: 'cancel' | 'delete' | 'export' | 'update_status';
  parameters?: {
    status?: string;
    reason?: string;
    format?: 'csv' | 'excel' | 'pdf';
  };
}

interface BulkActionResponse {
  success: boolean;
  data: {
    processedCount: number;
    successCount: number;
    failureCount: number;
    failures: {
      requestId: string;
      error: string;
    }[];
    downloadUrl?: string; // For export actions
  };
}
```

### Repository Service Implementation

```typescript
class WorkRequestRepositoryService {
  constructor(
    private prisma: PrismaClient,
    private cacheService: CacheService
  ) {}

  async getWorkRequests(
    organizationId: string,
    userId: string,
    filters: GetWorkRequestsRequest
  ): Promise<GetWorkRequestsResponse> {
    const cacheKey = `work-requests:${organizationId}:${userId}:${JSON.stringify(filters)}`;
    
    // Check cache first
    const cached = await this.cacheService.get<GetWorkRequestsResponse>(cacheKey);
    if (cached) {
      return cached;
    }

    // Build query conditions
    const whereClause = this.buildWhereClause(organizationId, userId, filters);
    const orderBy = this.buildOrderBy(filters.sortBy, filters.sortOrder);

    // Execute queries
    const [requests, total, summary] = await Promise.all([
      this.prisma.workRequest.findMany({
        where: whereClause,
        orderBy,
        skip: ((filters.page || 1) - 1) * (filters.pageSize || 25),
        take: filters.pageSize || 25,
        select: {
          id: true,
          title: true,
          status: true,
          priority: true,
          urgency: true,
          workType: true,
          assetType: true,
          assetCode: true,
          assetName: true,
          assetLocation: true,
          requestedStartDate: true,
          estimatedTotalCost: true,
          requestorName: true,
          department: true,
          submissionDate: true,
          createdAt: true,
          updatedAt: true,
          ...(filters.includeAssetInfo && {
            assetMetadata: true
          })
        }
      }),
      this.prisma.workRequest.count({ where: whereClause }),
      filters.includeCounts ? this.getRequestSummary(organizationId, userId, filters) : null
    ]);

    const response: GetWorkRequestsResponse = {
      success: true,
      data: {
        requests: requests.map(this.mapToWorkRequestSummary),
        pagination: {
          page: filters.page || 1,
          pageSize: filters.pageSize || 25,
          total,
          totalPages: Math.ceil(total / (filters.pageSize || 25))
        },
        ...(summary && { summary })
      }
    };

    // Cache the response
    await this.cacheService.set(cacheKey, response, 300); // 5 minutes

    return response;
  }

  private buildWhereClause(
    organizationId: string,
    userId: string,
    filters: GetWorkRequestsRequest
  ) {
    const where: any = {
      organizationId,
      ...(filters.requestedBy && { requestedBy: filters.requestedBy }),
      ...(filters.status && { status: { in: filters.status } }),
      ...(filters.priority && { priority: { in: filters.priority } }),
      ...(filters.workType && { workType: { in: filters.workType } }),
      ...(filters.assetType && { assetType: { in: filters.assetType } }),
      ...(filters.assetId && { assetId: filters.assetId }),
      ...(filters.department && { department: filters.department }),
      ...(filters.budgetCode && { budgetCode: { contains: filters.budgetCode, mode: 'insensitive' } }),
      ...(filters.costCenter && { costCenter: filters.costCenter })
    };

    // Date filters
    if (filters.submissionDateStart || filters.submissionDateEnd) {
      where.submissionDate = {
        ...(filters.submissionDateStart && { gte: new Date(filters.submissionDateStart) }),
        ...(filters.submissionDateEnd && { lte: new Date(filters.submissionDateEnd) })
      };
    }

    if (filters.requestedStartDateStart || filters.requestedStartDateEnd) {
      where.requestedStartDate = {
        ...(filters.requestedStartDateStart && { gte: new Date(filters.requestedStartDateStart) }),
        ...(filters.requestedStartDateEnd && { lte: new Date(filters.requestedStartDateEnd) })
      };
    }

    // Cost filters
    if (filters.minCost || filters.maxCost) {
      where.estimatedTotalCost = {
        ...(filters.minCost && { gte: filters.minCost }),
        ...(filters.maxCost && { lte: filters.maxCost })
      };
    }

    // Global search
    if (filters.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } },
        { assetCode: { contains: filters.search, mode: 'insensitive' } },
        { assetName: { contains: filters.search, mode: 'insensitive' } }
      ];
    }

    // Asset search
    if (filters.assetSearch) {
      where.OR = [
        { assetCode: { contains: filters.assetSearch, mode: 'insensitive' } },
        { assetName: { contains: filters.assetSearch, mode: 'insensitive' } }
      ];
    }

    return where;
  }

  private buildOrderBy(sortBy?: string, sortOrder?: string) {
    const direction = sortOrder === 'asc' ? 'asc' : 'desc';
    
    switch (sortBy) {
      case 'title':
        return { title: direction };
      case 'priority':
        return { priority: direction };
      case 'status':
        return { status: direction };
      case 'submissionDate':
        return { submissionDate: direction };
      case 'requestedStartDate':
        return { requestedStartDate: direction };
      case 'createdAt':
      default:
        return { createdAt: direction };
    }
  }

  private async getRequestSummary(
    organizationId: string,
    userId: string,
    filters: GetWorkRequestsRequest
  ) {
    const baseWhere = this.buildWhereClause(organizationId, userId, filters);
    
    const [
      statusCounts,
      priorityCounts,
      assetTypeCounts,
      costSummary
    ] = await Promise.all([
      this.prisma.workRequest.groupBy({
        by: ['status'],
        where: baseWhere,
        _count: { id: true }
      }),
      this.prisma.workRequest.groupBy({
        by: ['priority'],
        where: baseWhere,
        _count: { id: true }
      }),
      this.prisma.workRequest.groupBy({
        by: ['assetType'],
        where: baseWhere,
        _count: { id: true }
      }),
      this.prisma.workRequest.aggregate({
        where: baseWhere,
        _sum: { estimatedTotalCost: true },
        _count: { id: true }
      })
    ]);

    return {
      totalRequests: costSummary._count.id,
      byStatus: statusCounts.reduce((acc, item) => {
        acc[item.status] = item._count.id;
        return acc;
      }, {} as Record<string, number>),
      byPriority: priorityCounts.reduce((acc, item) => {
        acc[item.priority] = item._count.id;
        return acc;
      }, {} as Record<string, number>),
      byAssetType: assetTypeCounts.reduce((acc, item) => {
        acc[item.assetType] = item._count.id;
        return acc;
      }, {} as Record<string, number>),
      totalEstimatedCost: costSummary._sum.estimatedTotalCost || 0
    };
  }

  private mapToWorkRequestSummary(request: any): WorkRequestSummary {
    return {
      id: request.id,
      title: request.title,
      status: request.status,
      priority: request.priority,
      urgency: request.urgency,
      workType: request.workType,
      assetType: request.assetType,
      assetCode: request.assetCode,
      assetName: request.assetName,
      assetLocation: request.assetLocation,
      requestedStartDate: request.requestedStartDate,
      estimatedTotalCost: request.estimatedTotalCost,
      requestorName: request.requestorName,
      department: request.department,
      submissionDate: request.submissionDate,
      createdAt: request.createdAt,
      updatedAt: request.updatedAt
    };
  }

  async bulkAction(
    organizationId: string,
    userId: string,
    action: BulkActionRequest
  ): Promise<BulkActionResponse> {
    const results = {
      processedCount: action.requestIds.length,
      successCount: 0,
      failureCount: 0,
      failures: [] as { requestId: string; error: string }[]
    };

    for (const requestId of action.requestIds) {
      try {
        switch (action.action) {
          case 'cancel':
            await this.updateWorkRequestStatus(requestId, 'cancelled', userId, action.parameters?.reason);
            break;
          case 'delete':
            await this.deleteWorkRequest(requestId, userId);
            break;
          case 'update_status':
            await this.updateWorkRequestStatus(requestId, action.parameters?.status!, userId, action.parameters?.reason);
            break;
          case 'export':
            // Handle export logic
            break;
        }
        results.successCount++;
      } catch (error) {
        results.failureCount++;
        results.failures.push({
          requestId,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    return {
      success: true,
      data: results
    };
  }
}
```

## Deployment and Operations

### Docker Configuration

#### Dockerfile
```dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY packages/work-module/package*.json ./packages/work-module/
COPY packages/shared-kernel/package*.json ./packages/shared-kernel/

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY packages/work-module ./packages/work-module
COPY packages/shared-kernel ./packages/shared-kernel

# Build the application
RUN npm run build

FROM node:20-alpine AS runtime

WORKDIR /app

# Install security updates
RUN apk update && apk upgrade

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S workservice -u 1001

# Copy built application
COPY --from=builder --chown=workservice:nodejs /app/dist ./dist
COPY --from=builder --chown=workservice:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=workservice:nodejs /app/package*.json ./

# Set environment variables
ENV NODE_ENV=production
ENV PORT=3000

# Expose port
EXPOSE 3000

# Switch to non-root user
USER workservice

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD node dist/health-check.js

# Start application
CMD ["node", "dist/index.js"]
```

#### Docker Compose
```yaml
version: '3.8'

services:
  work-service:
    build: .
    ports:
      - "3001:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://workuser:workpass@postgres:5432/workdb
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - FIELD_ENCRYPTION_KEY=${FIELD_ENCRYPTION_KEY}
      - FILE_UPLOAD_PATH=/app/uploads
      - VIRUS_SCAN_ENABLED=true
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    networks:
      - work-network

  postgres:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=workdb
      - POSTGRES_USER=workuser
      - POSTGRES_PASSWORD=workpass
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - work-network

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    restart: unless-stopped
    networks:
      - work-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - work-service
    restart: unless-stopped
    networks:
      - work-network

volumes:
  postgres_data:
  redis_data:
  uploads:
  logs:

networks:
  work-network:
    driver: bridge
```

### Monitoring and Logging

#### Application Monitoring
```typescript
import { createPrometheusMetrics } from 'prom-client';
import { Request, Response, NextFunction } from 'express';

// Metrics collection
const metrics = createPrometheusMetrics();

const httpRequestDuration = new metrics.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code']
});

const httpRequestsTotal = new metrics.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

const workRequestsTotal = new metrics.Counter({
  name: 'work_requests_total',
  help: 'Total number of work requests created',
  labelNames: ['work_type', 'priority', 'organization']
});

const workRequestProcessingTime = new metrics.Histogram({
  name: 'work_request_processing_seconds',
  help: 'Time taken to process work requests',
  labelNames: ['operation', 'status']
});

// Middleware for metrics collection
export const metricsMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - startTime) / 1000;
    const route = req.route?.path || req.path;
    
    httpRequestDuration
      .labels(req.method, route, res.statusCode.toString())
      .observe(duration);
    
    httpRequestsTotal
      .labels(req.method, route, res.statusCode.toString())
      .inc();
  });
  
  next();
};

// Business metrics
export const trackWorkRequestCreation = (workType: string, priority: string, organizationId: string) => {
  workRequestsTotal
    .labels(workType, priority, organizationId)
    .inc();
};

export const trackWorkRequestProcessing = (operation: string, status: string, durationMs: number) => {
  workRequestProcessingTime
    .labels(operation, status)
    .observe(durationMs / 1000);
};
```

#### Structured Logging
```typescript
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'work-request-service',
    version: process.env.APP_VERSION || '1.0.0'
  },
  transports: [
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

// Audit logging
export const auditLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ 
      filename: 'logs/audit.log',
      maxsize: 10485760, // 10MB
      maxFiles: 10
    })
  ]
});

// Usage examples
export const logWorkRequestCreation = (userId: string, organizationId: string, workRequestId: string) => {
  auditLogger.info('Work request created', {
    event: 'work_request_created',
    userId,
    organizationId,
    workRequestId,
    timestamp: new Date().toISOString()
  });
};

export const logWorkRequestStatusChange = (
  userId: string, 
  workRequestId: string, 
  fromStatus: string, 
  toStatus: string
) => {
  auditLogger.info('Work request status changed', {
    event: 'work_request_status_changed',
    userId,
    workRequestId,
    fromStatus,
    toStatus,
    timestamp: new Date().toISOString()
  });
};
```

## Success Metrics and KPIs

### Technical Metrics
- **API Response Time**: <200ms for form loads, <500ms for stand searches
- **Database Query Performance**: <100ms for single record queries
- **Cache Hit Rate**: >85% for frequently accessed data
- **File Upload Speed**: <5 seconds for files up to 10MB
- **Form Validation Time**: <200ms for real-time validation

### Business Metrics
- **Form Completion Rate**: >90% of started forms completed
- **Data Quality**: <5% validation errors on submission
- **User Satisfaction**: >4.5/5 rating for form usability
- **Processing Time**: <24 hours average approval time
- **System Adoption**: >80% of maintenance requests through system

### Security Metrics
- **Authentication Success Rate**: >99.5%
- **Authorization Failures**: <0.1% false positives
- **File Scan Success Rate**: 100% of uploads scanned
- **Audit Trail Completeness**: 100% of actions logged
- **Data Encryption Coverage**: 100% of sensitive fields encrypted

---

This comprehensive TDD provides the complete technical foundation for implementing the Work Request Form feature, including detailed database schemas, API specifications, security implementations, testing strategies, and deployment configurations. The design ensures scalability, security, and maintainability while providing excellent user experience and system performance. 