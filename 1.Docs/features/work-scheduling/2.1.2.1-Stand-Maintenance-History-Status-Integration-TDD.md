# TDD: Stand Maintenance History & Status Integration

**Feature**: Stand Maintenance History & Status Integration  
**Version**: 2.1.2.1  
**Date**: January 2025  
**Owner**: Engineering Team  
**Status**: Ready for Implementation  
**PRD Reference**: 2.1.2.1-Stand-Maintenance-History-Status-Integration-PRD.md  
**Parent TDD**: 2.1.1.1-Work-Request-Form-TDD.md

## Technical Overview

This TDD defines the complete technical implementation for the Stand Maintenance History & Status Integration feature that creates a comprehensive maintenance history system by linking work requests directly to stand records. The system automatically manages stand status based on work request lifecycle events and provides complete visibility into past, current, and future maintenance activities.

**Key Technical Components:**
- Work request to stand linking with automatic status management
- Real-time stand status updates based on work request lifecycle
- Comprehensive maintenance history accessible from stand detail pages
- Future work visibility with impact assessment
- Event-driven architecture for real-time synchronization

## Architecture Overview

### System Components
- **Work Request Service**: Enhanced with stand integration capabilities
- **Assets Service**: Enhanced with work request history and status management
- **Event Bus**: Real-time event propagation between services
- **Status Engine**: Business logic for automatic status transitions
- **History Service**: Maintenance history aggregation and querying
- **Notification Service**: Real-time notifications for status changes

### Technology Stack
- **Backend**: Node.js 20+, Express 4.18+, PostgreSQL 14+
- **Event System**: Redis Pub/Sub or Apache Kafka for event streaming
- **Caching**: Redis for performance optimization
- **Database**: PostgreSQL with JSONB support and advanced indexing
- **Real-time**: WebSocket connections for live status updates
- **Monitoring**: Prometheus metrics and structured logging

## Database Schema Design

### Enhanced Work Request Schema

#### Work Request Enhancements
```sql
-- Add stand-specific fields to existing work_requests table
ALTER TABLE work.work_requests ADD COLUMN IF NOT EXISTS stand_status_impact VARCHAR(20) DEFAULT 'no_impact';
ALTER TABLE work.work_requests ADD COLUMN IF NOT EXISTS scheduled_status_change TIMESTAMP WITH TIME ZONE;
ALTER TABLE work.work_requests ADD COLUMN IF NOT EXISTS actual_start_date TIMESTAMP WITH TIME ZONE;
ALTER TABLE work.work_requests ADD COLUMN IF NOT EXISTS actual_end_date TIMESTAMP WITH TIME ZONE;
ALTER TABLE work.work_requests ADD COLUMN IF NOT EXISTS stand_impact_details JSONB DEFAULT '{}';

-- Add constraint for stand status impact
ALTER TABLE work.work_requests ADD CONSTRAINT work_requests_stand_status_impact_check 
CHECK (stand_status_impact IN ('no_impact', 'partial_restriction', 'full_closure', 'emergency_closure'));

-- Create index for stand status queries
CREATE INDEX idx_work_requests_stand_status ON work.work_requests(stand_status_impact, status, scheduled_status_change);
```

#### Stand Status History Table
```sql
CREATE TABLE assets.stand_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL,
  stand_id UUID NOT NULL, -- Reference to assets.stands.id
  stand_code VARCHAR(20) NOT NULL, -- Denormalized for performance
  
  -- Status Information
  from_status VARCHAR(30),
  to_status VARCHAR(30) NOT NULL,
  status_reason TEXT,
  impact_level VARCHAR(20) NOT NULL DEFAULT 'no_impact',
  
  -- Work Request Link
  work_request_id UUID, -- Reference to work.work_requests.id
  work_request_title VARCHAR(200),
  work_type VARCHAR(50),
  
  -- Timing Information
  effective_from TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  effective_to TIMESTAMP WITH TIME ZONE,
  scheduled_change BOOLEAN DEFAULT false,
  
  -- Operational Impact
  operational_impact JSONB DEFAULT '{}', -- Capacity, restrictions, etc.
  adjacent_stands_affected JSONB DEFAULT '[]', -- Array of affected stand IDs
  terminal_impact JSONB DEFAULT '{}', -- Terminal-level impacts
  
  -- Metadata
  change_reason VARCHAR(100),
  change_source VARCHAR(50) NOT NULL DEFAULT 'work_request', -- 'work_request', 'manual', 'system'
  automated_change BOOLEAN DEFAULT true,
  override_reason TEXT,
  
  -- Audit Fields
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  created_by UUID NOT NULL,
  created_by_name VARCHAR(100) NOT NULL,
  
  CONSTRAINT stand_status_history_dates_check CHECK (
    effective_to IS NULL OR effective_from < effective_to
  ),
  CONSTRAINT stand_status_history_status_check CHECK (
    to_status IN ('operational', 'maintenance', 'closed', 'emergency', 'restricted')
  )
);

-- Indexes for performance
CREATE INDEX idx_stand_status_history_stand ON assets.stand_status_history(stand_id, effective_from DESC);
CREATE INDEX idx_stand_status_history_work_request ON assets.stand_status_history(work_request_id);
CREATE INDEX idx_stand_status_history_org_status ON assets.stand_status_history(organization_id, to_status, effective_from DESC);
CREATE INDEX idx_stand_status_history_effective ON assets.stand_status_history(effective_from, effective_to);
CREATE INDEX idx_stand_status_history_current ON assets.stand_status_history(stand_id, effective_from DESC) WHERE effective_to IS NULL;

-- GIN indexes for JSONB fields
CREATE INDEX idx_stand_status_history_operational_impact ON assets.stand_status_history USING gin(operational_impact);
CREATE INDEX idx_stand_status_history_adjacent_stands ON assets.stand_status_history USING gin(adjacent_stands_affected);
```

#### Stand Work Request History View
```sql
CREATE VIEW assets.stand_work_request_history AS
SELECT 
  s.id as stand_id,
  s.code as stand_code,
  s.name as stand_name,
  wr.id as work_request_id,
  wr.title,
  wr.description,
  wr.work_type,
  wr.category,
  wr.priority,
  wr.status,
  wr.stand_status_impact,
  wr.requested_start_date,
  wr.requested_end_date,
  wr.actual_start_date,
  wr.actual_end_date,
  wr.estimated_total_cost,
  wr.requested_by,
  wr.requestor_name,
  wr.created_at,
  wr.updated_at,
  wr.submission_date,
  wr.approved_date,
  wr.completed_date,
  -- Calculate duration
  CASE 
    WHEN wr.actual_end_date IS NOT NULL AND wr.actual_start_date IS NOT NULL 
    THEN EXTRACT(EPOCH FROM (wr.actual_end_date - wr.actual_start_date))/3600
    ELSE NULL
  END as actual_duration_hours,
  -- Status indicators
  CASE 
    WHEN wr.status = 'completed' THEN 'completed'
    WHEN wr.status = 'in_progress' THEN 'current'
    WHEN wr.status = 'approved' AND wr.requested_start_date > now() THEN 'future'
    ELSE 'historical'
  END as timeline_category
FROM assets.stands s
JOIN work.work_request_stand_associations wrsa ON s.id = wrsa.stand_id
JOIN work.work_requests wr ON wrsa.work_request_id = wr.id
WHERE s.organization_id = wr.organization_id;

-- Index for the view
CREATE INDEX idx_stand_work_request_history_stand_timeline ON work.work_request_stand_associations(stand_id, work_request_id);
```

#### Stand Current Status View
```sql
CREATE VIEW assets.stand_current_status AS
SELECT DISTINCT ON (s.id)
  s.id as stand_id,
  s.code as stand_code,
  s.name as stand_name,
  s.organization_id,
  COALESCE(ssh.to_status, 'operational') as current_status,
  ssh.status_reason,
  ssh.impact_level,
  ssh.work_request_id,
  ssh.work_request_title,
  ssh.work_type,
  ssh.effective_from as status_since,
  ssh.effective_to as status_until,
  ssh.operational_impact,
  ssh.change_source,
  ssh.automated_change,
  -- Calculate time in current status
  EXTRACT(EPOCH FROM (now() - ssh.effective_from))/3600 as hours_in_status,
  -- Determine if status change is imminent
  CASE 
    WHEN ssh.effective_to IS NOT NULL AND ssh.effective_to <= now() + INTERVAL '24 hours' 
    THEN true 
    ELSE false 
  END as status_change_imminent
FROM assets.stands s
LEFT JOIN assets.stand_status_history ssh ON s.id = ssh.stand_id 
  AND (ssh.effective_to IS NULL OR ssh.effective_to > now())
ORDER BY s.id, ssh.effective_from DESC;
```

#### Stand Maintenance Analytics Table
```sql
CREATE TABLE assets.stand_maintenance_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL,
  stand_id UUID NOT NULL REFERENCES assets.stands(id) ON DELETE CASCADE,
  calculation_date DATE NOT NULL DEFAULT CURRENT_DATE,
  
  -- Time-based metrics
  total_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  planned_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  unplanned_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  emergency_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  
  -- Frequency metrics
  total_work_requests INTEGER DEFAULT 0,
  completed_work_requests INTEGER DEFAULT 0,
  cancelled_work_requests INTEGER DEFAULT 0,
  average_completion_time_hours DECIMAL(10,2),
  
  -- Cost metrics
  total_maintenance_cost DECIMAL(12,2) DEFAULT 0,
  average_cost_per_request DECIMAL(10,2),
  budget_utilization_percentage DECIMAL(5,2),
  
  -- Performance metrics
  mtbf_hours DECIMAL(10,2), -- Mean Time Between Failures
  mttr_hours DECIMAL(10,2), -- Mean Time To Repair
  availability_percentage DECIMAL(5,2),
  
  -- Trend indicators
  maintenance_trend VARCHAR(20) DEFAULT 'stable', -- 'increasing', 'decreasing', 'stable'
  cost_trend VARCHAR(20) DEFAULT 'stable',
  frequency_trend VARCHAR(20) DEFAULT 'stable',
  
  -- Metadata
  calculation_period_days INTEGER DEFAULT 30,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(organization_id, stand_id, calculation_date)
);

-- Indexes for analytics
CREATE INDEX idx_stand_maintenance_analytics_stand ON assets.stand_maintenance_analytics(stand_id, calculation_date DESC);
CREATE INDEX idx_stand_maintenance_analytics_org ON assets.stand_maintenance_analytics(organization_id, calculation_date DESC);
CREATE INDEX idx_stand_maintenance_analytics_metrics ON assets.stand_maintenance_analytics(mtbf_hours, mttr_hours, availability_percentage);
```

## API Design

### Stand History API Endpoints

#### Get Stand Work Request History
```typescript
/**
 * GET /api/v1/stands/{standId}/work-requests
 * Get comprehensive work request history for a stand
 */
interface StandWorkRequestHistoryRequest {
  standId: string;
  organizationId: string;
  filters?: {
    dateRange?: {
      startDate: string;
      endDate: string;
    };
    workTypes?: string[];
    statuses?: string[];
    priorities?: string[];
    categories?: string[];
    costRange?: {
      min: number;
      max: number;
    };
  };
  pagination?: {
    page: number;
    limit: number;
  };
  sort?: {
    field: string;
    direction: 'asc' | 'desc';
  };
}

interface StandWorkRequestHistoryResponse {
  standId: string;
  standCode: string;
  standName: string;
  totalRecords: number;
  filteredRecords: number;
  workRequests: {
    id: string;
    title: string;
    description: string;
    workType: string;
    category: string;
    priority: string;
    status: string;
    statusImpact: string;
    requestedStartDate: string;
    requestedEndDate: string;
    actualStartDate?: string;
    actualEndDate?: string;
    estimatedCost?: number;
    actualCost?: number;
    requestedBy: string;
    requestorName: string;
    createdAt: string;
    submissionDate?: string;
    approvedDate?: string;
    completedDate?: string;
    actualDurationHours?: number;
    timelineCategory: 'completed' | 'current' | 'future' | 'historical';
    documents: {
      id: string;
      fileName: string;
      fileSize: number;
      uploadedAt: string;
    }[];
  }[];
  summary: {
    totalCost: number;
    totalHours: number;
    completedRequests: number;
    averageCompletionTime: number;
    mostCommonWorkType: string;
    costTrend: 'increasing' | 'decreasing' | 'stable';
  };
  pagination: {
    currentPage: number;
    totalPages: number;
    hasNext: boolean;
    hasPrevious: boolean;
  };
}

// Implementation
export const getStandWorkRequestHistory = async (
  req: Request<{ standId: string }, StandWorkRequestHistoryResponse, never, StandWorkRequestHistoryRequest>,
  res: Response<StandWorkRequestHistoryResponse>
): Promise<void> => {
  const { standId } = req.params;
  const { organizationId, filters, pagination, sort } = req.query;
  
  try {
    // Validate permissions
    await validateStandAccess(req.user.id, organizationId, standId);
    
    // Build query with filters
    const query = buildWorkRequestHistoryQuery(standId, organizationId, filters);
    
    // Apply pagination and sorting
    const paginatedQuery = applyPaginationAndSort(query, pagination, sort);
    
    // Execute query
    const workRequests = await executeWorkRequestHistoryQuery(paginatedQuery);
    
    // Calculate summary metrics
    const summary = await calculateWorkRequestSummary(standId, organizationId, filters);
    
    // Get stand information
    const stand = await getStandById(standId, organizationId);
    
    res.json({
      standId,
      standCode: stand.code,
      standName: stand.name,
      totalRecords: summary.totalRecords,
      filteredRecords: workRequests.length,
      workRequests,
      summary,
      pagination: {
        currentPage: pagination?.page || 1,
        totalPages: Math.ceil(summary.totalRecords / (pagination?.limit || 20)),
        hasNext: (pagination?.page || 1) * (pagination?.limit || 20) < summary.totalRecords,
        hasPrevious: (pagination?.page || 1) > 1
      }
    });
  } catch (error) {
    handleApiError(error, res);
  }
};
```

#### Get Stand Current Status
```typescript
/**
 * GET /api/v1/stands/{standId}/status
 * Get current status and status history for a stand
 */
interface StandCurrentStatusResponse {
  standId: string;
  standCode: string;
  standName: string;
  currentStatus: {
    status: string;
    statusReason?: string;
    impactLevel: string;
    statusSince: string;
    statusUntil?: string;
    hoursInStatus: number;
    statusChangeImminent: boolean;
    workRequestId?: string;
    workRequestTitle?: string;
    workType?: string;
    operationalImpact: {
      capacityReduction?: number;
      restrictions?: string[];
      affectedServices?: string[];
    };
    contactInformation?: {
      primaryContact: string;
      secondaryContact?: string;
      emergencyContact?: string;
    };
  };
  statusHistory: {
    id: string;
    fromStatus?: string;
    toStatus: string;
    statusReason?: string;
    impactLevel: string;
    effectiveFrom: string;
    effectiveTo?: string;
    workRequestId?: string;
    workRequestTitle?: string;
    workType?: string;
    changeSource: string;
    automatedChange: boolean;
    createdBy: string;
    createdByName: string;
  }[];
  upcomingStatusChanges: {
    scheduledDate: string;
    newStatus: string;
    reason: string;
    workRequestId: string;
    workRequestTitle: string;
    impactLevel: string;
    estimatedDuration: number;
  }[];
  analytics: {
    availabilityPercentage: number;
    totalMaintenanceHours: number;
    averageMaintenanceTime: number;
    maintenanceFrequency: number;
    lastMaintenanceDate?: string;
    nextScheduledMaintenance?: string;
  };
}

export const getStandCurrentStatus = async (
  req: Request<{ standId: string }>,
  res: Response<StandCurrentStatusResponse>
): Promise<void> => {
  const { standId } = req.params;
  const { organizationId } = req.query;
  
  try {
    // Validate permissions
    await validateStandAccess(req.user.id, organizationId, standId);
    
    // Get current status
    const currentStatus = await getCurrentStandStatus(standId, organizationId);
    
    // Get status history
    const statusHistory = await getStandStatusHistory(standId, organizationId);
    
    // Get upcoming status changes
    const upcomingChanges = await getUpcomingStatusChanges(standId, organizationId);
    
    // Get analytics
    const analytics = await getStandAnalytics(standId, organizationId);
    
    // Get stand information
    const stand = await getStandById(standId, organizationId);
    
    res.json({
      standId,
      standCode: stand.code,
      standName: stand.name,
      currentStatus,
      statusHistory,
      upcomingStatusChanges: upcomingChanges,
      analytics
    });
  } catch (error) {
    handleApiError(error, res);
  }
};
```

#### Update Stand Status (Manual Override)
```typescript
/**
 * POST /api/v1/stands/{standId}/status
 * Manually update stand status (override automatic status)
 */
interface UpdateStandStatusRequest {
  newStatus: string;
  reason: string;
  impactLevel: string;
  effectiveFrom?: string;
  effectiveTo?: string;
  operationalImpact?: {
    capacityReduction?: number;
    restrictions?: string[];
    affectedServices?: string[];
  };
  overrideReason: string;
  notifyStakeholders: boolean;
}

interface UpdateStandStatusResponse {
  success: boolean;
  standId: string;
  oldStatus: string;
  newStatus: string;
  effectiveFrom: string;
  statusHistoryId: string;
  notificationsSent: string[];
}

export const updateStandStatus = async (
  req: Request<{ standId: string }, UpdateStandStatusResponse, UpdateStandStatusRequest>,
  res: Response<UpdateStandStatusResponse>
): Promise<void> => {
  const { standId } = req.params;
  const { organizationId } = req.query;
  const statusUpdate = req.body;
  
  try {
    // Validate permissions
    await validateStandStatusUpdatePermission(req.user.id, organizationId, standId);
    
    // Validate status transition
    const currentStatus = await getCurrentStandStatus(standId, organizationId);
    await validateStatusTransition(currentStatus.status, statusUpdate.newStatus);
    
    // Create status history record
    const statusHistoryId = await createStatusHistoryRecord({
      standId,
      organizationId,
      fromStatus: currentStatus.status,
      toStatus: statusUpdate.newStatus,
      statusReason: statusUpdate.reason,
      impactLevel: statusUpdate.impactLevel,
      effectiveFrom: statusUpdate.effectiveFrom || new Date().toISOString(),
      effectiveTo: statusUpdate.effectiveTo,
      operationalImpact: statusUpdate.operationalImpact,
      changeSource: 'manual',
      automatedChange: false,
      overrideReason: statusUpdate.overrideReason,
      createdBy: req.user.id,
      createdByName: req.user.name
    });
    
    // Update stand status
    await updateStandCurrentStatus(standId, statusUpdate.newStatus);
    
    // Send notifications if requested
    const notificationsSent = [];
    if (statusUpdate.notifyStakeholders) {
      notificationsSent.push(...await sendStatusChangeNotifications(standId, currentStatus.status, statusUpdate.newStatus));
    }
    
    // Emit real-time event
    await emitStatusChangeEvent(standId, currentStatus.status, statusUpdate.newStatus);
    
    // Log audit event
    await logAuditEvent('stand_status_updated', {
      userId: req.user.id,
      standId,
      organizationId,
      oldStatus: currentStatus.status,
      newStatus: statusUpdate.newStatus,
      manual: true
    });
    
    res.json({
      success: true,
      standId,
      oldStatus: currentStatus.status,
      newStatus: statusUpdate.newStatus,
      effectiveFrom: statusUpdate.effectiveFrom || new Date().toISOString(),
      statusHistoryId,
      notificationsSent
    });
  } catch (error) {
    handleApiError(error, res);
  }
};
```

## Event-Driven Architecture

### Event System Implementation

#### Event Types
```typescript
// Event type definitions
interface WorkRequestStatusChangedEvent {
  type: 'work_request_status_changed';
  workRequestId: string;
  standId: string;
  organizationId: string;
  oldStatus: string;
  newStatus: string;
  standStatusImpact: string;
  scheduledStartDate?: string;
  scheduledEndDate?: string;
  userId: string;
  timestamp: string;
  metadata: {
    workType: string;
    priority: string;
    impactLevel: string;
    estimatedDuration?: number;
  };
}

interface StandStatusChangedEvent {
  type: 'stand_status_changed';
  standId: string;
  standCode: string;
  organizationId: string;
  oldStatus: string;
  newStatus: string;
  changeSource: 'work_request' | 'manual' | 'system';
  workRequestId?: string;
  effectiveFrom: string;
  effectiveTo?: string;
  userId: string;
  timestamp: string;
  metadata: {
    impactLevel: string;
    operationalImpact: any;
    reason?: string;
  };
}

interface WorkRequestApprovedEvent {
  type: 'work_request_approved';
  workRequestId: string;
  standId: string;
  organizationId: string;
  scheduledStartDate: string;
  scheduledEndDate?: string;
  standStatusImpact: string;
  approvedBy: string;
  timestamp: string;
  metadata: {
    workType: string;
    priority: string;
    estimatedCost?: number;
  };
}
```

#### Event Publisher
```typescript
import { EventEmitter } from 'events';
import Redis from 'ioredis';

class EventPublisher extends EventEmitter {
  private redis: Redis;
  
  constructor() {
    super();
    this.redis = new Redis(process.env.REDIS_URL);
  }
  
  async publishWorkRequestStatusChanged(event: WorkRequestStatusChangedEvent): Promise<void> {
    try {
      // Publish to Redis pub/sub
      await this.redis.publish('work_request_events', JSON.stringify(event));
      
      // Emit local event
      this.emit('work_request_status_changed', event);
      
      // Log event
      console.log('Published work request status changed event:', event.workRequestId);
    } catch (error) {
      console.error('Failed to publish work request status changed event:', error);
      throw error;
    }
  }
  
  async publishStandStatusChanged(event: StandStatusChangedEvent): Promise<void> {
    try {
      // Publish to Redis pub/sub
      await this.redis.publish('stand_events', JSON.stringify(event));
      
      // Emit local event
      this.emit('stand_status_changed', event);
      
      // Log event
      console.log('Published stand status changed event:', event.standId);
    } catch (error) {
      console.error('Failed to publish stand status changed event:', error);
      throw error;
    }
  }
  
  async publishWorkRequestApproved(event: WorkRequestApprovedEvent): Promise<void> {
    try {
      // Publish to Redis pub/sub
      await this.redis.publish('work_request_events', JSON.stringify(event));
      
      // Emit local event
      this.emit('work_request_approved', event);
      
      // Log event
      console.log('Published work request approved event:', event.workRequestId);
    } catch (error) {
      console.error('Failed to publish work request approved event:', error);
      throw error;
    }
  }
}

export const eventPublisher = new EventPublisher();
```

#### Event Handlers
```typescript
import { eventPublisher } from './event-publisher';

class StandStatusEventHandler {
  constructor() {
    this.setupEventHandlers();
  }
  
  private setupEventHandlers(): void {
    // Handle work request status changes
    eventPublisher.on('work_request_status_changed', this.handleWorkRequestStatusChanged.bind(this));
    
    // Handle work request approvals
    eventPublisher.on('work_request_approved', this.handleWorkRequestApproved.bind(this));
    
    // Handle stand status changes
    eventPublisher.on('stand_status_changed', this.handleStandStatusChanged.bind(this));
  }
  
  private async handleWorkRequestStatusChanged(event: WorkRequestStatusChangedEvent): Promise<void> {
    try {
      console.log('Handling work request status change:', event.workRequestId);
      
      // Determine if stand status should change
      const shouldUpdateStatus = await this.shouldUpdateStandStatus(event);
      
      if (shouldUpdateStatus) {
        const newStandStatus = await this.calculateNewStandStatus(event);
        await this.updateStandStatus(event.standId, newStandStatus, event);
      }
      
      // Update analytics
      await this.updateStandAnalytics(event.standId, event.organizationId);
      
      // Send notifications
      await this.sendStatusChangeNotifications(event);
      
    } catch (error) {
      console.error('Error handling work request status change:', error);
      // Implement retry logic or dead letter queue
    }
  }
  
  private async handleWorkRequestApproved(event: WorkRequestApprovedEvent): Promise<void> {
    try {
      console.log('Handling work request approval:', event.workRequestId);
      
      // Schedule future status change if needed
      if (event.standStatusImpact !== 'no_impact') {
        await this.scheduleStatusChange(event);
      }
      
      // Update future work visibility
      await this.updateFutureWorkVisibility(event.standId, event.organizationId);
      
    } catch (error) {
      console.error('Error handling work request approval:', error);
    }
  }
  
  private async handleStandStatusChanged(event: StandStatusChangedEvent): Promise<void> {
    try {
      console.log('Handling stand status change:', event.standId);
      
      // Update real-time dashboards
      await this.updateRealTimeDashboards(event);
      
      // Send notifications to stakeholders
      await this.notifyStakeholders(event);
      
      // Update capacity planning systems
      await this.updateCapacityPlanning(event);
      
    } catch (error) {
      console.error('Error handling stand status change:', error);
    }
  }
  
  private async shouldUpdateStandStatus(event: WorkRequestStatusChangedEvent): Promise<boolean> {
    // Business logic to determine if stand status should change
    const statusTransitions = {
      'approved': event.standStatusImpact !== 'no_impact',
      'in_progress': event.standStatusImpact !== 'no_impact',
      'completed': true, // Always revert to operational
      'cancelled': true, // Revert to operational
      'rejected': false // No status change
    };
    
    return statusTransitions[event.newStatus] || false;
  }
  
  private async calculateNewStandStatus(event: WorkRequestStatusChangedEvent): Promise<string> {
    // Calculate new stand status based on work request status and impact
    const statusMapping = {
      'approved': event.standStatusImpact === 'full_closure' ? 'maintenance' : 'operational',
      'in_progress': event.standStatusImpact === 'full_closure' ? 'maintenance' : 'restricted',
      'completed': 'operational',
      'cancelled': 'operational'
    };
    
    return statusMapping[event.newStatus] || 'operational';
  }
  
  private async updateStandStatus(standId: string, newStatus: string, event: WorkRequestStatusChangedEvent): Promise<void> {
    // Create status history record
    await createStatusHistoryRecord({
      standId,
      organizationId: event.organizationId,
      fromStatus: await getCurrentStandStatus(standId, event.organizationId),
      toStatus: newStatus,
      statusReason: `Work request ${event.newStatus}`,
      impactLevel: event.metadata.impactLevel,
      workRequestId: event.workRequestId,
      workRequestTitle: await getWorkRequestTitle(event.workRequestId),
      workType: event.metadata.workType,
      changeSource: 'work_request',
      automatedChange: true,
      createdBy: event.userId,
      createdByName: await getUserName(event.userId)
    });
    
    // Update current status
    await updateStandCurrentStatus(standId, newStatus);
    
    // Emit stand status changed event
    await eventPublisher.publishStandStatusChanged({
      type: 'stand_status_changed',
      standId,
      standCode: await getStandCode(standId),
      organizationId: event.organizationId,
      oldStatus: await getCurrentStandStatus(standId, event.organizationId),
      newStatus,
      changeSource: 'work_request',
      workRequestId: event.workRequestId,
      effectiveFrom: new Date().toISOString(),
      userId: event.userId,
      timestamp: new Date().toISOString(),
      metadata: {
        impactLevel: event.metadata.impactLevel,
        operationalImpact: {},
        reason: `Work request ${event.newStatus}`
      }
    });
  }
}

export const standStatusEventHandler = new StandStatusEventHandler();
```

## Service Layer Implementation

### Stand History Service
```typescript
import { Pool } from 'pg';
import { Redis } from 'ioredis';

interface StandHistoryFilters {
  dateRange?: { startDate: string; endDate: string };
  workTypes?: string[];
  statuses?: string[];
  priorities?: string[];
  categories?: string[];
  costRange?: { min: number; max: number };
}

class StandHistoryService {
  private db: Pool;
  private redis: Redis;
  
  constructor(db: Pool, redis: Redis) {
    this.db = db;
    this.redis = redis;
  }
  
  async getStandWorkRequestHistory(
    standId: string,
    organizationId: string,
    filters?: StandHistoryFilters,
    pagination?: { page: number; limit: number },
    sort?: { field: string; direction: 'asc' | 'desc' }
  ): Promise<any> {
    const cacheKey = `stand_history:${standId}:${JSON.stringify({ filters, pagination, sort })}`;
    
    // Try cache first
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // Build query
    let query = `
      SELECT 
        wr.id,
        wr.title,
        wr.description,
        wr.work_type,
        wr.category,
        wr.priority,
        wr.status,
        wr.stand_status_impact,
        wr.requested_start_date,
        wr.requested_end_date,
        wr.actual_start_date,
        wr.actual_end_date,
        wr.estimated_total_cost,
        wr.requested_by,
        wr.requestor_name,
        wr.created_at,
        wr.submission_date,
        wr.approved_date,
        wr.completed_date,
        CASE 
          WHEN wr.actual_end_date IS NOT NULL AND wr.actual_start_date IS NOT NULL 
          THEN EXTRACT(EPOCH FROM (wr.actual_end_date - wr.actual_start_date))/3600
          ELSE NULL
        END as actual_duration_hours,
        CASE 
          WHEN wr.status = 'completed' THEN 'completed'
          WHEN wr.status = 'in_progress' THEN 'current'
          WHEN wr.status = 'approved' AND wr.requested_start_date > now() THEN 'future'
          ELSE 'historical'
        END as timeline_category
      FROM work.work_requests wr
      JOIN work.work_request_stand_associations wrsa ON wr.id = wrsa.work_request_id
      WHERE wrsa.stand_id = $1 AND wr.organization_id = $2
    `;
    
    const params = [standId, organizationId];
    let paramIndex = 3;
    
    // Apply filters
    if (filters?.dateRange) {
      query += ` AND wr.created_at BETWEEN $${paramIndex} AND $${paramIndex + 1}`;
      params.push(filters.dateRange.startDate, filters.dateRange.endDate);
      paramIndex += 2;
    }
    
    if (filters?.workTypes?.length) {
      query += ` AND wr.work_type = ANY($${paramIndex})`;
      params.push(filters.workTypes);
      paramIndex++;
    }
    
    if (filters?.statuses?.length) {
      query += ` AND wr.status = ANY($${paramIndex})`;
      params.push(filters.statuses);
      paramIndex++;
    }
    
    if (filters?.priorities?.length) {
      query += ` AND wr.priority = ANY($${paramIndex})`;
      params.push(filters.priorities);
      paramIndex++;
    }
    
    if (filters?.categories?.length) {
      query += ` AND wr.category = ANY($${paramIndex})`;
      params.push(filters.categories);
      paramIndex++;
    }
    
    if (filters?.costRange) {
      query += ` AND wr.estimated_total_cost BETWEEN $${paramIndex} AND $${paramIndex + 1}`;
      params.push(filters.costRange.min, filters.costRange.max);
      paramIndex += 2;
    }
    
    // Apply sorting
    const sortField = sort?.field || 'created_at';
    const sortDirection = sort?.direction || 'desc';
    query += ` ORDER BY wr.${sortField} ${sortDirection}`;
    
    // Apply pagination
    if (pagination) {
      const offset = (pagination.page - 1) * pagination.limit;
      query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
      params.push(pagination.limit, offset);
    }
    
    // Execute query
    const result = await this.db.query(query, params);
    
    // Cache result
    await this.redis.setex(cacheKey, 300, JSON.stringify(result.rows)); // Cache for 5 minutes
    
    return result.rows;
  }
  
  async getStandCurrentStatus(standId: string, organizationId: string): Promise<any> {
    const cacheKey = `stand_current_status:${standId}`;
    
    // Try cache first
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    const query = `
      SELECT 
        s.id as stand_id,
        s.code as stand_code,
        s.name as stand_name,
        COALESCE(ssh.to_status, 'operational') as current_status,
        ssh.status_reason,
        ssh.impact_level,
        ssh.work_request_id,
        ssh.work_request_title,
        ssh.work_type,
        ssh.effective_from as status_since,
        ssh.effective_to as status_until,
        ssh.operational_impact,
        ssh.change_source,
        ssh.automated_change,
        EXTRACT(EPOCH FROM (now() - ssh.effective_from))/3600 as hours_in_status,
        CASE 
          WHEN ssh.effective_to IS NOT NULL AND ssh.effective_to <= now() + INTERVAL '24 hours' 
          THEN true 
          ELSE false 
        END as status_change_imminent
      FROM assets.stands s
      LEFT JOIN assets.stand_status_history ssh ON s.id = ssh.stand_id 
        AND (ssh.effective_to IS NULL OR ssh.effective_to > now())
      WHERE s.id = $1 AND s.organization_id = $2
      ORDER BY ssh.effective_from DESC
      LIMIT 1
    `;
    
    const result = await this.db.query(query, [standId, organizationId]);
    const status = result.rows[0];
    
    // Cache result
    await this.redis.setex(cacheKey, 60, JSON.stringify(status)); // Cache for 1 minute
    
    return status;
  }
  
  async getStandStatusHistory(standId: string, organizationId: string, limit: number = 50): Promise<any[]> {
    const query = `
      SELECT 
        id,
        from_status,
        to_status,
        status_reason,
        impact_level,
        effective_from,
        effective_to,
        work_request_id,
        work_request_title,
        work_type,
        change_source,
        automated_change,
        created_by,
        created_by_name
      FROM assets.stand_status_history
      WHERE stand_id = $1 AND organization_id = $2
      ORDER BY effective_from DESC
      LIMIT $3
    `;
    
    const result = await this.db.query(query, [standId, organizationId, limit]);
    return result.rows;
  }
  
  async getUpcomingStatusChanges(standId: string, organizationId: string): Promise<any[]> {
    const query = `
      SELECT 
        wr.requested_start_date as scheduled_date,
        CASE 
          WHEN wr.stand_status_impact = 'full_closure' THEN 'maintenance'
          WHEN wr.stand_status_impact = 'partial_restriction' THEN 'restricted'
          ELSE 'operational'
        END as new_status,
        wr.title as reason,
        wr.id as work_request_id,
        wr.title as work_request_title,
        wr.stand_status_impact as impact_level,
        EXTRACT(EPOCH FROM (wr.requested_end_date - wr.requested_start_date))/3600 as estimated_duration
      FROM work.work_requests wr
      JOIN work.work_request_stand_associations wrsa ON wr.id = wrsa.work_request_id
      WHERE wrsa.stand_id = $1 
        AND wr.organization_id = $2
        AND wr.status = 'approved'
        AND wr.requested_start_date > now()
        AND wr.stand_status_impact != 'no_impact'
      ORDER BY wr.requested_start_date ASC
    `;
    
    const result = await this.db.query(query, [standId, organizationId]);
    return result.rows;
  }
  
  async calculateStandAnalytics(standId: string, organizationId: string): Promise<any> {
    const cacheKey = `stand_analytics:${standId}`;
    
    // Try cache first
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    const query = `
      SELECT 
        COUNT(*) as total_requests,
        COUNT(*) FILTER (WHERE status = 'completed') as completed_requests,
        AVG(EXTRACT(EPOCH FROM (actual_end_date - actual_start_date))/3600) FILTER (WHERE actual_end_date IS NOT NULL) as avg_duration_hours,
        SUM(estimated_total_cost) FILTER (WHERE status = 'completed') as total_cost,
        MAX(completed_date) as last_maintenance_date
      FROM work.work_requests wr
      JOIN work.work_request_stand_associations wrsa ON wr.id = wrsa.work_request_id
      WHERE wrsa.stand_id = $1 
        AND wr.organization_id = $2
        AND wr.created_at >= now() - INTERVAL '1 year'
    `;
    
    const result = await this.db.query(query, [standId, organizationId]);
    const analytics = result.rows[0];
    
    // Calculate availability percentage (simplified)
    const totalHours = 24 * 365; // Hours in a year
    const maintenanceHours = analytics.avg_duration_hours * analytics.completed_requests || 0;
    const availabilityPercentage = ((totalHours - maintenanceHours) / totalHours) * 100;
    
    const finalAnalytics = {
      availabilityPercentage: Math.round(availabilityPercentage * 100) / 100,
      totalMaintenanceHours: maintenanceHours,
      averageMaintenanceTime: analytics.avg_duration_hours || 0,
      maintenanceFrequency: analytics.completed_requests || 0,
      lastMaintenanceDate: analytics.last_maintenance_date,
      nextScheduledMaintenance: await this.getNextScheduledMaintenance(standId, organizationId)
    };
    
    // Cache result
    await this.redis.setex(cacheKey, 3600, JSON.stringify(finalAnalytics)); // Cache for 1 hour
    
    return finalAnalytics;
  }
  
  private async getNextScheduledMaintenance(standId: string, organizationId: string): Promise<string | null> {
    const query = `
      SELECT MIN(requested_start_date) as next_maintenance
      FROM work.work_requests wr
      JOIN work.work_request_stand_associations wrsa ON wr.id = wrsa.work_request_id
      WHERE wrsa.stand_id = $1 
        AND wr.organization_id = $2
        AND wr.status = 'approved'
        AND wr.requested_start_date > now()
    `;
    
    const result = await this.db.query(query, [standId, organizationId]);
    return result.rows[0]?.next_maintenance || null;
  }
}

export { StandHistoryService };
```

### Stand Status Management Service
```typescript
class StandStatusManagementService {
  private db: Pool;
  private redis: Redis;
  private eventPublisher: EventPublisher;
  
  constructor(db: Pool, redis: Redis, eventPublisher: EventPublisher) {
    this.db = db;
    this.redis = redis;
    this.eventPublisher = eventPublisher;
  }
  
  async createStatusHistoryRecord(statusData: {
    standId: string;
    organizationId: string;
    fromStatus?: string;
    toStatus: string;
    statusReason?: string;
    impactLevel: string;
    effectiveFrom?: string;
    effectiveTo?: string;
    workRequestId?: string;
    workRequestTitle?: string;
    workType?: string;
    operationalImpact?: any;
    changeSource: string;
    automatedChange: boolean;
    overrideReason?: string;
    createdBy: string;
    createdByName: string;
  }): Promise<string> {
    const query = `
      INSERT INTO assets.stand_status_history (
        organization_id,
        stand_id,
        stand_code,
        from_status,
        to_status,
        status_reason,
        impact_level,
        effective_from,
        effective_to,
        work_request_id,
        work_request_title,
        work_type,
        operational_impact,
        change_source,
        automated_change,
        override_reason,
        created_by,
        created_by_name
      ) VALUES (
        $1, $2, (SELECT code FROM assets.stands WHERE id = $2), $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
      ) RETURNING id
    `;
    
    const values = [
      statusData.organizationId,
      statusData.standId,
      statusData.fromStatus,
      statusData.toStatus,
      statusData.statusReason,
      statusData.impactLevel,
      statusData.effectiveFrom || new Date().toISOString(),
      statusData.effectiveTo,
      statusData.workRequestId,
      statusData.workRequestTitle,
      statusData.workType,
      JSON.stringify(statusData.operationalImpact || {}),
      statusData.changeSource,
      statusData.automatedChange,
      statusData.overrideReason,
      statusData.createdBy,
      statusData.createdByName
    ];
    
    const result = await this.db.query(query, values);
    
    // Invalidate cache
    await this.redis.del(`stand_current_status:${statusData.standId}`);
    
    return result.rows[0].id;
  }
  
  async updateStandCurrentStatus(standId: string, newStatus: string): Promise<void> {
    // Update the current status in the stands table
    const query = `
      UPDATE assets.stands 
      SET 
        current_status = $1,
        status_updated_at = now()
      WHERE id = $2
    `;
    
    await this.db.query(query, [newStatus, standId]);
    
    // Invalidate cache
    await this.redis.del(`stand_current_status:${standId}`);
  }
  
  async validateStatusTransition(currentStatus: string, newStatus: string): Promise<boolean> {
    // Define valid status transitions
    const validTransitions: { [key: string]: string[] } = {
      'operational': ['maintenance', 'restricted', 'closed', 'emergency'],
      'maintenance': ['operational', 'closed', 'emergency'],
      'restricted': ['operational', 'maintenance', 'closed', 'emergency'],
      'closed': ['operational', 'maintenance', 'emergency'],
      'emergency': ['operational', 'maintenance', 'restricted', 'closed']
    };
    
    const allowedTransitions = validTransitions[currentStatus] || [];
    
    if (!allowedTransitions.includes(newStatus)) {
      throw new Error(`Invalid status transition from ${currentStatus} to ${newStatus}`);
    }
    
    return true;
  }
  
  async scheduleStatusChange(event: WorkRequestApprovedEvent): Promise<void> {
    // Create future status change record
    const statusHistoryId = await this.createStatusHistoryRecord({
      standId: event.standId,
      organizationId: event.organizationId,
      fromStatus: await this.getCurrentStandStatus(event.standId),
      toStatus: event.standStatusImpact === 'full_closure' ? 'maintenance' : 'restricted',
      statusReason: 'Scheduled maintenance work',
      impactLevel: event.standStatusImpact,
      effectiveFrom: event.scheduledStartDate,
      effectiveTo: event.scheduledEndDate,
      workRequestId: event.workRequestId,
      workRequestTitle: await this.getWorkRequestTitle(event.workRequestId),
      workType: event.metadata.workType,
      changeSource: 'work_request',
      automatedChange: true,
      createdBy: event.approvedBy,
      createdByName: await this.getUserName(event.approvedBy)
    });
    
    // Schedule the actual status change
    await this.scheduleStatusChangeJob(event.standId, event.scheduledStartDate, statusHistoryId);
  }
  
  private async scheduleStatusChangeJob(standId: string, scheduledDate: string, statusHistoryId: string): Promise<void> {
    // Use a job queue (like Bull) to schedule the status change
    // This is a simplified implementation
    const delay = new Date(scheduledDate).getTime() - Date.now();
    
    if (delay > 0) {
      setTimeout(async () => {
        await this.executeScheduledStatusChange(standId, statusHistoryId);
      }, delay);
    }
  }
  
  private async executeScheduledStatusChange(standId: string, statusHistoryId: string): Promise<void> {
    try {
      // Get the scheduled status change
      const statusChange = await this.getStatusHistoryRecord(statusHistoryId);
      
      if (!statusChange) {
        console.error('Status change record not found:', statusHistoryId);
        return;
      }
      
      // Update the stand status
      await this.updateStandCurrentStatus(standId, statusChange.to_status);
      
      // Emit event
      await this.eventPublisher.publishStandStatusChanged({
        type: 'stand_status_changed',
        standId,
        standCode: await this.getStandCode(standId),
        organizationId: statusChange.organization_id,
        oldStatus: statusChange.from_status,
        newStatus: statusChange.to_status,
        changeSource: 'work_request',
        workRequestId: statusChange.work_request_id,
        effectiveFrom: statusChange.effective_from,
        effectiveTo: statusChange.effective_to,
        userId: statusChange.created_by,
        timestamp: new Date().toISOString(),
        metadata: {
          impactLevel: statusChange.impact_level,
          operationalImpact: statusChange.operational_impact,
          reason: statusChange.status_reason
        }
      });
      
    } catch (error) {
      console.error('Error executing scheduled status change:', error);
    }
  }
  
  private async getCurrentStandStatus(standId: string): Promise<string> {
    const query = `SELECT current_status FROM assets.stands WHERE id = $1`;
    const result = await this.db.query(query, [standId]);
    return result.rows[0]?.current_status || 'operational';
  }
  
  private async getStandCode(standId: string): Promise<string> {
    const query = `SELECT code FROM assets.stands WHERE id = $1`;
    const result = await this.db.query(query, [standId]);
    return result.rows[0]?.code || '';
  }
  
  private async getWorkRequestTitle(workRequestId: string): Promise<string> {
    const query = `SELECT title FROM work.work_requests WHERE id = $1`;
    const result = await this.db.query(query, [workRequestId]);
    return result.rows[0]?.title || '';
  }
  
  private async getUserName(userId: string): Promise<string> {
    const query = `SELECT name FROM users WHERE id = $1`;
    const result = await this.db.query(query, [userId]);
    return result.rows[0]?.name || 'Unknown User';
  }
  
  private async getStatusHistoryRecord(statusHistoryId: string): Promise<any> {
    const query = `SELECT * FROM assets.stand_status_history WHERE id = $1`;
    const result = await this.db.query(query, [statusHistoryId]);
    return result.rows[0];
  }
}

export { StandStatusManagementService };
```

## Frontend Integration

### Stand Detail Page Enhancements
```typescript
// Stand Detail Page Component
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { StandHistoryTimeline } from './components/StandHistoryTimeline';
import { StandCurrentStatus } from './components/StandCurrentStatus';
import { StandFutureWork } from './components/StandFutureWork';
import { StandAnalytics } from './components/StandAnalytics';
import { useStandHistory } from './hooks/useStandHistory';
import { useStandStatus } from './hooks/useStandStatus';
import { useRealTimeUpdates } from './hooks/useRealTimeUpdates';

interface StandDetailPageProps {
  standId: string;
}

export const StandDetailPage: React.FC<StandDetailPageProps> = ({ standId }) => {
  const { organizationId } = useParams();
  const [activeTab, setActiveTab] = useState<'history' | 'status' | 'future' | 'analytics'>('history');
  const [historyFilters, setHistoryFilters] = useState({});
  
  // Custom hooks for data fetching
  const { 
    workRequestHistory, 
    loading: historyLoading, 
    error: historyError,
    refetch: refetchHistory 
  } = useStandHistory(standId, organizationId, historyFilters);
  
  const { 
    currentStatus, 
    statusHistory, 
    upcomingChanges, 
    analytics,
    loading: statusLoading,
    error: statusError,
    refetch: refetchStatus
  } = useStandStatus(standId, organizationId);
  
  // Real-time updates
  useRealTimeUpdates(standId, {
    onStatusChange: () => {
      refetchStatus();
      refetchHistory();
    },
    onWorkRequestUpdate: () => {
      refetchHistory();
    }
  });
  
  const handleFilterChange = (newFilters: any) => {
    setHistoryFilters(newFilters);
  };
  
  const handleStatusUpdate = async (statusUpdate: any) => {
    try {
      await updateStandStatus(standId, statusUpdate);
      refetchStatus();
    } catch (error) {
      console.error('Failed to update stand status:', error);
    }
  };
  
  if (historyLoading || statusLoading) {
    return <div className="loading-spinner">Loading stand information...</div>;
  }
  
  if (historyError || statusError) {
    return <div className="error-message">Error loading stand information</div>;
  }
  
  return (
    <div className="stand-detail-page">
      <div className="stand-header">
        <h1>{currentStatus?.standName} ({currentStatus?.standCode})</h1>
        <div className="current-status-badge">
          <span className={`status-indicator ${currentStatus?.currentStatus?.status}`}>
            {currentStatus?.currentStatus?.status}
          </span>
        </div>
      </div>
      
      <div className="tab-navigation">
        <button 
          className={activeTab === 'history' ? 'active' : ''}
          onClick={() => setActiveTab('history')}
        >
          Work Request History
        </button>
        <button 
          className={activeTab === 'status' ? 'active' : ''}
          onClick={() => setActiveTab('status')}
        >
          Current Status
        </button>
        <button 
          className={activeTab === 'future' ? 'active' : ''}
          onClick={() => setActiveTab('future')}
        >
          Future Work
        </button>
        <button 
          className={activeTab === 'analytics' ? 'active' : ''}
          onClick={() => setActiveTab('analytics')}
        >
          Analytics
        </button>
      </div>
      
      <div className="tab-content">
        {activeTab === 'history' && (
          <StandHistoryTimeline 
            workRequestHistory={workRequestHistory}
            onFilterChange={handleFilterChange}
            filters={historyFilters}
          />
        )}
        
        {activeTab === 'status' && (
          <StandCurrentStatus 
            currentStatus={currentStatus}
            statusHistory={statusHistory}
            onStatusUpdate={handleStatusUpdate}
          />
        )}
        
        {activeTab === 'future' && (
          <StandFutureWork 
            upcomingChanges={upcomingChanges}
            standId={standId}
          />
        )}
        
        {activeTab === 'analytics' && (
          <StandAnalytics 
            analytics={analytics}
            standId={standId}
          />
        )}
      </div>
    </div>
  );
};
```

### Stand History Timeline Component
```typescript
import React, { useState } from 'react';
import { format } from 'date-fns';
import { WorkRequestModal } from './WorkRequestModal';
import { FilterPanel } from './FilterPanel';

interface StandHistoryTimelineProps {
  workRequestHistory: any[];
  onFilterChange: (filters: any) => void;
  filters: any;
}

export const StandHistoryTimeline: React.FC<StandHistoryTimelineProps> = ({
  workRequestHistory,
  onFilterChange,
  filters
}) => {
  const [selectedWorkRequest, setSelectedWorkRequest] = useState<any>(null);
  const [showFilters, setShowFilters] = useState(false);
  
  const getStatusColor = (status: string) => {
    const colors = {
      'completed': 'green',
      'in_progress': 'blue',
      'approved': 'orange',
      'rejected': 'red',
      'cancelled': 'gray'
    };
    return colors[status] || 'gray';
  };
  
  const getTimelineCategory = (workRequest: any) => {
    if (workRequest.status === 'completed') return 'completed';
    if (workRequest.status === 'in_progress') return 'current';
    if (workRequest.status === 'approved' && new Date(workRequest.requestedStartDate) > new Date()) return 'future';
    return 'historical';
  };
  
  const groupedHistory = workRequestHistory.reduce((groups, workRequest) => {
    const category = getTimelineCategory(workRequest);
    if (!groups[category]) groups[category] = [];
    groups[category].push(workRequest);
    return groups;
  }, {});
  
  return (
    <div className="stand-history-timeline">
      <div className="timeline-header">
        <h2>Work Request History</h2>
        <div className="timeline-controls">
          <button 
            className="filter-button"
            onClick={() => setShowFilters(!showFilters)}
          >
            Filters
          </button>
          <div className="timeline-summary">
            Total: {workRequestHistory.length} requests
          </div>
        </div>
      </div>
      
      {showFilters && (
        <FilterPanel 
          filters={filters}
          onFilterChange={onFilterChange}
          onClose={() => setShowFilters(false)}
        />
      )}
      
      <div className="timeline-sections">
        {/* Current Work */}
        {groupedHistory.current && (
          <div className="timeline-section current">
            <h3>Current Work</h3>
            <div className="timeline-items">
              {groupedHistory.current.map((workRequest: any) => (
                <TimelineItem
                  key={workRequest.id}
                  workRequest={workRequest}
                  onClick={() => setSelectedWorkRequest(workRequest)}
                />
              ))}
            </div>
          </div>
        )}
        
        {/* Future Work */}
        {groupedHistory.future && (
          <div className="timeline-section future">
            <h3>Scheduled Work</h3>
            <div className="timeline-items">
              {groupedHistory.future.map((workRequest: any) => (
                <TimelineItem
                  key={workRequest.id}
                  workRequest={workRequest}
                  onClick={() => setSelectedWorkRequest(workRequest)}
                />
              ))}
            </div>
          </div>
        )}
        
        {/* Historical Work */}
        {groupedHistory.completed && (
          <div className="timeline-section completed">
            <h3>Completed Work</h3>
            <div className="timeline-items">
              {groupedHistory.completed.map((workRequest: any) => (
                <TimelineItem
                  key={workRequest.id}
                  workRequest={workRequest}
                  onClick={() => setSelectedWorkRequest(workRequest)}
                />
              ))}
            </div>
          </div>
        )}
        
        {/* Other Historical Work */}
        {groupedHistory.historical && (
          <div className="timeline-section historical">
            <h3>Historical Work</h3>
            <div className="timeline-items">
              {groupedHistory.historical.map((workRequest: any) => (
                <TimelineItem
                  key={workRequest.id}
                  workRequest={workRequest}
                  onClick={() => setSelectedWorkRequest(workRequest)}
                />
              ))}
            </div>
          </div>
        )}
      </div>
      
      {selectedWorkRequest && (
        <WorkRequestModal
          workRequest={selectedWorkRequest}
          onClose={() => setSelectedWorkRequest(null)}
        />
      )}
    </div>
  );
};

interface TimelineItemProps {
  workRequest: any;
  onClick: () => void;
}

const TimelineItem: React.FC<TimelineItemProps> = ({ workRequest, onClick }) => {
  const statusColor = getStatusColor(workRequest.status);
  
  return (
    <div className="timeline-item" onClick={onClick}>
      <div className="timeline-marker">
        <div className={`status-dot ${statusColor}`}></div>
      </div>
      <div className="timeline-content">
        <div className="timeline-header">
          <h4>{workRequest.title}</h4>
          <span className={`status-badge ${workRequest.status}`}>
            {workRequest.status}
          </span>
        </div>
        <div className="timeline-details">
          <div className="detail-item">
            <span className="label">Type:</span>
            <span className="value">{workRequest.workType}</span>
          </div>
          <div className="detail-item">
            <span className="label">Priority:</span>
            <span className="value">{workRequest.priority}</span>
          </div>
          <div className="detail-item">
            <span className="label">Requested:</span>
            <span className="value">{format(new Date(workRequest.requestedStartDate), 'MMM dd, yyyy')}</span>
          </div>
          {workRequest.estimatedCost && (
            <div className="detail-item">
              <span className="label">Cost:</span>
              <span className="value">${workRequest.estimatedCost.toLocaleString()}</span>
            </div>
          )}
          {workRequest.actualDurationHours && (
            <div className="detail-item">
              <span className="label">Duration:</span>
              <span className="value">{workRequest.actualDurationHours.toFixed(1)} hours</span>
            </div>
          )}
        </div>
        <div className="timeline-description">
          {workRequest.description.length > 100 
            ? `${workRequest.description.substring(0, 100)}...`
            : workRequest.description
          }
        </div>
      </div>
    </div>
  );
};
```

### Real-time Updates Hook
```typescript
import { useEffect, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

interface UseRealTimeUpdatesProps {
  onStatusChange?: () => void;
  onWorkRequestUpdate?: () => void;
}

export const useRealTimeUpdates = (standId: string, callbacks: UseRealTimeUpdatesProps) => {
  const socketRef = useRef<Socket | null>(null);
  
  useEffect(() => {
    // Initialize socket connection
    socketRef.current = io(process.env.REACT_APP_WEBSOCKET_URL || 'ws://localhost:3001', {
      auth: {
        token: localStorage.getItem('authToken')
      }
    });
    
    const socket = socketRef.current;
    
    // Join stand-specific room
    socket.emit('join_stand_room', standId);
    
    // Listen for stand status changes
    socket.on('stand_status_changed', (event) => {
      if (event.standId === standId) {
        callbacks.onStatusChange?.();
      }
    });
    
    // Listen for work request updates
    socket.on('work_request_updated', (event) => {
      if (event.standId === standId) {
        callbacks.onWorkRequestUpdate?.();
      }
    });
    
    // Handle connection errors
    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
    });
    
    return () => {
      if (socket) {
        socket.emit('leave_stand_room', standId);
        socket.disconnect();
      }
    };
  }, [standId, callbacks]);
  
  return {
    isConnected: socketRef.current?.connected || false
  };
};
```

## Testing Strategy

### Unit Tests
```typescript
// StandHistoryService.test.ts
import { StandHistoryService } from '../services/StandHistoryService';
import { Pool } from 'pg';
import { Redis } from 'ioredis';

describe('StandHistoryService', () => {
  let service: StandHistoryService;
  let mockDb: jest.Mocked<Pool>;
  let mockRedis: jest.Mocked<Redis>;
  
  beforeEach(() => {
    mockDb = {
      query: jest.fn()
    } as any;
    
    mockRedis = {
      get: jest.fn(),
      setex: jest.fn(),
      del: jest.fn()
    } as any;
    
    service = new StandHistoryService(mockDb, mockRedis);
  });
  
  describe('getStandWorkRequestHistory', () => {
    it('should return cached data when available', async () => {
      const cachedData = JSON.stringify([{ id: '1', title: 'Test Work Request' }]);
      mockRedis.get.mockResolvedValue(cachedData);
      
      const result = await service.getStandWorkRequestHistory('stand-1', 'org-1');
      
      expect(result).toEqual([{ id: '1', title: 'Test Work Request' }]);
      expect(mockRedis.get).toHaveBeenCalledWith(expect.stringContaining('stand_history:stand-1'));
      expect(mockDb.query).not.toHaveBeenCalled();
    });
    
    it('should query database when cache is empty', async () => {
      mockRedis.get.mockResolvedValue(null);
      mockDb.query.mockResolvedValue({
        rows: [{ id: '1', title: 'Test Work Request' }]
      } as any);
      
      const result = await service.getStandWorkRequestHistory('stand-1', 'org-1');
      
      expect(result).toEqual([{ id: '1', title: 'Test Work Request' }]);
      expect(mockDb.query).toHaveBeenCalled();
      expect(mockRedis.setex).toHaveBeenCalled();
    });
    
    it('should apply filters correctly', async () => {
      mockRedis.get.mockResolvedValue(null);
      mockDb.query.mockResolvedValue({ rows: [] } as any);
      
      const filters = {
        dateRange: { startDate: '2024-01-01', endDate: '2024-12-31' },
        workTypes: ['maintenance', 'repair'],
        statuses: ['completed']
      };
      
      await service.getStandWorkRequestHistory('stand-1', 'org-1', filters);
      
      const queryCall = mockDb.query.mock.calls[0];
      const query = queryCall[0];
      const params = queryCall[1];
      
      expect(query).toContain('wr.created_at BETWEEN');
      expect(query).toContain('wr.work_type = ANY');
      expect(query).toContain('wr.status = ANY');
      expect(params).toContain('2024-01-01');
      expect(params).toContain('2024-12-31');
      expect(params).toContain(['maintenance', 'repair']);
      expect(params).toContain(['completed']);
    });
  });
  
  describe('getStandCurrentStatus', () => {
    it('should return current status with all required fields', async () => {
      const mockStatus = {
        stand_id: 'stand-1',
        stand_code: 'A01',
        stand_name: 'Stand A01',
        current_status: 'operational',
        hours_in_status: 24.5,
        status_change_imminent: false
      };
      
      mockRedis.get.mockResolvedValue(null);
      mockDb.query.mockResolvedValue({ rows: [mockStatus] } as any);
      
      const result = await service.getStandCurrentStatus('stand-1', 'org-1');
      
      expect(result).toEqual(mockStatus);
      expect(mockRedis.setex).toHaveBeenCalledWith(
        'stand_current_status:stand-1',
        60,
        JSON.stringify(mockStatus)
      );
    });
  });
});
```

### Integration Tests
```typescript
// StandHistoryIntegration.test.ts
import request from 'supertest';
import { app } from '../app';
import { setupTestDatabase, cleanupTestDatabase } from '../test-utils/database';
import { createTestUser, createTestStand, createTestWorkRequest } from '../test-utils/fixtures';

describe('Stand History Integration', () => {
  let testUser: any;
  let testStand: any;
  let testWorkRequest: any;
  let authToken: string;
  
  beforeAll(async () => {
    await setupTestDatabase();
    testUser = await createTestUser();
    testStand = await createTestStand(testUser.organizationId);
    testWorkRequest = await createTestWorkRequest(testStand.id, testUser.id);
    authToken = generateAuthToken(testUser);
  });
  
  afterAll(async () => {
    await cleanupTestDatabase();
  });
  
  describe('GET /api/v1/stands/:standId/work-requests', () => {
    it('should return work request history for a stand', async () => {
      const response = await request(app)
        .get(`/api/v1/stands/${testStand.id}/work-requests`)
        .set('Authorization', `Bearer ${authToken}`)
        .query({ organizationId: testUser.organizationId })
        .expect(200);
      
      expect(response.body).toHaveProperty('standId', testStand.id);
      expect(response.body).toHaveProperty('workRequests');
      expect(response.body.workRequests).toBeInstanceOf(Array);
      expect(response.body.workRequests.length).toBeGreaterThan(0);
      
      const workRequest = response.body.workRequests[0];
      expect(workRequest).toHaveProperty('id');
      expect(workRequest).toHaveProperty('title');
      expect(workRequest).toHaveProperty('status');
      expect(workRequest).toHaveProperty('workType');
    });
    
    it('should apply filters correctly', async () => {
      const response = await request(app)
        .get(`/api/v1/stands/${testStand.id}/work-requests`)
        .set('Authorization', `Bearer ${authToken}`)
        .query({ 
          organizationId: testUser.organizationId,
          'filters[workTypes]': ['maintenance'],
          'filters[statuses]': ['completed']
        })
        .expect(200);
      
      expect(response.body.workRequests).toBeInstanceOf(Array);
      // All returned work requests should match the filters
      response.body.workRequests.forEach((wr: any) => {
        expect(wr.workType).toBe('maintenance');
        expect(wr.status).toBe('completed');
      });
    });
    
    it('should return 401 for unauthenticated requests', async () => {
      await request(app)
        .get(`/api/v1/stands/${testStand.id}/work-requests`)
        .expect(401);
    });
    
    it('should return 403 for unauthorized access', async () => {
      const otherUser = await createTestUser();
      const otherAuthToken = generateAuthToken(otherUser);
      
      await request(app)
        .get(`/api/v1/stands/${testStand.id}/work-requests`)
        .set('Authorization', `Bearer ${otherAuthToken}`)
        .query({ organizationId: testUser.organizationId })
        .expect(403);
    });
  });
  
  describe('GET /api/v1/stands/:standId/status', () => {
    it('should return current status and history', async () => {
      const response = await request(app)
        .get(`/api/v1/stands/${testStand.id}/status`)
        .set('Authorization', `Bearer ${authToken}`)
        .query({ organizationId: testUser.organizationId })
        .expect(200);
      
      expect(response.body).toHaveProperty('standId', testStand.id);
      expect(response.body).toHaveProperty('currentStatus');
      expect(response.body).toHaveProperty('statusHistory');
      expect(response.body).toHaveProperty('upcomingStatusChanges');
      expect(response.body).toHaveProperty('analytics');
      
      expect(response.body.currentStatus).toHaveProperty('status');
      expect(response.body.currentStatus).toHaveProperty('statusSince');
      expect(response.body.statusHistory).toBeInstanceOf(Array);
    });
  });
  
  describe('POST /api/v1/stands/:standId/status', () => {
    it('should update stand status with manual override', async () => {
      const statusUpdate = {
        newStatus: 'maintenance',
        reason: 'Emergency maintenance required',
        impactLevel: 'full_closure',
        overrideReason: 'Safety issue detected',
        notifyStakeholders: true
      };
      
      const response = await request(app)
        .post(`/api/v1/stands/${testStand.id}/status`)
        .set('Authorization', `Bearer ${authToken}`)
        .query({ organizationId: testUser.organizationId })
        .send(statusUpdate)
        .expect(200);
      
      expect(response.body).toHaveProperty('success', true);
      expect(response.body).toHaveProperty('standId', testStand.id);
      expect(response.body).toHaveProperty('newStatus', 'maintenance');
      expect(response.body).toHaveProperty('statusHistoryId');
    });
    
    it('should reject invalid status transitions', async () => {
      const statusUpdate = {
        newStatus: 'invalid_status',
        reason: 'Test',
        impactLevel: 'no_impact',
        overrideReason: 'Test',
        notifyStakeholders: false
      };
      
      await request(app)
        .post(`/api/v1/stands/${testStand.id}/status`)
        .set('Authorization', `Bearer ${authToken}`)
        .query({ organizationId: testUser.organizationId })
        .send(statusUpdate)
        .expect(400);
    });
  });
});
```

### Event System Tests
```typescript
// EventSystem.test.ts
import { EventPublisher } from '../events/EventPublisher';
import { StandStatusEventHandler } from '../events/StandStatusEventHandler';
import { Redis } from 'ioredis';

describe('Event System', () => {
  let eventPublisher: EventPublisher;
  let eventHandler: StandStatusEventHandler;
  let mockRedis: jest.Mocked<Redis>;
  
  beforeEach(() => {
    mockRedis = {
      publish: jest.fn()
    } as any;
    
    eventPublisher = new EventPublisher();
    eventHandler = new StandStatusEventHandler();
    
    // Mock Redis
    (eventPublisher as any).redis = mockRedis;
  });
  
  describe('WorkRequestStatusChangedEvent', () => {
    it('should publish event and trigger status update', async () => {
      const event: WorkRequestStatusChangedEvent = {
        type: 'work_request_status_changed',
        workRequestId: 'wr-1',
        standId: 'stand-1',
        organizationId: 'org-1',
        oldStatus: 'submitted',
        newStatus: 'approved',
        standStatusImpact: 'full_closure',
        userId: 'user-1',
        timestamp: new Date().toISOString(),
        metadata: {
          workType: 'maintenance',
          priority: 'high',
          impactLevel: 'full_closure'
        }
      };
      
      // Mock the handler method
      const handleSpy = jest.spyOn(eventHandler as any, 'handleWorkRequestStatusChanged');
      
      await eventPublisher.publishWorkRequestStatusChanged(event);
      
      expect(mockRedis.publish).toHaveBeenCalledWith(
        'work_request_events',
        JSON.stringify(event)
      );
      
      // Simulate event handling
      await (eventHandler as any).handleWorkRequestStatusChanged(event);
      
      expect(handleSpy).toHaveBeenCalledWith(event);
    });
  });
  
  describe('StandStatusChangedEvent', () => {
    it('should publish event and trigger notifications', async () => {
      const event: StandStatusChangedEvent = {
        type: 'stand_status_changed',
        standId: 'stand-1',
        standCode: 'A01',
        organizationId: 'org-1',
        oldStatus: 'operational',
        newStatus: 'maintenance',
        changeSource: 'work_request',
        workRequestId: 'wr-1',
        effectiveFrom: new Date().toISOString(),
        userId: 'user-1',
        timestamp: new Date().toISOString(),
        metadata: {
          impactLevel: 'full_closure',
          operationalImpact: {},
          reason: 'Scheduled maintenance'
        }
      };
      
      const handleSpy = jest.spyOn(eventHandler as any, 'handleStandStatusChanged');
      
      await eventPublisher.publishStandStatusChanged(event);
      
      expect(mockRedis.publish).toHaveBeenCalledWith(
        'stand_events',
        JSON.stringify(event)
      );
      
      // Simulate event handling
      await (eventHandler as any).handleStandStatusChanged(event);
      
      expect(handleSpy).toHaveBeenCalledWith(event);
    });
  });
});
```

## Performance Optimization

### Database Optimization
```sql
-- Optimized indexes for common queries
CREATE INDEX CONCURRENTLY idx_work_requests_stand_timeline 
ON work.work_requests(organization_id, status, requested_start_date DESC) 
WHERE status IN ('approved', 'in_progress', 'completed');

CREATE INDEX CONCURRENTLY idx_stand_status_history_current_status 
ON assets.stand_status_history(stand_id, effective_from DESC, effective_to) 
WHERE effective_to IS NULL;

CREATE INDEX CONCURRENTLY idx_work_requests_cost_analysis 
ON work.work_requests(organization_id, work_type, status, estimated_total_cost) 
WHERE status = 'completed' AND estimated_total_cost IS NOT NULL;

-- Partitioning for large tables
CREATE TABLE assets.stand_status_history_y2024 PARTITION OF assets.stand_status_history
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE assets.stand_status_history_y2025 PARTITION OF assets.stand_status_history
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

### Caching Strategy
```typescript
class CacheManager {
  private redis: Redis;
  
  constructor(redis: Redis) {
    this.redis = redis;
  }
  
  // Cache keys
  private getStandStatusKey(standId: string): string {
    return `stand_status:${standId}`;
  }
  
  private getStandHistoryKey(standId: string, filters: any): string {
    return `stand_history:${standId}:${JSON.stringify(filters)}`;
  }
  
  private getStandAnalyticsKey(standId: string): string {
    return `stand_analytics:${standId}`;
  }
  
  // Cache operations
  async cacheStandStatus(standId: string, status: any, ttl: number = 60): Promise<void> {
    await this.redis.setex(this.getStandStatusKey(standId), ttl, JSON.stringify(status));
  }
  
  async getCachedStandStatus(standId: string): Promise<any | null> {
    const cached = await this.redis.get(this.getStandStatusKey(standId));
    return cached ? JSON.parse(cached) : null;
  }
  
  async invalidateStandStatus(standId: string): Promise<void> {
    await this.redis.del(this.getStandStatusKey(standId));
  }
  
  async cacheStandHistory(standId: string, filters: any, history: any, ttl: number = 300): Promise<void> {
    await this.redis.setex(this.getStandHistoryKey(standId, filters), ttl, JSON.stringify(history));
  }
  
  async getCachedStandHistory(standId: string, filters: any): Promise<any | null> {
    const cached = await this.redis.get(this.getStandHistoryKey(standId, filters));
    return cached ? JSON.parse(cached) : null;
  }
  
  async invalidateStandHistory(standId: string): Promise<void> {
    const pattern = `stand_history:${standId}:*`;
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
  
  async cacheStandAnalytics(standId: string, analytics: any, ttl: number = 3600): Promise<void> {
    await this.redis.setex(this.getStandAnalyticsKey(standId), ttl, JSON.stringify(analytics));
  }
  
  async getCachedStandAnalytics(standId: string): Promise<any | null> {
    const cached = await this.redis.get(this.getStandAnalyticsKey(standId));
    return cached ? JSON.parse(cached) : null;
  }
  
  async invalidateStandAnalytics(standId: string): Promise<void> {
    await this.redis.del(this.getStandAnalyticsKey(standId));
  }
  
  // Bulk invalidation
  async invalidateAllStandData(standId: string): Promise<void> {
    await Promise.all([
      this.invalidateStandStatus(standId),
      this.invalidateStandHistory(standId),
      this.invalidateStandAnalytics(standId)
    ]);
  }
}
```

### Query Optimization
```typescript
class OptimizedStandQueries {
  private db: Pool;
  
  constructor(db: Pool) {
    this.db = db;
  }
  
  // Optimized query for stand work request history with pagination
  async getStandWorkRequestHistoryOptimized(
    standId: string,
    organizationId: string,
    filters: any,
    pagination: { page: number; limit: number }
  ): Promise<any> {
    // Use window functions for efficient pagination
    const query = `
      WITH filtered_requests AS (
        SELECT 
          wr.id,
          wr.title,
          wr.description,
          wr.work_type,
          wr.category,
          wr.priority,
          wr.status,
          wr.stand_status_impact,
          wr.requested_start_date,
          wr.requested_end_date,
          wr.actual_start_date,
          wr.actual_end_date,
          wr.estimated_total_cost,
          wr.requested_by,
          wr.requestor_name,
          wr.created_at,
          wr.submission_date,
          wr.approved_date,
          wr.completed_date,
          ROW_NUMBER() OVER (ORDER BY wr.created_at DESC) as row_num,
          COUNT(*) OVER () as total_count
        FROM work.work_requests wr
        JOIN work.work_request_stand_associations wrsa ON wr.id = wrsa.work_request_id
        WHERE wrsa.stand_id = $1 AND wr.organization_id = $2
          ${this.buildFilterConditions(filters)}
      )
      SELECT *,
        CASE 
          WHEN actual_end_date IS NOT NULL AND actual_start_date IS NOT NULL 
          THEN EXTRACT(EPOCH FROM (actual_end_date - actual_start_date))/3600
          ELSE NULL
        END as actual_duration_hours,
        CASE 
          WHEN status = 'completed' THEN 'completed'
          WHEN status = 'in_progress' THEN 'current'
          WHEN status = 'approved' AND requested_start_date > now() THEN 'future'
          ELSE 'historical'
        END as timeline_category
      FROM filtered_requests
      WHERE row_num BETWEEN $3 AND $4
      ORDER BY created_at DESC
    `;
    
    const offset = (pagination.page - 1) * pagination.limit;
    const limit = pagination.limit;
    
    const result = await this.db.query(query, [
      standId,
      organizationId,
      offset + 1,
      offset + limit,
      ...this.getFilterParams(filters)
    ]);
    
    return result.rows;
  }
  
  // Optimized query for stand analytics with pre-calculated metrics
  async getStandAnalyticsOptimized(standId: string, organizationId: string): Promise<any> {
    const query = `
      WITH metrics AS (
        SELECT 
          COUNT(*) as total_requests,
          COUNT(*) FILTER (WHERE status = 'completed') as completed_requests,
          COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_requests,
          AVG(EXTRACT(EPOCH FROM (actual_end_date - actual_start_date))/3600) 
            FILTER (WHERE actual_end_date IS NOT NULL AND actual_start_date IS NOT NULL) as avg_duration_hours,
          SUM(estimated_total_cost) FILTER (WHERE status = 'completed') as total_cost,
          MAX(completed_date) as last_maintenance_date,
          MIN(requested_start_date) FILTER (WHERE status = 'approved' AND requested_start_date > now()) as next_maintenance_date
        FROM work.work_requests wr
        JOIN work.work_request_stand_associations wrsa ON wr.id = wrsa.work_request_id
        WHERE wrsa.stand_id = $1 
          AND wr.organization_id = $2
          AND wr.created_at >= now() - INTERVAL '1 year'
      ),
      availability AS (
        SELECT 
          COALESCE(SUM(EXTRACT(EPOCH FROM (
            COALESCE(effective_to, now()) - effective_from
          ))/3600) FILTER (WHERE to_status IN ('maintenance', 'closed')), 0) as maintenance_hours
        FROM assets.stand_status_history
        WHERE stand_id = $1 
          AND organization_id = $2
          AND effective_from >= now() - INTERVAL '1 year'
      )
      SELECT 
        m.*,
        a.maintenance_hours,
        CASE 
          WHEN a.maintenance_hours > 0 
          THEN ROUND(((8760 - a.maintenance_hours) / 8760 * 100)::numeric, 2)
          ELSE 100.00
        END as availability_percentage
      FROM metrics m
      CROSS JOIN availability a
    `;
    
    const result = await this.db.query(query, [standId, organizationId]);
    return result.rows[0];
  }
  
  private buildFilterConditions(filters: any): string {
    const conditions = [];
    
    if (filters?.dateRange) {
      conditions.push(`AND wr.created_at BETWEEN $${this.paramIndex} AND $${this.paramIndex + 1}`);
    }
    
    if (filters?.workTypes?.length) {
      conditions.push(`AND wr.work_type = ANY($${this.paramIndex})`);
    }
    
    if (filters?.statuses?.length) {
      conditions.push(`AND wr.status = ANY($${this.paramIndex})`);
    }
    
    return conditions.join(' ');
  }
  
  private getFilterParams(filters: any): any[] {
    const params = [];
    
    if (filters?.dateRange) {
      params.push(filters.dateRange.startDate, filters.dateRange.endDate);
    }
    
    if (filters?.workTypes?.length) {
      params.push(filters.workTypes);
    }
    
    if (filters?.statuses?.length) {
      params.push(filters.statuses);
    }
    
    return params;
  }
}
```

## Monitoring and Alerting

### Application Metrics
```typescript
import { register, Counter, Histogram, Gauge } from 'prom-client';

// Metrics definitions
const standStatusChanges = new Counter({
  name: 'stand_status_changes_total',
  help: 'Total number of stand status changes',
  labelNames: ['stand_id', 'from_status', 'to_status', 'change_source']
});

const workRequestProcessingTime = new Histogram({
  name: 'work_request_processing_duration_seconds',
  help: 'Time taken to process work requests',
  labelNames: ['operation', 'status'],
  buckets: [0.1, 0.5, 1, 2, 5, 10, 30]
});

const standHistoryQueryTime = new Histogram({
  name: 'stand_history_query_duration_seconds',
  help: 'Time taken to query stand history',
  labelNames: ['stand_id', 'cache_hit'],
  buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5]
});

const activeStandStatuses = new Gauge({
  name: 'active_stand_statuses',
  help: 'Number of stands in each status',
  labelNames: ['organization_id', 'status']
});

const cacheHitRate = new Gauge({
  name: 'cache_hit_rate',
  help: 'Cache hit rate percentage',
  labelNames: ['cache_type']
});

// Metrics collection functions
export const trackStandStatusChange = (standId: string, fromStatus: string, toStatus: string, changeSource: string) => {
  standStatusChanges.labels(standId, fromStatus, toStatus, changeSource).inc();
};

export const trackWorkRequestProcessing = (operation: string, status: string, durationMs: number) => {
  workRequestProcessingTime.labels(operation, status).observe(durationMs / 1000);
};

export const trackStandHistoryQuery = (standId: string, cacheHit: boolean, durationMs: number) => {
  standHistoryQueryTime.labels(standId, cacheHit.toString()).observe(durationMs / 1000);
};

export const updateActiveStandStatuses = async (organizationId: string, statusCounts: { [status: string]: number }) => {
  // Reset all gauges for this organization
  activeStandStatuses.reset();
  
  // Set new values
  Object.entries(statusCounts).forEach(([status, count]) => {
    activeStandStatuses.labels(organizationId, status).set(count);
  });
};

export const updateCacheHitRate = (cacheType: string, hitRate: number) => {
  cacheHitRate.labels(cacheType).set(hitRate);
};
```

### Health Checks
```typescript
import { Request, Response } from 'express';
import { Pool } from 'pg';
import { Redis } from 'ioredis';

interface HealthCheckResult {
  status: 'healthy' | 'unhealthy';
  timestamp: string;
  services: {
    database: {
      status: 'healthy' | 'unhealthy';
      responseTime: number;
      error?: string;
    };
    redis: {
      status: 'healthy' | 'unhealthy';
      responseTime: number;
      error?: string;
    };
    eventSystem: {
      status: 'healthy' | 'unhealthy';
      responseTime: number;
      error?: string;
    };
  };
  metrics: {
    activeConnections: number;
    cacheHitRate: number;
    averageResponseTime: number;
  };
}

class HealthCheckService {
  private db: Pool;
  private redis: Redis;
  
  constructor(db: Pool, redis: Redis) {
    this.db = db;
    this.redis = redis;
  }
  
  async performHealthCheck(): Promise<HealthCheckResult> {
    const timestamp = new Date().toISOString();
    const services = {
      database: await this.checkDatabase(),
      redis: await this.checkRedis(),
      eventSystem: await this.checkEventSystem()
    };
    
    const overallStatus = Object.values(services).every(service => service.status === 'healthy') 
      ? 'healthy' 
      : 'unhealthy';
    
    const metrics = await this.collectMetrics();
    
    return {
      status: overallStatus,
      timestamp,
      services,
      metrics
    };
  }
  
  private async checkDatabase(): Promise<any> {
    const startTime = Date.now();
    
    try {
      await this.db.query('SELECT 1');
      return {
        status: 'healthy',
        responseTime: Date.now() - startTime
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        responseTime: Date.now() - startTime,
        error: error.message
      };
    }
  }
  
  private async checkRedis(): Promise<any> {
    const startTime = Date.now();
    
    try {
      await this.redis.ping();
      return {
        status: 'healthy',
        responseTime: Date.now() - startTime
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        responseTime: Date.now() - startTime,
        error: error.message
      };
    }
  }
  
  private async checkEventSystem(): Promise<any> {
    const startTime = Date.now();
    
    try {
      // Test event publishing
      await this.redis.publish('health_check', JSON.stringify({ timestamp: new Date().toISOString() }));
      return {
        status: 'healthy',
        responseTime: Date.now() - startTime
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        responseTime: Date.now() - startTime,
        error: error.message
      };
    }
  }
  
  private async collectMetrics(): Promise<any> {
    try {
      const dbStats = await this.db.query('SELECT numbackends FROM pg_stat_database WHERE datname = current_database()');
      const redisInfo = await this.redis.info('stats');
      
      return {
        activeConnections: dbStats.rows[0]?.numbackends || 0,
        cacheHitRate: this.parseCacheHitRate(redisInfo),
        averageResponseTime: await this.calculateAverageResponseTime()
      };
    } catch (error) {
      return {
        activeConnections: 0,
        cacheHitRate: 0,
        averageResponseTime: 0
      };
    }
  }
  
  private parseCacheHitRate(redisInfo: string): number {
    const match = redisInfo.match(/keyspace_hits:(\d+)/);
    const hits = match ? parseInt(match[1]) : 0;
    
    const missMatch = redisInfo.match(/keyspace_misses:(\d+)/);
    const misses = missMatch ? parseInt(missMatch[1]) : 0;
    
    const total = hits + misses;
    return total > 0 ? (hits / total) * 100 : 0;
  }
  
  private async calculateAverageResponseTime(): Promise<number> {
    // This would typically come from your metrics system
    // For now, return a placeholder
    return 150; // milliseconds
  }
}

export const healthCheckHandler = async (req: Request, res: Response): Promise<void> => {
  const healthCheck = new HealthCheckService(req.app.locals.db, req.app.locals.redis);
  const result = await healthCheck.performHealthCheck();
  
  const statusCode = result.status === 'healthy' ? 200 : 503;
  res.status(statusCode).json(result);
};
```

## Deployment Configuration

### Docker Configuration
```dockerfile
# Dockerfile for Stand History Service
FROM node:20-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY src/ ./src/

# Build TypeScript
RUN npm run build

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Change ownership
RUN chown -R nodejs:nodejs /app
USER nodejs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Start application
CMD ["node", "dist/main.js"]
```

### Kubernetes Deployment
```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: stand-history-service
  labels:
    app: stand-history-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: stand-history-service
  template:
    metadata:
      labels:
        app: stand-history-service
    spec:
      containers:
      - name: stand-history-service
        image: stand-history-service:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secret
              key: secret
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: logs
          mountPath: /app/logs
      volumes:
      - name: logs
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: stand-history-service
spec:
  selector:
    app: stand-history-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: stand-history-service-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: api.capacity-planner.com
    http:
      paths:
      - path: /api/v1/stands
        pathType: Prefix
        backend:
          service:
            name: stand-history-service
            port:
              number: 80
```

### Database Migration Scripts
```sql
-- Migration: 20250115_add_stand_history_integration.sql
BEGIN;

-- Add stand status impact to work requests
ALTER TABLE work.work_requests 
ADD COLUMN IF NOT EXISTS stand_status_impact VARCHAR(20) DEFAULT 'no_impact',
ADD COLUMN IF NOT EXISTS scheduled_status_change TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS actual_start_date TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS actual_end_date TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS stand_impact_details JSONB DEFAULT '{}';

-- Add constraint for stand status impact
ALTER TABLE work.work_requests 
ADD CONSTRAINT work_requests_stand_status_impact_check 
CHECK (stand_status_impact IN ('no_impact', 'partial_restriction', 'full_closure', 'emergency_closure'));

-- Create stand status history table
CREATE TABLE IF NOT EXISTS assets.stand_status_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL,
  stand_id UUID NOT NULL,
  stand_code VARCHAR(20) NOT NULL,
  from_status VARCHAR(30),
  to_status VARCHAR(30) NOT NULL,
  status_reason TEXT,
  impact_level VARCHAR(20) NOT NULL DEFAULT 'no_impact',
  effective_from TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  effective_to TIMESTAMP WITH TIME ZONE,
  scheduled_change BOOLEAN DEFAULT false,
  work_request_id UUID,
  work_request_title VARCHAR(200),
  work_type VARCHAR(50),
  operational_impact JSONB DEFAULT '{}',
  adjacent_stands_affected JSONB DEFAULT '[]',
  terminal_impact JSONB DEFAULT '{}',
  change_reason VARCHAR(100),
  change_source VARCHAR(50) NOT NULL DEFAULT 'work_request',
  automated_change BOOLEAN DEFAULT true,
  override_reason TEXT,
  created_by UUID NOT NULL,
  created_by_name VARCHAR(100) NOT NULL,
  
  CONSTRAINT stand_status_history_dates_check CHECK (
    effective_to IS NULL OR effective_from < effective_to
  ),
  CONSTRAINT stand_status_history_status_check CHECK (
    to_status IN ('operational', 'maintenance', 'closed', 'emergency', 'restricted')
  )
);

-- Create indexes
CREATE INDEX idx_stand_status_history_stand ON assets.stand_status_history(stand_id, effective_from DESC);
CREATE INDEX idx_stand_status_history_work_request ON assets.stand_status_history(work_request_id);
CREATE INDEX idx_stand_status_history_org_status ON assets.stand_status_history(organization_id, to_status, effective_from DESC);
CREATE INDEX idx_stand_status_history_effective ON assets.stand_status_history(effective_from, effective_to);
CREATE INDEX idx_stand_status_history_current ON assets.stand_status_history(stand_id, effective_from DESC) WHERE effective_to IS NULL;

-- GIN indexes for JSONB fields
CREATE INDEX idx_stand_status_history_operational_impact ON assets.stand_status_history USING gin(operational_impact);
CREATE INDEX idx_stand_status_history_adjacent_stands ON assets.stand_status_history USING gin(adjacent_stands_affected);

-- Create stand maintenance analytics table
CREATE TABLE IF NOT EXISTS assets.stand_maintenance_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL,
  stand_id UUID NOT NULL,
  calculation_date DATE NOT NULL DEFAULT CURRENT_DATE,
  total_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  planned_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  unplanned_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  emergency_maintenance_hours DECIMAL(10,2) DEFAULT 0,
  total_work_requests INTEGER DEFAULT 0,
  completed_work_requests INTEGER DEFAULT 0,
  cancelled_work_requests INTEGER DEFAULT 0,
  average_completion_time_hours DECIMAL(10,2),
  total_maintenance_cost DECIMAL(12,2) DEFAULT 0,
  average_cost_per_request DECIMAL(10,2),
  budget_utilization_percentage DECIMAL(5,2),
  mtbf_hours DECIMAL(10,2),
  mttr_hours DECIMAL(10,2),
  availability_percentage DECIMAL(5,2),
  maintenance_trend VARCHAR(20) DEFAULT 'stable',
  cost_trend VARCHAR(20) DEFAULT 'stable',
  frequency_trend VARCHAR(20) DEFAULT 'stable',
  calculation_period_days INTEGER DEFAULT 30,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(organization_id, stand_id, calculation_date)
);

-- Create indexes for analytics
CREATE INDEX idx_stand_maintenance_analytics_stand ON assets.stand_maintenance_analytics(stand_id, calculation_date DESC);
CREATE INDEX idx_stand_maintenance_analytics_org ON assets.stand_maintenance_analytics(organization_id, calculation_date DESC);
CREATE INDEX idx_stand_maintenance_analytics_metrics ON assets.stand_maintenance_analytics(mtbf_hours, mttr_hours, availability_percentage);

-- Create views
CREATE OR REPLACE VIEW assets.stand_work_request_history AS
SELECT 
  s.id as stand_id,
  s.code as stand_code,
  s.name as stand_name,
  wr.id as work_request_id,
  wr.title,
  wr.description,
  wr.work_type,
  wr.category,
  wr.priority,
  wr.status,
  wr.stand_status_impact,
  wr.requested_start_date,
  wr.requested_end_date,
  wr.actual_start_date,
  wr.actual_end_date,
  wr.estimated_total_cost,
  wr.requested_by,
  wr.requestor_name,
  wr.created_at,
  wr.updated_at,
  wr.submission_date,
  wr.approved_date,
  wr.completed_date,
  CASE 
    WHEN wr.actual_end_date IS NOT NULL AND wr.actual_start_date IS NOT NULL 
    THEN EXTRACT(EPOCH FROM (wr.actual_end_date - wr.actual_start_date))/3600
    ELSE NULL
  END as actual_duration_hours,
  CASE 
    WHEN wr.status = 'completed' THEN 'completed'
    WHEN wr.status = 'in_progress' THEN 'current'
    WHEN wr.status = 'approved' AND wr.requested_start_date > now() THEN 'future'
    ELSE 'historical'
  END as timeline_category
FROM assets.stands s
JOIN work.work_request_stand_associations wrsa ON s.id = wrsa.stand_id
JOIN work.work_requests wr ON wrsa.work_request_id = wr.id
WHERE s.organization_id = wr.organization_id;

CREATE OR REPLACE VIEW assets.stand_current_status AS
SELECT DISTINCT ON (s.id)
  s.id as stand_id,
  s.code as stand_code,
  s.name as stand_name,
  s.organization_id,
  COALESCE(ssh.to_status, 'operational') as current_status,
  ssh.status_reason,
  ssh.impact_level,
  ssh.work_request_id,
  ssh.work_request_title,
  ssh.work_type,
  ssh.effective_from as status_since,
  ssh.effective_to as status_until,
  ssh.operational_impact,
  ssh.change_source,
  ssh.automated_change,
  EXTRACT(EPOCH FROM (now() - ssh.effective_from))/3600 as hours_in_status,
  CASE 
    WHEN ssh.effective_to IS NOT NULL AND ssh.effective_to <= now() + INTERVAL '24 hours' 
    THEN true 
    ELSE false 
  END as status_change_imminent
FROM assets.stands s
LEFT JOIN assets.stand_status_history ssh ON s.id = ssh.stand_id 
  AND (ssh.effective_to IS NULL OR ssh.effective_to > now())
ORDER BY s.id, ssh.effective_from DESC;

-- Add current_status column to stands table if it doesn't exist
ALTER TABLE assets.stands 
ADD COLUMN IF NOT EXISTS current_status VARCHAR(30) DEFAULT 'operational',
ADD COLUMN IF NOT EXISTS status_updated_at TIMESTAMP WITH TIME ZONE DEFAULT now();

-- Create index for current status
CREATE INDEX IF NOT EXISTS idx_stands_current_status ON assets.stands(organization_id, current_status);

-- Create function to update stand analytics
CREATE OR REPLACE FUNCTION update_stand_analytics(p_stand_id UUID, p_organization_id UUID)
RETURNS VOID AS $$
BEGIN
  INSERT INTO assets.stand_maintenance_analytics (
    organization_id,
    stand_id,
    calculation_date,
    total_work_requests,
    completed_work_requests,
    cancelled_work_requests,
    average_completion_time_hours,
    total_maintenance_cost,
    average_cost_per_request
  )
  SELECT 
    p_organization_id,
    p_stand_id,
    CURRENT_DATE,
    COUNT(*),
    COUNT(*) FILTER (WHERE status = 'completed'),
    COUNT(*) FILTER (WHERE status = 'cancelled'),
    AVG(EXTRACT(EPOCH FROM (actual_end_date - actual_start_date))/3600) 
      FILTER (WHERE actual_end_date IS NOT NULL AND actual_start_date IS NOT NULL),
    SUM(estimated_total_cost) FILTER (WHERE status = 'completed'),
    AVG(estimated_total_cost) FILTER (WHERE status = 'completed')
  FROM work.work_requests wr
  JOIN work.work_request_stand_associations wrsa ON wr.id = wrsa.work_request_id
  WHERE wrsa.stand_id = p_stand_id 
    AND wr.organization_id = p_organization_id
    AND wr.created_at >= CURRENT_DATE - INTERVAL '30 days'
  ON CONFLICT (organization_id, stand_id, calculation_date)
  DO UPDATE SET
    total_work_requests = EXCLUDED.total_work_requests,
    completed_work_requests = EXCLUDED.completed_work_requests,
    cancelled_work_requests = EXCLUDED.cancelled_work_requests,
    average_completion_time_hours = EXCLUDED.average_completion_time_hours,
    total_maintenance_cost = EXCLUDED.total_maintenance_cost,
    average_cost_per_request = EXCLUDED.average_cost_per_request,
    last_updated = now();
END;
$$ LANGUAGE plpgsql;

COMMIT;
```

## Success Metrics and KPIs

### Technical Success Metrics
- **API Response Time**: <200ms for stand history queries, <500ms for status updates
- **Database Query Performance**: <100ms for single stand queries, <500ms for complex analytics
- **Cache Hit Rate**: >85% for frequently accessed stand data
- **Event Processing Time**: <1 second for status change propagation
- **System Availability**: >99.5% uptime for stand history services

### Business Success Metrics
- **Data Completeness**: 100% of work requests linked to stand history
- **Status Accuracy**: >99% accuracy in automated status updates
- **User Adoption**: >90% of maintenance staff using stand history features
- **Operational Efficiency**: 25% reduction in manual status tracking
- **Decision Making**: 40% faster maintenance planning with historical insights

### Security and Compliance Metrics
- **Audit Trail Completeness**: 100% of status changes logged
- **Data Integrity**: Zero data inconsistencies between work requests and stand status
- **Access Control**: <0.1% unauthorized access attempts
- **Compliance Reporting**: 100% of regulatory reports generated successfully

---

This comprehensive TDD provides the complete technical foundation for implementing the Stand Maintenance History & Status Integration feature. The design ensures scalability, performance, and maintainability while providing seamless integration between work requests and stand management systems. The implementation includes robust event-driven architecture, comprehensive caching strategies, and extensive monitoring capabilities to ensure reliable operation in production environments. 